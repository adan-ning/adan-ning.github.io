<!DOCTYPE html>
<html lang="zh-CN">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="robots" content="noodp" />
        <title>计算机组成(第二章) - 蓝Q曦的博客网站</title><meta name="Description" content="这是我的全新 Hugo 网站"><meta property="og:title" content="计算机组成(第二章)" />
<meta property="og:description" content="数据与文字的表示方法 数据格式 分类 符号数据：非数字符号的表示(ASCII,汉字，图形等) 数值数据：数字数据的表示方式(定点，浮点) 计算机数字和" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://adan-ning.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%862/" /><meta property="og:image" content="https://adan-ning.github.io/logo.png" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-03-16T00:00:00+00:00" />
<meta property="article:modified_time" content="2024-03-16T00:00:00+00:00" /><meta property="og:site_name" content="我的网站" />

<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:image" content="https://adan-ning.github.io/logo.png" /><meta name="twitter:title" content="计算机组成(第二章)"/>
<meta name="twitter:description" content="数据与文字的表示方法 数据格式 分类 符号数据：非数字符号的表示(ASCII,汉字，图形等) 数值数据：数字数据的表示方式(定点，浮点) 计算机数字和"/>
<meta name="application-name" content="我的网站">
<meta name="apple-mobile-web-app-title" content="我的网站"><meta name="theme-color" content="#ffffff"><meta name="msapplication-TileColor" content="#da532c"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" />
        <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
        <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5"><link rel="manifest" href="/site.webmanifest"><link rel="canonical" href="https://adan-ning.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%862/" /><link rel="prev" href="https://adan-ning.github.io/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A12/" /><link rel="next" href="https://adan-ning.github.io/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%863/" /><link rel="stylesheet" href="/css/style.min.css"><link rel="preload" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
        <noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css"></noscript><link rel="preload" href="https://cdn.jsdelivr.net/npm/animate.css@4.1.1/animate.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
        <noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@4.1.1/animate.min.css"></noscript><script type="application/ld+json">
    {
        "@context": "http://schema.org",
        "@type": "BlogPosting",
        "headline": "计算机组成(第二章)",
        "inLanguage": "zh-CN",
        "mainEntityOfPage": {
            "@type": "WebPage",
            "@id": "https:\/\/adan-ning.github.io\/posts\/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%862\/"
        },"genre": "posts","keywords": "计算机组成原理","wordcount":  11238 ,
        "url": "https:\/\/adan-ning.github.io\/posts\/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%862\/","datePublished": "2024-03-16T00:00:00+00:00","dateModified": "2024-03-16T00:00:00+00:00","publisher": {
            "@type": "Organization",
            "name": ""},"author": {
                "@type": "Person",
                "name": "蓝Q曦"
            },"description": ""
    }
    </script></head>
    <body data-header-desktop="fixed" data-header-mobile="auto"><script type="text/javascript">(window.localStorage && localStorage.getItem('theme') ? localStorage.getItem('theme') === 'dark' : ('auto' === 'auto' ? window.matchMedia('(prefers-color-scheme: dark)').matches : 'auto' === 'dark')) && document.body.setAttribute('theme', 'dark');</script>

        <div id="mask"></div><div class="wrapper"><header class="desktop" id="header-desktop">
    <div class="header-wrapper">
        <div class="header-title">
            <a href="/" title="蓝Q曦的博客网站"><span id="id-1" class="typeit"></span></a>
        </div>
        <div class="menu">
            <div class="menu-inner"><a class="menu-item" href="/posts/"> 文章 </a><a class="menu-item" href="/tags/"> 标签 </a><a class="menu-item" href="/categories/"> 分类 </a><span class="menu-item delimiter"></span><span class="menu-item search" id="search-desktop">
                        <input type="text" placeholder="Search titles or contents..." id="search-input-desktop">
                        <a href="javascript:void(0);" class="search-button search-toggle" id="search-toggle-desktop" title="Search">
                            <i class="fas fa-search fa-fw" aria-hidden="true"></i>
                        </a>
                        <a href="javascript:void(0);" class="search-button search-clear" id="search-clear-desktop" title="Clear">
                            <i class="fas fa-times-circle fa-fw" aria-hidden="true"></i>
                        </a>
                        <span class="search-button search-loading" id="search-loading-desktop">
                            <i class="fas fa-spinner fa-fw fa-spin" aria-hidden="true"></i>
                        </span>
                    </span><a href="javascript:void(0);" class="menu-item theme-switch" title="Switch Theme">
                    <i class="fas fa-adjust fa-fw" aria-hidden="true"></i>
                </a></div>

        </div>
    </div>
</header><header class="mobile" id="header-mobile">
    <div class="header-container">
        <div class="header-wrapper">
            <div class="header-title">
                <a href="/" title="蓝Q曦的博客网站"><span id="id-2" class="typeit"></span></a>
            </div>
            <div class="menu-toggle" id="menu-toggle-mobile">
                <span></span><span></span><span></span>
            </div>
        </div>
        <div class="menu" id="menu-mobile"><div class="search-wrapper">
                    <div class="search mobile" id="search-mobile">
                        <input type="text" placeholder="Search titles or contents..." id="search-input-mobile">
                        <a href="javascript:void(0);" class="search-button search-toggle" id="search-toggle-mobile" title="Search">
                            <i class="fas fa-search fa-fw" aria-hidden="true"></i>
                        </a>
                        <a href="javascript:void(0);" class="search-button search-clear" id="search-clear-mobile" title="Clear">
                            <i class="fas fa-times-circle fa-fw" aria-hidden="true"></i>
                        </a>
                        <span class="search-button search-loading" id="search-loading-mobile">
                            <i class="fas fa-spinner fa-fw fa-spin" aria-hidden="true"></i>
                        </span>
                    </div>
                    <a href="javascript:void(0);" class="search-cancel" id="search-cancel-mobile">
                        Cancel
                    </a>
                </div><a class="menu-item" href="/posts/" title="">文章</a><a class="menu-item" href="/tags/" title="">标签</a><a class="menu-item" href="/categories/" title="">分类</a><a href="javascript:void(0);" class="menu-item theme-switch" title="Switch Theme">
                <i class="fas fa-adjust fa-fw" aria-hidden="true"></i>
            </a></div>
    </div>
</header><div class="search-dropdown desktop">
        <div id="search-dropdown-desktop"></div>
    </div>
    <div class="search-dropdown mobile">
        <div id="search-dropdown-mobile"></div>
    </div><main class="main">
                <div class="container"><div class="toc" id="toc-auto">
            <h2 class="toc-title">Contents</h2>
            <div class="toc-content" id="toc-content-auto"></div>
        </div><article class="page single"><h1 class="single-title animate__animated animate__flipInX">计算机组成(第二章)</h1><div class="post-meta">
            <div class="post-meta-line"><span class="post-author"><a href="/" title="Author" rel="author" class="author"><i class="fas fa-user-circle fa-fw" aria-hidden="true"></i>蓝Q曦</a></span>&nbsp;<span class="post-category">included in <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"><i class="far fa-folder fa-fw" aria-hidden="true"></i>计算机组成原理</a></span></div>
            <div class="post-meta-line"><i class="far fa-calendar-alt fa-fw" aria-hidden="true"></i>&nbsp;<time datetime="2024-03-16">2024-03-16</time>&nbsp;<i class="fas fa-pencil-alt fa-fw" aria-hidden="true"></i>&nbsp;11238 words&nbsp;
                <i class="far fa-clock fa-fw" aria-hidden="true"></i>&nbsp;23 minutes&nbsp;</div>
        </div><div class="details toc" id="toc-static"  data-kept="true">
                <div class="details-summary toc-title">
                    <span>Contents</span>
                    <span><i class="details-icon fas fa-angle-right" aria-hidden="true"></i></span>
                </div>
                <div class="details-content toc-content" id="toc-content-static"><nav id="TableOfContents">
  <ul>
    <li><a href="#数据格式">数据格式</a>
      <ul>
        <li><a href="#分类">分类</a></li>
        <li><a href="#编码">编码</a></li>
      </ul>
    </li>
    <li><a href="#数值数据">数值数据</a></li>
    <li><a href="#常用的表示方法">常用的表示方法</a>
      <ul>
        <li><a href="#定点表示法">定点表示法</a></li>
        <li><a href="#浮点表示">浮点表示</a></li>
        <li><a href="#ieee754标准规定了浮点数的表示规格运算规则等">IEEE754标准(规定了浮点数的表示规格，运算规则等)</a></li>
      </ul>
    </li>
    <li><a href="#数的机器码表示">数的机器码表示</a>
      <ul>
        <li><a href="#数的机器码表示-1">数的机器码表示</a></li>
        <li><a href="#原码表示法">原码表示法</a></li>
        <li><a href="#反码表示法">反码表示法</a></li>
        <li><a href="#补码表示法">补码表示法</a></li>
        <li><a href="#移码表示法用在阶码中">移码表示法(用在阶码中)</a></li>
      </ul>
    </li>
    <li><a href="#字符和字符串非数值的表示方法">字符和字符串(非数值)的表示方法</a></li>
    <li><a href="#奇偶校验概念">奇偶校验概念</a></li>
    <li><a href="#crc循环冗余校验">CRC循环冗余校验</a></li>
    <li><a href="#定点加法减法运算">定点加法，减法运算</a>
      <ul>
        <li><a href="#补码加减法">补码加减法</a></li>
      </ul>
    </li>
    <li><a href="#溢出的检测">溢出的检测</a></li>
    <li><a href="#基本的加法器">基本的加法器</a>
      <ul>
        <li><a href="#各种逻辑的图形符号">各种逻辑的图形符号</a></li>
        <li><a href="#串行加法器">串行加法器</a></li>
      </ul>
    </li>
    <li><a href="#定点乘法运算">定点乘法运算</a>
      <ul>
        <li><a href="#定点原码乘法原理">定点原码乘法原理</a></li>
        <li><a href="#由手工计算到机器运算">由手工计算到机器运算</a></li>
        <li><a href="#原码一位乘法">原码一位乘法</a></li>
        <li><a href="#算法流程">算法流程</a></li>
        <li><a href="#原码一位乘法的硬件实现">原码一位乘法的硬件实现</a></li>
      </ul>
    </li>
    <li><a href="#补码一位乘法">补码一位乘法</a>
      <ul>
        <li><a href="#比较法booth乘法">比较法(BOOTH乘法)</a></li>
        <li><a href="#booth乘法规则">BOOTH乘法规则</a></li>
        <li><a href="#补码一位乘法的硬件实现">补码一位乘法的硬件实现</a></li>
      </ul>
    </li>
    <li><a href="#阵列乘法器">阵列乘法器</a>
      <ul>
        <li><a href="#不带符号的阵列乘法器">不带符号的阵列乘法器</a></li>
        <li><a href="#带符号位的阵列乘法器">带符号位的阵列乘法器</a></li>
      </ul>
    </li>
    <li><a href="#定点除法运算">定点除法运算</a></li>
    <li><a href="#原码恢复余数法">原码恢复余数法</a></li>
    <li><a href="#原码不恢复余数法加减交替法">原码不恢复余数法(加减交替法)</a></li>
    <li><a href="#阵列除法器">阵列除法器</a></li>
    <li><a href="#原理">原理</a></li>
    <li><a href="#定点运算器的组成">定点运算器的组成</a>
      <ul>
        <li><a href="#算术逻辑运算部件alu">算术逻辑运算部件ALU</a></li>
      </ul>
    </li>
    <li><a href="#多功能算术逻辑部件alu">多功能算术逻辑部件ALU</a>
      <ul>
        <li><a href="#算术逻辑部件alu">算术逻辑部件ALU</a></li>
      </ul>
    </li>
    <li><a href="#浮点运算方法和浮点运算器">浮点运算方法和浮点运算器</a>
      <ul>
        <li><a href="#浮点加法减法运算">浮点加法、减法运算</a></li>
        <li><a href="#浮点乘法和除法运算">浮点乘法和除法运算</a></li>
      </ul>
    </li>
    <li><a href="#本-章-小-结">本 章 小 结</a></li>
  </ul>
</nav></div>
            </div><div class="content" id="content"><h1 id="数据与文字的表示方法">数据与文字的表示方法</h1>
<h2 id="数据格式">数据格式</h2>
<h3 id="分类">分类</h3>
<p>符号数据：非数字符号的表示(ASCII,汉字，图形等)
数值数据：数字数据的表示方式(定点，浮点)</p>
<p><strong>计算机数字和字符的表示方法有利于数据的存储，加工(处理)，传送</strong></p>
<h3 id="编码">编码</h3>
<p>用少量，简单的基本符号，选择合适的规则表示尽量多的信息，同时利于信息处理(速度，方便)</p>
<h2 id="数值数据">数值数据</h2>
<p>计算机在数据，文字的表示方式时，应该考虑以下几个因素</p>
<ol>
<li>表示的数据类型(符号，小数点，数值)</li>
<li>数值的范围</li>
<li>数值精度</li>
<li>存储，处理，传送的硬件代价</li>
</ol>
<h2 id="常用的表示方法">常用的表示方法</h2>
<h3 id="定点表示法">定点表示法</h3>
<p>所有数据的小数点位置固定不变</p>
<p>理论上位置可以任意，但实际上将数据表示有两种方法(小数点位置固定—定点表示法/定点格式)</p>
<ol>
<li>纯小数</li>
<li>纯整数</li>
</ol>
<p><strong>定点数表示</strong></p>
<ol>
<li>带符号数</li>
<li>不带符号数</li>
</ol>
<h4 id="定点纯整数">定点纯整数</h4>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://cdn.jsdelivr.net/gh/adan-ning/images/202403161314053.jpg"
        data-srcset="https://cdn.jsdelivr.net/gh/adan-ning/images/202403161314053.jpg, https://cdn.jsdelivr.net/gh/adan-ning/images/202403161314053.jpg 1.5x, https://cdn.jsdelivr.net/gh/adan-ning/images/202403161314053.jpg 2x"
        data-sizes="auto"
        alt="https://cdn.jsdelivr.net/gh/adan-ning/images/202403161314053.jpg"
        title="https://cdn.jsdelivr.net/gh/adan-ning/images/202403161314053.jpg" /></p>
<p><strong>表示数的范围是 $0\leqslant|x|\leqslant 2^n-1$</strong></p>
<p><strong>定点表示法的特点</strong></p>
<ol>
<li>定点数表示数的范围受字长限制，表示数的范围有限</li>
<li>定点表示的精度有限</li>
<li>机器中，常用定点纯整数表示</li>
</ol>
<h3 id="浮点表示">浮点表示</h3>
<p>小数点位置随阶码不同而浮动</p>
<p><strong>格式</strong></p>
<p>$N=R^E.M$</p>
<p>基数R，取固定的值，比如10.2等；指数E；尾数M；</p>
<p>机器中表示</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://cdn.jsdelivr.net/gh/adan-ning/images/202403161324679.jpg"
        data-srcset="https://cdn.jsdelivr.net/gh/adan-ning/images/202403161324679.jpg, https://cdn.jsdelivr.net/gh/adan-ning/images/202403161324679.jpg 1.5x, https://cdn.jsdelivr.net/gh/adan-ning/images/202403161324679.jpg 2x"
        data-sizes="auto"
        alt="https://cdn.jsdelivr.net/gh/adan-ning/images/202403161324679.jpg"
        title="https://cdn.jsdelivr.net/gh/adan-ning/images/202403161324679.jpg" /></p>
<h3 id="ieee754标准规定了浮点数的表示规格运算规则等">IEEE754标准(规定了浮点数的表示规格，运算规则等)</h3>
<ol>
<li>规则规定了单精度(32)和双精度(64)的基本格式</li>
<li>规则中，尾数用原码，指数用移码(便于对阶和比较)</li>
</ol>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://cdn.jsdelivr.net/gh/adan-ning/images/202403161328245.jpg"
        data-srcset="https://cdn.jsdelivr.net/gh/adan-ning/images/202403161328245.jpg, https://cdn.jsdelivr.net/gh/adan-ning/images/202403161328245.jpg 1.5x, https://cdn.jsdelivr.net/gh/adan-ning/images/202403161328245.jpg 2x"
        data-sizes="auto"
        alt="https://cdn.jsdelivr.net/gh/adan-ning/images/202403161328245.jpg"
        title="https://cdn.jsdelivr.net/gh/adan-ning/images/202403161328245.jpg" /></p>
<p><strong>基数R=2，基数固定，采用隐含方式来表示它</strong></p>
<p><strong>32位的浮点数</strong></p>
<ol>
<li>S是数的符号位，1位，在最高位，“0”表示正数，“1”表示负数。</li>
<li>M是尾数，23位，在低位部分，采用纯小数表示</li>
<li>E是阶码，8位，采用移码表示。移码比较大小方便</li>
<li>指数偏移，127</li>
</ol>
<p><strong>64位的浮点数</strong></p>
<p>符号位1位，阶码域11位，尾数域52位，指数偏移值是1023.</p>
<p>因此规格化的64位浮点数x的真值为：</p>
<p>$x=(-1)^S\times(1.M)\times2^{E-1023}$</p>
<p>e=E-1023</p>
<p><strong>一个规格化的32位浮点数x的真值表示为</strong>：</p>
<p>$x=(-1)^S\times(1.M)\times2^{E-127}$</p>
<p>e=E-127</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://cdn.jsdelivr.net/gh/adan-ning/images/202403161346491.jpg"
        data-srcset="https://cdn.jsdelivr.net/gh/adan-ning/images/202403161346491.jpg, https://cdn.jsdelivr.net/gh/adan-ning/images/202403161346491.jpg 1.5x, https://cdn.jsdelivr.net/gh/adan-ning/images/202403161346491.jpg 2x"
        data-sizes="auto"
        alt="https://cdn.jsdelivr.net/gh/adan-ning/images/202403161346491.jpg"
        title="https://cdn.jsdelivr.net/gh/adan-ning/images/202403161346491.jpg" /></p>
<p>例题：</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://cdn.jsdelivr.net/gh/adan-ning/images/202403161354654.png"
        data-srcset="https://cdn.jsdelivr.net/gh/adan-ning/images/202403161354654.png, https://cdn.jsdelivr.net/gh/adan-ning/images/202403161354654.png 1.5x, https://cdn.jsdelivr.net/gh/adan-ning/images/202403161354654.png 2x"
        data-sizes="auto"
        alt="https://cdn.jsdelivr.net/gh/adan-ning/images/202403161354654.png"
        title="https://cdn.jsdelivr.net/gh/adan-ning/images/202403161354654.png" /></p>
<h2 id="数的机器码表示">数的机器码表示</h2>
<h3 id="数的机器码表示-1">数的机器码表示</h3>
<p>真值：一般书写的数</p>
<p>机器码：机器中表示的数，要解决在计算机内部数的正，负符号和小数点的运算问题</p>
<p>原码，反码，补码，移码</p>
<h3 id="原码表示法">原码表示法</h3>
<p><strong>原码特点</strong></p>
<p>将真值的正负号换成1和0，表示简单，易于同真值之间进行转换</p>
<p>实现乘除运算规则简单</p>
<p>进行加减运算十分麻烦，做减法无法求解正确结果&hellip;&hellip;</p>
<h3 id="反码表示法">反码表示法</h3>
<p><strong>定义</strong></p>
<p>正数的表示与原，补码相同，负数的补码符号位为1，数值位是将原码的数值按位取反，就得到该数的反码表示</p>
<p>电路容易实现，触发器的输出有正负之分</p>
<h3 id="补码表示法">补码表示法</h3>
<p>补码是在“模”和“同余”的概念下导出的(&ldquo;模&quot;是指一个计量单位的计量系统的计量范围，即产生“溢出”的量。)</p>
<p><strong>定义</strong></p>
<p>正数的补码就是正数本身，负数的补码是原负数加上模。</p>
<p>计算机运算受字长限制，属于有模运算</p>
<ol>
<li>定点小数$x_0x_1x_2&hellip;&hellip;x_n$溢出量为2，以2为模(周期)</li>
<li>定点整数$x_0x_1x_2&hellip;&hellip;x_n$溢出量为$2^{n+1}$，以$2{n+1}$为模(周期)</li>
</ol>
<p>定点小数$x_0x_1x_2&hellip;&hellip;x_n$</p>
<p>$[x]_补=\begin{cases}x,1&gt;x\geq-1\2+x,0\geq x \geq -1\end{cases}$</p>
<p>$符号\begin{cases}0,正数\1,负数\end{cases}$</p>
<p><strong>补码性质</strong></p>
<ol>
<li>高位表示正负</li>
<li>正数补码，尾数与原码相同</li>
<li>范围$-2^n\sim2^n-1$(定点正数)</li>
<li>无正负0之分</li>
</ol>
<p>变形补码(双符号补码)</p>
<p>为了防止溢出而设定</p>
<p><strong>结论</strong></p>
<p>若运算结果超出了计算机所能表示的数值范围，则只保留它的小于模的低n位的数值，超过n位的高位部分就自动舍弃了。</p>
<h3 id="移码表示法用在阶码中">移码表示法(用在阶码中)</h3>
<p>定点整数定义：$[x]_移=2^n+x$ ($2^n&gt;x\geq-2^n$)</p>
<p>00000000~11111111($-2^n\sim 2^n-1$)</p>
<p>例：</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://cdn.jsdelivr.net/gh/adan-ning/images/202403181459115.jpg"
        data-srcset="https://cdn.jsdelivr.net/gh/adan-ning/images/202403181459115.jpg, https://cdn.jsdelivr.net/gh/adan-ning/images/202403181459115.jpg 1.5x, https://cdn.jsdelivr.net/gh/adan-ning/images/202403181459115.jpg 2x"
        data-sizes="auto"
        alt="https://cdn.jsdelivr.net/gh/adan-ning/images/202403181459115.jpg"
        title="https://cdn.jsdelivr.net/gh/adan-ning/images/202403181459115.jpg" />  <img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://cdn.jsdelivr.net/gh/adan-ning/images/202403181500904.jpg"
        data-srcset="https://cdn.jsdelivr.net/gh/adan-ning/images/202403181500904.jpg, https://cdn.jsdelivr.net/gh/adan-ning/images/202403181500904.jpg 1.5x, https://cdn.jsdelivr.net/gh/adan-ning/images/202403181500904.jpg 2x"
        data-sizes="auto"
        alt="https://cdn.jsdelivr.net/gh/adan-ning/images/202403181500904.jpg"
        title="https://cdn.jsdelivr.net/gh/adan-ning/images/202403181500904.jpg" /></p>
<p><strong>特点</strong></p>
<p>移码和补码尾数相同，符号位相反</p>
<p><strong>范围</strong></p>
<p>$-2^n\sim 2^n-1$</p>
<p>例：以定点整数为例，用数轴形式说明原码，反码，补码表示范围和可能的数码组合情况</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://cdn.jsdelivr.net/gh/adan-ning/images/202403181505085.jpg"
        data-srcset="https://cdn.jsdelivr.net/gh/adan-ning/images/202403181505085.jpg, https://cdn.jsdelivr.net/gh/adan-ning/images/202403181505085.jpg 1.5x, https://cdn.jsdelivr.net/gh/adan-ning/images/202403181505085.jpg 2x"
        data-sizes="auto"
        alt="https://cdn.jsdelivr.net/gh/adan-ning/images/202403181505085.jpg"
        title="https://cdn.jsdelivr.net/gh/adan-ning/images/202403181505085.jpg" /></p>
<p>例：将十进制真值(-127,-1,0,+1,+127)列表表示成二进制数及原码，反码，补码，移码值(要求8位)</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://cdn.jsdelivr.net/gh/adan-ning/images/202403181508187.jpg"
        data-srcset="https://cdn.jsdelivr.net/gh/adan-ning/images/202403181508187.jpg, https://cdn.jsdelivr.net/gh/adan-ning/images/202403181508187.jpg 1.5x, https://cdn.jsdelivr.net/gh/adan-ning/images/202403181508187.jpg 2x"
        data-sizes="auto"
        alt="https://cdn.jsdelivr.net/gh/adan-ning/images/202403181508187.jpg"
        title="https://cdn.jsdelivr.net/gh/adan-ning/images/202403181508187.jpg" /></p>
<h2 id="字符和字符串非数值的表示方法">字符和字符串(非数值)的表示方法</h2>
<ol>
<li>
<p>符号数据：字符信息用数据表示，如ASCII等</p>
<p>常见的ASCII码用七位二进制表示一个字符，它包括10个十进制数字(0~9)，52个英文大写和小写字母(a ~ z,A~Z)，34个专用符号和32个控制符号，共计128个字符</p>
</li>
<li>
<p>字符表示方法ASCII：用一个字节表示，低7位用来编码(128)，最高位位校验位</p>
</li>
<li>
<p>字符串的存放方法：向量存放法</p>
<p>在存储器中占用一片连续的空间，每个字节存放一个字符代码，字符串的所有元素(字符)在物理上是相邻的。</p>
</li>
</ol>
<h2 id="奇偶校验概念">奇偶校验概念</h2>
<p>奇偶校验码是一种最简单的数据校验码，它的码距等于2，可以检测出一位错误(或奇数位错误)，但不能确定出错的位置，也不能检测出偶数位错误</p>
<p>码距：将两个码字逐位进行对比，具有不同的位的个数，例如01和10，码距为2</p>
<p>奇偶校验实现方法是：有若干为有效信息(如一个字节)，再加上一个二进制位(校验位)组成检验码</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://cdn.jsdelivr.net/gh/adan-ning/images/202403181555330.jpg"
        data-srcset="https://cdn.jsdelivr.net/gh/adan-ning/images/202403181555330.jpg, https://cdn.jsdelivr.net/gh/adan-ning/images/202403181555330.jpg 1.5x, https://cdn.jsdelivr.net/gh/adan-ning/images/202403181555330.jpg 2x"
        data-sizes="auto"
        alt="https://cdn.jsdelivr.net/gh/adan-ning/images/202403181555330.jpg"
        title="https://cdn.jsdelivr.net/gh/adan-ning/images/202403181555330.jpg" /></p>
<h2 id="crc循环冗余校验">CRC循环冗余校验</h2>
<p>循环冗余校验码</p>
<ol>
<li>与奇偶校验码一样只能检错不能纠错</li>
<li>应用于数据通信领域和磁介质存储系统中</li>
<li>利用多项式校验</li>
</ol>
<p>步骤：</p>
<ol>
<li>K=信息码的长度，R=生成多项式最高次幂-&gt;校验码位数N=K+R</li>
<li>生成多项式$G(x)=a<em>x3+b</em>x2+c<em>x1+d</em>x0$，对应二进制码abcd，即为模2除法的除数</li>
<li>信息码左移R位，利用模2除法(上商规则:最高位为1则商1，最高位为0则商0，减法规则：对应位上相同，结果为0，不同，结果为1)，产生余数，将余数补在信息码后形成CRC码，余数某位是1，则该位出错。</li>
</ol>
<h2 id="定点加法减法运算">定点加法，减法运算</h2>
<h3 id="补码加减法">补码加减法</h3>
<p>公式：$[x+y]_补=[x]_补+[y]_补$</p>
<p>补码减法：</p>
<p>为了将减法转变为加法，需证明公式：$[x-y]_补=[x]_补+[-y]_补$</p>
<p>证明：</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://cdn.jsdelivr.net/gh/adan-ning/images/202403181618706.jpg"
        data-srcset="https://cdn.jsdelivr.net/gh/adan-ning/images/202403181618706.jpg, https://cdn.jsdelivr.net/gh/adan-ning/images/202403181618706.jpg 1.5x, https://cdn.jsdelivr.net/gh/adan-ning/images/202403181618706.jpg 2x"
        data-sizes="auto"
        alt="https://cdn.jsdelivr.net/gh/adan-ning/images/202403181618706.jpg"
        title="https://cdn.jsdelivr.net/gh/adan-ning/images/202403181618706.jpg" /></p>
<p><strong>$[X]_补+[Y]_补=[X+Y]_补$证明</strong></p>
<p>假设|x|&lt;1,|y|&lt;1,|x+y|&lt;1</p>
<p>现在分四种情况来证明</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://cdn.jsdelivr.net/gh/adan-ning/images/202403181621019.jpg"
        data-srcset="https://cdn.jsdelivr.net/gh/adan-ning/images/202403181621019.jpg, https://cdn.jsdelivr.net/gh/adan-ning/images/202403181621019.jpg 1.5x, https://cdn.jsdelivr.net/gh/adan-ning/images/202403181621019.jpg 2x"
        data-sizes="auto"
        alt="https://cdn.jsdelivr.net/gh/adan-ning/images/202403181621019.jpg"
        title="https://cdn.jsdelivr.net/gh/adan-ning/images/202403181621019.jpg" /></p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://cdn.jsdelivr.net/gh/adan-ning/images/202403181622273.jpg"
        data-srcset="https://cdn.jsdelivr.net/gh/adan-ning/images/202403181622273.jpg, https://cdn.jsdelivr.net/gh/adan-ning/images/202403181622273.jpg 1.5x, https://cdn.jsdelivr.net/gh/adan-ning/images/202403181622273.jpg 2x"
        data-sizes="auto"
        alt="https://cdn.jsdelivr.net/gh/adan-ning/images/202403181622273.jpg"
        title="https://cdn.jsdelivr.net/gh/adan-ning/images/202403181622273.jpg" /></p>
<p><strong>使用补码加减法求解下列题目</strong></p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://cdn.jsdelivr.net/gh/adan-ning/images/202403181624485.jpg"
        data-srcset="https://cdn.jsdelivr.net/gh/adan-ning/images/202403181624485.jpg, https://cdn.jsdelivr.net/gh/adan-ning/images/202403181624485.jpg 1.5x, https://cdn.jsdelivr.net/gh/adan-ning/images/202403181624485.jpg 2x"
        data-sizes="auto"
        alt="https://cdn.jsdelivr.net/gh/adan-ning/images/202403181624485.jpg"
        title="https://cdn.jsdelivr.net/gh/adan-ning/images/202403181624485.jpg" /></p>
<h2 id="溢出的检测">溢出的检测</h2>
<p><strong>检测方法</strong></p>
<ol>
<li>
<p>双符号位法(参与加减运算的数采用变形补码表示)</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://cdn.jsdelivr.net/gh/adan-ning/images/202403181627201.jpg"
        data-srcset="https://cdn.jsdelivr.net/gh/adan-ning/images/202403181627201.jpg, https://cdn.jsdelivr.net/gh/adan-ning/images/202403181627201.jpg 1.5x, https://cdn.jsdelivr.net/gh/adan-ning/images/202403181627201.jpg 2x"
        data-sizes="auto"
        alt="https://cdn.jsdelivr.net/gh/adan-ning/images/202403181627201.jpg"
        title="https://cdn.jsdelivr.net/gh/adan-ning/images/202403181627201.jpg" /></p>
</li>
<li>
<p>单符号位法</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://cdn.jsdelivr.net/gh/adan-ning/images/202403181628915.jpg"
        data-srcset="https://cdn.jsdelivr.net/gh/adan-ning/images/202403181628915.jpg, https://cdn.jsdelivr.net/gh/adan-ning/images/202403181628915.jpg 1.5x, https://cdn.jsdelivr.net/gh/adan-ning/images/202403181628915.jpg 2x"
        data-sizes="auto"
        alt="https://cdn.jsdelivr.net/gh/adan-ning/images/202403181628915.jpg"
        title="https://cdn.jsdelivr.net/gh/adan-ning/images/202403181628915.jpg" /></p>
</li>
</ol>
<h2 id="基本的加法器">基本的加法器</h2>
<p><strong>半加器</strong></p>
<p>$H_i=A_i\bigoplus B_i$</p>
<p>不考虑进位</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://cdn.jsdelivr.net/gh/adan-ning/images/202403181633937.jpg"
        data-srcset="https://cdn.jsdelivr.net/gh/adan-ning/images/202403181633937.jpg, https://cdn.jsdelivr.net/gh/adan-ning/images/202403181633937.jpg 1.5x, https://cdn.jsdelivr.net/gh/adan-ning/images/202403181633937.jpg 2x"
        data-sizes="auto"
        alt="https://cdn.jsdelivr.net/gh/adan-ning/images/202403181633937.jpg"
        title="https://cdn.jsdelivr.net/gh/adan-ning/images/202403181633937.jpg" /></p>
<p><strong>全加器</strong></p>
<p>考虑低位进位$C_{i-1}$和向高位的进位$C_i$</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://cdn.jsdelivr.net/gh/adan-ning/images/202403181638889.jpg"
        data-srcset="https://cdn.jsdelivr.net/gh/adan-ning/images/202403181638889.jpg, https://cdn.jsdelivr.net/gh/adan-ning/images/202403181638889.jpg 1.5x, https://cdn.jsdelivr.net/gh/adan-ning/images/202403181638889.jpg 2x"
        data-sizes="auto"
        alt="https://cdn.jsdelivr.net/gh/adan-ning/images/202403181638889.jpg"
        title="https://cdn.jsdelivr.net/gh/adan-ning/images/202403181638889.jpg" /></p>
<h3 id="各种逻辑的图形符号">各种逻辑的图形符号</h3>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://cdn.jsdelivr.net/gh/adan-ning/images/202403181635960.jpg"
        data-srcset="https://cdn.jsdelivr.net/gh/adan-ning/images/202403181635960.jpg, https://cdn.jsdelivr.net/gh/adan-ning/images/202403181635960.jpg 1.5x, https://cdn.jsdelivr.net/gh/adan-ning/images/202403181635960.jpg 2x"
        data-sizes="auto"
        alt="https://cdn.jsdelivr.net/gh/adan-ning/images/202403181635960.jpg"
        title="https://cdn.jsdelivr.net/gh/adan-ning/images/202403181635960.jpg" /></p>
<h3 id="串行加法器">串行加法器</h3>
<ol>
<li>
<p>将n个全加器相连可得n位加法器，但其加法时间较长。这是因为其位间进位是串行传送的，本位全加和$F_i$必须等低位进位$C_{i-1}$来到后才能进行，加法时间与位数有关</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://cdn.jsdelivr.net/gh/adan-ning/images/202403181643897.jpg"
        data-srcset="https://cdn.jsdelivr.net/gh/adan-ning/images/202403181643897.jpg, https://cdn.jsdelivr.net/gh/adan-ning/images/202403181643897.jpg 1.5x, https://cdn.jsdelivr.net/gh/adan-ning/images/202403181643897.jpg 2x"
        data-sizes="auto"
        alt="https://cdn.jsdelivr.net/gh/adan-ning/images/202403181643897.jpg"
        title="https://cdn.jsdelivr.net/gh/adan-ning/images/202403181643897.jpg" /></p>
</li>
<li>
<p>只有改变进位逐位传送的路径，才能提高加法器工作速度</p>
</li>
<li>
<p>解决办法之一是采用“超前进位产生电路”来同时形成各位进位，从而实现快速加法，我们称这种加法器为超前进位加法器</p>
</li>
</ol>
<h2 id="定点乘法运算">定点乘法运算</h2>
<p><strong>乘法实现方法</strong></p>
<ol>
<li>在现有的加法和减法器的基础上增加适当的以为线路及控制逻辑可以实现</li>
<li>用LSI和VLSI工艺实现专用的乘法器</li>
<li>编制子程序(单片机等低端机器)</li>
</ol>
<p><strong>原理</strong></p>
<ol>
<li>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://cdn.jsdelivr.net/gh/adan-ning/images/202403231029533.png"
        data-srcset="https://cdn.jsdelivr.net/gh/adan-ning/images/202403231029533.png, https://cdn.jsdelivr.net/gh/adan-ning/images/202403231029533.png 1.5x, https://cdn.jsdelivr.net/gh/adan-ning/images/202403231029533.png 2x"
        data-sizes="auto"
        alt="https://cdn.jsdelivr.net/gh/adan-ning/images/202403231029533.png"
        title="https://cdn.jsdelivr.net/gh/adan-ning/images/202403231029533.png" /></p>
</li>
<li>
<p>尾数乘法如下：</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://cdn.jsdelivr.net/gh/adan-ning/images/202403181655551.jpg"
        data-srcset="https://cdn.jsdelivr.net/gh/adan-ning/images/202403181655551.jpg, https://cdn.jsdelivr.net/gh/adan-ning/images/202403181655551.jpg 1.5x, https://cdn.jsdelivr.net/gh/adan-ning/images/202403181655551.jpg 2x"
        data-sizes="auto"
        alt="https://cdn.jsdelivr.net/gh/adan-ning/images/202403181655551.jpg"
        title="https://cdn.jsdelivr.net/gh/adan-ning/images/202403181655551.jpg" /></p>
</li>
</ol>
<h3 id="定点原码乘法原理">定点原码乘法原理</h3>
<ol>
<li>
<p>n位乘n位积可能为2n位</p>
</li>
<li>
<p>乘积的最后是所有部分积之和，有n个数相加，而FA只有两个输入端</p>
<p>所以需要改造</p>
<ol>
<li>方法一：硬件实现方法(串行的“加法和移位”)，硬件结构简单，速度太慢(时间延迟太长)</li>
<li>方法二：不带符号位的阵列乘法器</li>
</ol>
</li>
</ol>
<h3 id="由手工计算到机器运算">由手工计算到机器运算</h3>
<ol>
<li>由手工计算到机器运算，需要解决3个问题：
<ol>
<li>符号如何让处理</li>
<li>多个部分积如何相加</li>
<li>为保持两次部分积之间的位权对应关系，会导致加法器位数的增加，能否在不增加位数的情况下保持位权对应？</li>
</ol>
</li>
<li>由于解决方式的不同，形成了两种主要的乘法器结构
<ol>
<li>采用常规的加法器来实现
<ol>
<li>将n位乘法转换为n次累加和移位，每次处理1位</li>
<li>为避免加法器位数的扩充，可以把手工计算时的新部分积“左移-&gt;累加”改为机器运算的原部分积“累加-&gt;右移”</li>
</ol>
</li>
<li>采用阵列乘法器实现
<ol>
<li>利用中大规模集成电路把多项部分积同时相加，这样结构的乘法器称为阵列乘法器</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="原码一位乘法">原码一位乘法</h3>
<p>原码一位乘法是从手算演变而来的，即用两个操作数的绝对值相乘，乘积的符号为两操作数符号的异或值(同号为正，异号为负)</p>
<p>乘积P=|X|$\times$|Y|</p>
<p>符号$P_s=X_s\bigoplus Y_s$</p>
<p>式中：$P_s$为乘积的符号，$X_s$和$Y_s$为被乘数和乘数的符号</p>
<p><strong>规则</strong></p>
<ol>
<li>参加运算的操作数取其绝对值</li>
<li>令乘数的最低位为判断位，若为&quot;1&rdquo;，加被乘数，若为“0”，不加被乘数(加0)；</li>
<li>累加后的部分积以及乘数右移一位</li>
<li>重复n次(2)和(3)</li>
<li>符号位单独处理，同号为正，异号为负。</li>
</ol>
<p><strong>基本过程</strong></p>
<p>每次将一位乘数所对应的部分积与原部分积的累加和相加并移位</p>
<p>设置寄存器：</p>
<p>A：存放部分累加和，乘积高位，格式为双符号位</p>
<p>B：存放被乘数，格式为双符号位</p>
<p>C：存放乘数，乘积低位，格式为无符号位</p>
<p>设置初值：</p>
<p>A=00.0000</p>
<p>B=|X|=00.1101</p>
<p>C=|Y|=     .1011</p>
<p>操作步骤</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://cdn.jsdelivr.net/gh/adan-ning/images/202403181725983.jpg"
        data-srcset="https://cdn.jsdelivr.net/gh/adan-ning/images/202403181725983.jpg, https://cdn.jsdelivr.net/gh/adan-ning/images/202403181725983.jpg 1.5x, https://cdn.jsdelivr.net/gh/adan-ning/images/202403181725983.jpg 2x"
        data-sizes="auto"
        alt="https://cdn.jsdelivr.net/gh/adan-ning/images/202403181725983.jpg"
        title="https://cdn.jsdelivr.net/gh/adan-ning/images/202403181725983.jpg" /></p>
<h3 id="算法流程">算法流程</h3>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://cdn.jsdelivr.net/gh/adan-ning/images/202403181726929.jpg"
        data-srcset="https://cdn.jsdelivr.net/gh/adan-ning/images/202403181726929.jpg, https://cdn.jsdelivr.net/gh/adan-ning/images/202403181726929.jpg 1.5x, https://cdn.jsdelivr.net/gh/adan-ning/images/202403181726929.jpg 2x"
        data-sizes="auto"
        alt="https://cdn.jsdelivr.net/gh/adan-ning/images/202403181726929.jpg"
        title="https://cdn.jsdelivr.net/gh/adan-ning/images/202403181726929.jpg" /></p>
<h3 id="原码一位乘法的硬件实现">原码一位乘法的硬件实现</h3>
<ol>
<li>A,B为n+2位，C为n位，加法器为n+2位，异或门</li>
<li>A,C寄存器级连在一起，具有右移功能。每次移位时，A的最低位进入C的最高位，而C的最低位被丢掉。最后，<strong>A的内容为乘积的高位部分，C的内容为乘积的低位部分</strong></li>
<li>C的最低位作为控制信号，控制运算器加被乘数还是加0；</li>
</ol>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://cdn.jsdelivr.net/gh/adan-ning/images/202403231112073.png"
        data-srcset="https://cdn.jsdelivr.net/gh/adan-ning/images/202403231112073.png, https://cdn.jsdelivr.net/gh/adan-ning/images/202403231112073.png 1.5x, https://cdn.jsdelivr.net/gh/adan-ning/images/202403231112073.png 2x"
        data-sizes="auto"
        alt="https://cdn.jsdelivr.net/gh/adan-ning/images/202403231112073.png"
        title="https://cdn.jsdelivr.net/gh/adan-ning/images/202403231112073.png" /></p>
<p><strong>说明</strong></p>
<ol>
<li>
<p>原码乘法虽然容易实现，但一般计算机中数据多以补码表示。若仍用原码做乘法，需要进行码制转换，反倒不方便而且又影响速度。</p>
</li>
<li>
<p>因为补码符号位直接参加运算，所以补码乘法不能简单地套用原码乘法的算法。实现补码乘法有2种方法。</p>
</li>
<li>
<p>一种方法为校正法，使用较少，只给出算式：</p>
<p>$[X \times Y]_补=[X]_补 \times (O.X_1X_2&hellip;X_n)-[X_补] \times Y_0$</p>
</li>
<li>
<p>另一种更好的方法为比较法，该算法是英国人Booth夫妇提出，所以也称为Booth法。该算法无需校正，控制较为简单。以下主要讨论比较法。</p>
</li>
</ol>
<h2 id="补码一位乘法">补码一位乘法</h2>
<p><strong>算法分析</strong></p>
<p>$X_补 = X_0.X_1X_2&hellip;.._n$</p>
<ol>
<li>
<p>Y为正：$Y_补 = 0.Y_1Y_2&hellip;.Y_n$</p>
<p>$(XY)_补 = X_补(0.Y_1Y_2&hellip;.Y_n)$</p>
</li>
<li>
<p>Y为负：$Y_补=1.Y_1Y_2&hellip;.Y_n$</p>
<p>$(XY)_补 = X_补(0.Y_1Y_2&hellip;..Y_n)+(-X)_补$</p>
</li>
<li>
<p>Y符号任意：</p>
<p>$(XY)_补 = X_补(0.Y_1Y_2&hellip;..Y_n)+(-X)_补Y_0$(符号位$Y_0$)</p>
</li>
</ol>
<h3 id="比较法booth乘法">比较法(BOOTH乘法)</h3>
<p><strong>递推公式</strong></p>
<p>$[Z_0]_补 = 0$</p>
<p>$[Z_1]_补 = 2^{-1}{[Z_0]_补+(Y_n+1-Y_n)[X_补]}$</p>
<p>$[Z_2]_补 = 2^{-1}{[Z_1]<em>补+(Y_n-Y</em>{n-1})[X_补]}$</p>
<p>.</p>
<p>..</p>
<p>&hellip;</p>
<p>$[Z_n]_补 = 2^{-1}{[Z_n-1]_补+(Y_2-Y_1)[X_补]}$</p>
<p>$\therefore [X \times Y]_补 = [Z_n]_补 +(Y_1-Y_s)[X_补]$</p>
<p>式中，$[Z_0]$为初始部分积，$[Z_1]_补$~$[Z_n]_补$依次为各次求得的累加并右移之后的部分积</p>
<h3 id="booth乘法规则">BOOTH乘法规则</h3>
<ol>
<li>参与运算的数用补码表示</li>
<li>符号为参加运算</li>
<li>乘数最低位后面增加一位附加位$Y_{n+1}$其初值为0</li>
<li>由于每求一次部分积要右移一位，所以乘数的最低两位$Y_n$、$Y_{n+1}$的值决定了每次应执行的操作；</li>
<li>移位按补码右移规则进行</li>
<li>共需做n+1次累加，n次移位，第n+1次不移位</li>
</ol>
<h4 id="比较法算法">比较法算法</h4>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://cdn.jsdelivr.net/gh/adan-ning/images/202403231321873.png"
        data-srcset="https://cdn.jsdelivr.net/gh/adan-ning/images/202403231321873.png, https://cdn.jsdelivr.net/gh/adan-ning/images/202403231321873.png 1.5x, https://cdn.jsdelivr.net/gh/adan-ning/images/202403231321873.png 2x"
        data-sizes="auto"
        alt="https://cdn.jsdelivr.net/gh/adan-ning/images/202403231321873.png"
        title="https://cdn.jsdelivr.net/gh/adan-ning/images/202403231321873.png" /></p>
<p><strong>运算实例</strong></p>
<p>X=-0.1101,Y=-0.1011.求$(XY)_补$</p>
<p>初值：A=00.0000,B=$X_补$=11.0011，</p>
<p>-B=$(-X)_补$=00.1101,C=$Y_补$=1.0101</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://cdn.jsdelivr.net/gh/adan-ning/images/202403231324051.png"
        data-srcset="https://cdn.jsdelivr.net/gh/adan-ning/images/202403231324051.png, https://cdn.jsdelivr.net/gh/adan-ning/images/202403231324051.png 1.5x, https://cdn.jsdelivr.net/gh/adan-ning/images/202403231324051.png 2x"
        data-sizes="auto"
        alt="https://cdn.jsdelivr.net/gh/adan-ning/images/202403231324051.png"
        title="https://cdn.jsdelivr.net/gh/adan-ning/images/202403231324051.png" /></p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://cdn.jsdelivr.net/gh/adan-ning/images/202403231325161.png"
        data-srcset="https://cdn.jsdelivr.net/gh/adan-ning/images/202403231325161.png, https://cdn.jsdelivr.net/gh/adan-ning/images/202403231325161.png 1.5x, https://cdn.jsdelivr.net/gh/adan-ning/images/202403231325161.png 2x"
        data-sizes="auto"
        alt="https://cdn.jsdelivr.net/gh/adan-ning/images/202403231325161.png"
        title="https://cdn.jsdelivr.net/gh/adan-ning/images/202403231325161.png" /></p>
<ol>
<li>A,B取双符号位，符号参加运算</li>
<li>C取单符号位，符号参加移位，以决定最后是否修正</li>
</ol>
<h3 id="补码一位乘法的硬件实现">补码一位乘法的硬件实现</h3>
<ol>
<li>
<p>A,B,C为n+2位，加法器为n+2位</p>
<p>与或门有n+2个</p>
</li>
<li>
<p>各器件的作用与原码一位乘法相同。控制方式上有所不同，即<strong>由C寄存器的最低两位来控制加、减被乘数或加0操作。</strong></p>
</li>
</ol>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://cdn.jsdelivr.net/gh/adan-ning/images/202403231503055.png"
        data-srcset="https://cdn.jsdelivr.net/gh/adan-ning/images/202403231503055.png, https://cdn.jsdelivr.net/gh/adan-ning/images/202403231503055.png 1.5x, https://cdn.jsdelivr.net/gh/adan-ning/images/202403231503055.png 2x"
        data-sizes="auto"
        alt="https://cdn.jsdelivr.net/gh/adan-ning/images/202403231503055.png"
        title="https://cdn.jsdelivr.net/gh/adan-ning/images/202403231503055.png" /></p>
<h2 id="阵列乘法器">阵列乘法器</h2>
<h3 id="不带符号的阵列乘法器">不带符号的阵列乘法器</h3>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://cdn.jsdelivr.net/gh/adan-ning/images/202403231505074.png"
        data-srcset="https://cdn.jsdelivr.net/gh/adan-ning/images/202403231505074.png, https://cdn.jsdelivr.net/gh/adan-ning/images/202403231505074.png 1.5x, https://cdn.jsdelivr.net/gh/adan-ning/images/202403231505074.png 2x"
        data-sizes="auto"
        alt="https://cdn.jsdelivr.net/gh/adan-ning/images/202403231505074.png"
        title="https://cdn.jsdelivr.net/gh/adan-ning/images/202403231505074.png" /></p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://cdn.jsdelivr.net/gh/adan-ning/images/202403231506773.png"
        data-srcset="https://cdn.jsdelivr.net/gh/adan-ning/images/202403231506773.png, https://cdn.jsdelivr.net/gh/adan-ning/images/202403231506773.png 1.5x, https://cdn.jsdelivr.net/gh/adan-ning/images/202403231506773.png 2x"
        data-sizes="auto"
        alt="https://cdn.jsdelivr.net/gh/adan-ning/images/202403231506773.png"
        title="https://cdn.jsdelivr.net/gh/adan-ning/images/202403231506773.png" /></p>
<h3 id="带符号位的阵列乘法器">带符号位的阵列乘法器</h3>
<p><strong>求补电路</strong></p>
<p>原理：算前求补—乘法器—算后求补，见下图</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://cdn.jsdelivr.net/gh/adan-ning/images/202403231508318.png"
        data-srcset="https://cdn.jsdelivr.net/gh/adan-ning/images/202403231508318.png, https://cdn.jsdelivr.net/gh/adan-ning/images/202403231508318.png 1.5x, https://cdn.jsdelivr.net/gh/adan-ning/images/202403231508318.png 2x"
        data-sizes="auto"
        alt="https://cdn.jsdelivr.net/gh/adan-ning/images/202403231508318.png"
        title="https://cdn.jsdelivr.net/gh/adan-ning/images/202403231508318.png" /></p>
<p>小结</p>
<ol>
<li>
<p>E=0时，输入和输出相等</p>
</li>
<li>
<p>E=1时，则从数最右端往左边扫描，直到第一个1的时候，该位和右边各位保持不变$0 \bigoplus A = A$,左边各数值位按位取反$1 \bigoplus A = \ 乛A$</p>
</li>
<li>
<p>可以用符号作为E的输入</p>
<p>原：1.11110，补：1.00010(不变，左边数值位取反)</p>
</li>
<li>
<p>时间延迟分析：转换n+1位带符号的时间延迟为$t=n<em>2T+5T$，其中n</em>2T为或门延迟时间，5T为最高位与门和异或门的时延。</p>
</li>
</ol>
<p><strong>带符号位的阵列乘法器(间接法)</strong></p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://cdn.jsdelivr.net/gh/adan-ning/images/202403231517748.png"
        data-srcset="https://cdn.jsdelivr.net/gh/adan-ning/images/202403231517748.png, https://cdn.jsdelivr.net/gh/adan-ning/images/202403231517748.png 1.5x, https://cdn.jsdelivr.net/gh/adan-ning/images/202403231517748.png 2x"
        data-sizes="auto"
        alt="https://cdn.jsdelivr.net/gh/adan-ning/images/202403231517748.png"
        title="https://cdn.jsdelivr.net/gh/adan-ning/images/202403231517748.png" /></p>
<h2 id="定点除法运算">定点除法运算</h2>
<p><strong>除法&mdash;&gt;若干余数与除数加减，移位</strong></p>
<p>例：$0.10110 \div 0.11111$</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://cdn.jsdelivr.net/gh/adan-ning/images/202403231519915.png"
        data-srcset="https://cdn.jsdelivr.net/gh/adan-ning/images/202403231519915.png, https://cdn.jsdelivr.net/gh/adan-ning/images/202403231519915.png 1.5x, https://cdn.jsdelivr.net/gh/adan-ning/images/202403231519915.png 2x"
        data-sizes="auto"
        alt="https://cdn.jsdelivr.net/gh/adan-ning/images/202403231519915.png"
        title="https://cdn.jsdelivr.net/gh/adan-ning/images/202403231519915.png" /></p>
<p><strong>实现出发的关键：比较余数，除数绝对值大小，以决定上商</strong></p>
<ol>
<li>除法运算是乘法运算的逆运算。乘法通过加-右移实现，不难想到机器除法运算是通过减-左移实现的。</li>
<li>机器实现除法运算有两个先决条件(纯小数)
<ol>
<li>除数不等于0，否则商为无穷大</li>
<li>被除数要小余除数，否则商会溢出</li>
</ol>
</li>
</ol>
<h2 id="原码恢复余数法">原码恢复余数法</h2>
<ol>
<li>
<p>算法</p>
<p><strong>比较两数大小可用减法试探</strong></p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://cdn.jsdelivr.net/gh/adan-ning/images/202403231523651.png"
        data-srcset="https://cdn.jsdelivr.net/gh/adan-ning/images/202403231523651.png, https://cdn.jsdelivr.net/gh/adan-ning/images/202403231523651.png 1.5x, https://cdn.jsdelivr.net/gh/adan-ning/images/202403231523651.png 2x"
        data-sizes="auto"
        alt="https://cdn.jsdelivr.net/gh/adan-ning/images/202403231523651.png"
        title="https://cdn.jsdelivr.net/gh/adan-ning/images/202403231523651.png" /></p>
</li>
<li>
<p>实例</p>
<p>X=-0.10110，Y=0.11111，求X/Y，给出商Q和余数R</p>
<p>设置：A：被除数，余数，B：除数。C：商</p>
<p>初值：</p>
<p>$A=|X|=00.10110$</p>
<p>$B=|Y|=00.11111$,$-B=11.00001$</p>
<p>$C=|Q|=0.00000$</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://cdn.jsdelivr.net/gh/adan-ning/images/202403231526336.png"
        data-srcset="https://cdn.jsdelivr.net/gh/adan-ning/images/202403231526336.png, https://cdn.jsdelivr.net/gh/adan-ning/images/202403231526336.png 1.5x, https://cdn.jsdelivr.net/gh/adan-ning/images/202403231526336.png 2x"
        data-sizes="auto"
        alt="https://cdn.jsdelivr.net/gh/adan-ning/images/202403231526336.png"
        title="https://cdn.jsdelivr.net/gh/adan-ning/images/202403231526336.png" /></p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://cdn.jsdelivr.net/gh/adan-ning/images/202403231527882.png"
        data-srcset="https://cdn.jsdelivr.net/gh/adan-ning/images/202403231527882.png, https://cdn.jsdelivr.net/gh/adan-ning/images/202403231527882.png 1.5x, https://cdn.jsdelivr.net/gh/adan-ning/images/202403231527882.png 2x"
        data-sizes="auto"
        alt="https://cdn.jsdelivr.net/gh/adan-ning/images/202403231527882.png"
        title="https://cdn.jsdelivr.net/gh/adan-ning/images/202403231527882.png" /></p>
</li>
<li>
<p>说明</p>
<ol>
<li>A,B双符号位。X,Y绝对值，|X|小于|Y|</li>
<li>运算结束后，余数乘以$2^{-n}$，与被除数同号</li>
</ol>
</li>
</ol>
<h2 id="原码不恢复余数法加减交替法">原码不恢复余数法(加减交替法)</h2>
<ol>
<li>
<p>算法分析</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://cdn.jsdelivr.net/gh/adan-ning/images/202403231532286.png"
        data-srcset="https://cdn.jsdelivr.net/gh/adan-ning/images/202403231532286.png, https://cdn.jsdelivr.net/gh/adan-ning/images/202403231532286.png 1.5x, https://cdn.jsdelivr.net/gh/adan-ning/images/202403231532286.png 2x"
        data-sizes="auto"
        alt="https://cdn.jsdelivr.net/gh/adan-ning/images/202403231532286.png"
        title="https://cdn.jsdelivr.net/gh/adan-ning/images/202403231532286.png" /></p>
</li>
<li>
<p>算法</p>
<p>$r_{i+1}=2r_i+(1-2Q_i)Y$</p>
<p>$r_i$为正，则$Q_i$为1，第i+1步作$2r_i-Y$</p>
<p>$r_i$为负，则$Q_i$为0，第i+1步作$2r_i+Y$</p>
</li>
<li>
<p>实例</p>
<p>X=0.10110,Y=-0.11111,求X/Y，给出商Q和余数R</p>
<p>初值：</p>
<p>A=|X|=00.10110</p>
<p>B=|Y|=00.11111,-B=11.00001</p>
<p>C=|Q|=0.00000</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://cdn.jsdelivr.net/gh/adan-ning/images/202403231537229.png"
        data-srcset="https://cdn.jsdelivr.net/gh/adan-ning/images/202403231537229.png, https://cdn.jsdelivr.net/gh/adan-ning/images/202403231537229.png 1.5x, https://cdn.jsdelivr.net/gh/adan-ning/images/202403231537229.png 2x"
        data-sizes="auto"
        alt="https://cdn.jsdelivr.net/gh/adan-ning/images/202403231537229.png"
        title="https://cdn.jsdelivr.net/gh/adan-ning/images/202403231537229.png" /></p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://cdn.jsdelivr.net/gh/adan-ning/images/202403231537161.png"
        data-srcset="https://cdn.jsdelivr.net/gh/adan-ning/images/202403231537161.png, https://cdn.jsdelivr.net/gh/adan-ning/images/202403231537161.png 1.5x, https://cdn.jsdelivr.net/gh/adan-ning/images/202403231537161.png 2x"
        data-sizes="auto"
        alt="https://cdn.jsdelivr.net/gh/adan-ning/images/202403231537161.png"
        title="https://cdn.jsdelivr.net/gh/adan-ning/images/202403231537161.png" /></p>
</li>
<li>
<p>运算规则</p>
<ol>
<li>A,B取双符号位，X,Y取绝对值运算，|X|&lt;|Y|</li>
<li>根据余数的政府决定商值及下一步操作</li>
<li>求n位商，作n步操作；若第n步余数为负，则第n+1步恢复余数，不移位</li>
</ol>
</li>
</ol>
<p><strong>原码不恢复余数法的硬件实现</strong></p>
<ol>
<li>A、B寄存器，n+2位，C寄存器，n+1位，加法器，n+2位 ，与或门，n+2个</li>
<li>A、C寄存器级连在一起，具有左移一位功能。每次移位时，C的最高位进入A的最低位，而C的最低位用来保存每次运算得到的商。A的初值为被除数，最后变为余数，C的内容为除法得到的商。</li>
<li>在运算过程中，由余数的符号决定商值和下一步操作，即控制运算器加除数还是减除数。</li>
</ol>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://cdn.jsdelivr.net/gh/adan-ning/images/202403231542540.png"
        data-srcset="https://cdn.jsdelivr.net/gh/adan-ning/images/202403231542540.png, https://cdn.jsdelivr.net/gh/adan-ning/images/202403231542540.png 1.5x, https://cdn.jsdelivr.net/gh/adan-ning/images/202403231542540.png 2x"
        data-sizes="auto"
        alt="https://cdn.jsdelivr.net/gh/adan-ning/images/202403231542540.png"
        title="https://cdn.jsdelivr.net/gh/adan-ning/images/202403231542540.png" /></p>
<h2 id="阵列除法器">阵列除法器</h2>
<p>同乘法一样，为提高除法的运算速度，可采用阵列除法器。以下介绍两个正数的不恢复余数阵列除法器。</p>
<ol>
<li>
<p>可控加减单元CAS是构成阵列除法器的基本单元。由一个全加器和一个异或门组成。如图所示</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://cdn.jsdelivr.net/gh/adan-ning/images/202403231544077.png"
        data-srcset="https://cdn.jsdelivr.net/gh/adan-ning/images/202403231544077.png, https://cdn.jsdelivr.net/gh/adan-ning/images/202403231544077.png 1.5x, https://cdn.jsdelivr.net/gh/adan-ning/images/202403231544077.png 2x"
        data-sizes="auto"
        alt="https://cdn.jsdelivr.net/gh/adan-ning/images/202403231544077.png"
        title="https://cdn.jsdelivr.net/gh/adan-ning/images/202403231544077.png" /></p>
</li>
<li>
<p>可控加减单元CAS有四个输入端和四个输出端。</p>
<p>当控制线P=0时,$Y_i \bigoplus P =Y_i$，全加器完成$Y_i+X_i$</p>
<p>当控制线P=1时,$Y_i \bigoplus P =\stackrel{-} Y_i$，全加器完成$ \stackrel{-} Y_i+X_i$</p>
</li>
</ol>
<h2 id="原理">原理</h2>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://cdn.jsdelivr.net/gh/adan-ning/images/202403231547461.png"
        data-srcset="https://cdn.jsdelivr.net/gh/adan-ning/images/202403231547461.png, https://cdn.jsdelivr.net/gh/adan-ning/images/202403231547461.png 1.5x, https://cdn.jsdelivr.net/gh/adan-ning/images/202403231547461.png 2x"
        data-sizes="auto"
        alt="https://cdn.jsdelivr.net/gh/adan-ning/images/202403231547461.png"
        title="https://cdn.jsdelivr.net/gh/adan-ning/images/202403231547461.png" /></p>
<ol>
<li>被除数X各位沿竖直线送到CAS，除数Y沿斜线送到CAS。做加法还是做减法，由控制线P决定。由于是两正数相除，除法阵列第一行应执行减法操作，所以该行控制端P=1，同时将P作为该行末端的进位输入，从而完成减法运算。</li>
<li>如果够减，有进位，商为1，下行做减法。如果不够减，无进位，商为0，下行做加法。其它行工作同上，得出商和余数。</li>
</ol>
<h2 id="定点运算器的组成">定点运算器的组成</h2>
<h3 id="算术逻辑运算部件alu">算术逻辑运算部件ALU</h3>
<ol>
<li>计算机的主要功能是对数据进行各种加工和处理，包括加、减、乘、除这些基本的算术运算，与、或、非这些基本的逻辑运算，以及由此构成的其它复杂的运算。<strong>运算器则是实现这些运算的主要部件。</strong></li>
<li>无论多么复杂的运算，最终都要分解为加法运算来实现。其中，减法运算通过补码转化为加法来实现 ；乘、除运算可以转换为加减运算、移位操作来实现。加法和移位是计算机中最基本的两种运算操作。</li>
<li>可见，**加法器又是运算器的核心部件。**在加法器的基础上增加移位功能，并通过选择输入控制条件，就可以实现所有的运算。</li>
</ol>
<h4 id="全加器">全加器</h4>
<ol>
<li>全加器（FA）是最基本的运算单元，由它构成加法器。</li>
<li>全加器有**三个输入量：**操作数$A_i$、$B_i$、以及低位传来的进位信号$C_{i-1}$ 。</li>
<li>全加器有**两个输出量：**本位和$S_i$、以及向高位的进位信号$C_i$。</li>
</ol>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://cdn.jsdelivr.net/gh/adan-ning/images/202403251440419.png"
        data-srcset="https://cdn.jsdelivr.net/gh/adan-ning/images/202403251440419.png, https://cdn.jsdelivr.net/gh/adan-ning/images/202403251440419.png 1.5x, https://cdn.jsdelivr.net/gh/adan-ning/images/202403251440419.png 2x"
        data-sizes="auto"
        alt="https://cdn.jsdelivr.net/gh/adan-ning/images/202403251440419.png"
        title="https://cdn.jsdelivr.net/gh/adan-ning/images/202403251440419.png" /></p>
<p>根据真值表得：</p>
<p>Si=Ai⊕Bi⊕Ci-1
Ci=AiBi+(Ai⊕Bi)Ci-1</p>
<p>Si : 本位和
Ci : 向高位的进位</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://cdn.jsdelivr.net/gh/adan-ning/images/202403251442029.png"
        data-srcset="https://cdn.jsdelivr.net/gh/adan-ning/images/202403251442029.png, https://cdn.jsdelivr.net/gh/adan-ning/images/202403251442029.png 1.5x, https://cdn.jsdelivr.net/gh/adan-ning/images/202403251442029.png 2x"
        data-sizes="auto"
        alt="https://cdn.jsdelivr.net/gh/adan-ning/images/202403251442029.png"
        title="https://cdn.jsdelivr.net/gh/adan-ning/images/202403251442029.png" /></p>
<p><strong>一个全加器只完成一位加法</strong></p>
<h4 id="全加器构成加法器">全加器构成加法器</h4>
<ol>
<li>全加器并不存储信息，可用门电路来实现。用全加器能够方便地构成加法器。加法器分为<strong>串行加法器</strong>和<strong>并行加法器</strong>。</li>
<li><strong>串行加法器只有一个全加器</strong>，数据逐位串行送入加法器进行计算。由于运算速度慢，一般不用。</li>
<li><strong>并行加法器</strong>则由若干个这样的全加器构成，各位数据同时运算。并行加法器的位数与操作数的位数相等。并行加法器的最长运算时间主要取决于进位信号的传递时间。例如：11…11和00…01相加，最低位产生的进位将逐位影响到最高位.</li>
<li>由此可见，提高并行加法器速度的<strong>关键</strong>是<strong>尽量加快进位产生和传递的速度。</strong></li>
</ol>
<h4 id="进位产生与传递">进位产生与传递</h4>
<ol>
<li>
<p><strong>进位链</strong>的概念：</p>
<p>并行加法器中的每一个全加器都有一个从低位送来的进位输入和一个传送给高位的进位输出。我们把构成进位信号产生和传递的<strong>逻辑网络</strong>称为<strong>进位链。</strong></p>
</li>
<li>
<p>进位链上每一位的进位表达式为：</p>
<p>$C_i=A_iB_i+(A_i⊕B_i)C_{i-1}$ （注意是逻辑关系）</p>
<p>设	Gi=AiBi ，称为进位产生函数
Pi=Ai⊕Bi ，称为进位传递函数</p>
<p>∴   进位表达式 Ci=Gi+PiCi-1</p>
</li>
</ol>
<h4 id="并行加法器的串行进位">并行加法器的串行进位</h4>
<ol>
<li>
<p>把n个全加器串联起来，就可以实现两个n位数的相加。这种加法器称为<strong>串行进位</strong>的并行加法器，串行进位又叫**行波进位。 **</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://cdn.jsdelivr.net/gh/adan-ning/images/202403251459350.png"
        data-srcset="https://cdn.jsdelivr.net/gh/adan-ning/images/202403251459350.png, https://cdn.jsdelivr.net/gh/adan-ning/images/202403251459350.png 1.5x, https://cdn.jsdelivr.net/gh/adan-ning/images/202403251459350.png 2x"
        data-sizes="auto"
        alt="https://cdn.jsdelivr.net/gh/adan-ning/images/202403251459350.png"
        title="https://cdn.jsdelivr.net/gh/adan-ning/images/202403251459350.png" /></p>
</li>
</ol>
<h4 id="并行加法器的并行进位">并行加法器的并行进位</h4>
<ol>
<li>
<p>改进串行进位方式的基本思路是<strong>各进位同时形成</strong>，避免各进位之间的依赖关系。现在来分析一下进位关系。</p>
</li>
<li>
<p>只要满足下述两条件中任一个，就可形成C1：</p>
<p>(1)X1，Y1均为“1”；
(2)X1，Y1任一个为“1”，且进位C0为“1”。由此，可写得</p>
<p>C1的表达式为C1=X1Y1+(X1⊕Y1)C0</p>
</li>
<li>
<p>只要满足下述两条件中任一个，就可形成C2：</p>
<p>(1)X2，Y2均为“1”；
(2)X2，Y2任一为“1”，且X1，Y1均为“1”；
(3)X2，Y2任一为“1”，同时X1，Y1任一为“1”，且C0为</p>
<p>“1”。由此可得C2表达式为</p>
<p>C2=X2Y2+(X2⊕Y2)X1Y1+(X2⊕Y2)(X1⊕Y1)C0</p>
</li>
</ol>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://cdn.jsdelivr.net/gh/adan-ning/images/202403251508637.png"
        data-srcset="https://cdn.jsdelivr.net/gh/adan-ning/images/202403251508637.png, https://cdn.jsdelivr.net/gh/adan-ning/images/202403251508637.png 1.5x, https://cdn.jsdelivr.net/gh/adan-ning/images/202403251508637.png 2x"
        data-sizes="auto"
        alt="https://cdn.jsdelivr.net/gh/adan-ning/images/202403251508637.png"
        title="https://cdn.jsdelivr.net/gh/adan-ning/images/202403251508637.png" /></p>
<p><strong>以上进位输出只与$G_i$、$P_i$以及最低进位$C_0$有关，而且不依赖于其低位进位$C_{i-1}$的输入，因此各级进位可以同时产生，形成并行进位。</strong></p>
<p><strong>并行进位的特点</strong></p>
<ol>
<li>并行进位的特点是各级进位信号同时形成，与字长无关，提高了整体运算速度 。并行进位又叫<strong>先行进位</strong>。</li>
<li>最长延迟时间仅为2ty。</li>
<li>随着加法器位数的增加，Ci的逻辑表达式会变得越来越长，输入变量会越来越多，电路结构也会变得越来越复杂，导致<strong>电路实现也越来越困难</strong>。</li>
<li>并行进位方式需继续改进，才能有实用价值。这就是下面要介绍的<strong>分组进位方式</strong>。</li>
</ol>
<h4 id="单级先行进位">单级先行进位</h4>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://cdn.jsdelivr.net/gh/adan-ning/images/202403251515189.png"
        data-srcset="https://cdn.jsdelivr.net/gh/adan-ning/images/202403251515189.png, https://cdn.jsdelivr.net/gh/adan-ning/images/202403251515189.png 1.5x, https://cdn.jsdelivr.net/gh/adan-ning/images/202403251515189.png 2x"
        data-sizes="auto"
        alt="https://cdn.jsdelivr.net/gh/adan-ning/images/202403251515189.png"
        title="https://cdn.jsdelivr.net/gh/adan-ning/images/202403251515189.png" /></p>
<ol>
<li>
<p>以16位加法器为例，将其分为4组，每组4位。</p>
</li>
<li>
<p>在组内，按照并行进位函数直接产生C1～C4，这些进位可同时得到。实现这种进位逻辑的电路称为<strong>4位先行进位电路（CLA）</strong>，如74181ALU。</p>
</li>
<li>
<p>利用这种4位一组的CLA电路和4位全加器可以构成4位CLA加法器。注意，4位CLA加法器包含了<strong>两部分逻辑</strong>：4位全加器和4位一组的先行进位链，这个组内的进位为一级进位。</p>
</li>
<li>
<p>在组间，每个组的进位输入是前一个组的进位输出，而每个组的进位输出是下一个组的进位输入。</p>
</li>
<li>
<p>上述<strong>组内并行、组间串行</strong>的进位方式也称为单级先行进位方式，原理如下图所示。</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://cdn.jsdelivr.net/gh/adan-ning/images/202403251517260.png"
        data-srcset="https://cdn.jsdelivr.net/gh/adan-ning/images/202403251517260.png, https://cdn.jsdelivr.net/gh/adan-ning/images/202403251517260.png 1.5x, https://cdn.jsdelivr.net/gh/adan-ning/images/202403251517260.png 2x"
        data-sizes="auto"
        alt="https://cdn.jsdelivr.net/gh/adan-ning/images/202403251517260.png"
        title="https://cdn.jsdelivr.net/gh/adan-ning/images/202403251517260.png" /></p>
</li>
</ol>
<h4 id="多级先行进位">多级先行进位</h4>
<ol>
<li>
<p>组内进位信号能同时产生、组间进位信号也能同时产生，由此可以构成多级并行进位逻辑。16位2级先行进位加法器如图所示。</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://cdn.jsdelivr.net/gh/adan-ning/images/202403251519150.png"
        data-srcset="https://cdn.jsdelivr.net/gh/adan-ning/images/202403251519150.png, https://cdn.jsdelivr.net/gh/adan-ning/images/202403251519150.png 1.5x, https://cdn.jsdelivr.net/gh/adan-ning/images/202403251519150.png 2x"
        data-sizes="auto"
        alt="https://cdn.jsdelivr.net/gh/adan-ning/images/202403251519150.png"
        title="https://cdn.jsdelivr.net/gh/adan-ning/images/202403251519150.png" /></p>
</li>
<li>
<p>为说明问题，我们不妨仍以16位加法器为例，仍然4位一组，分成4个小组，先就第一小组的进位输出函数C4做一下分析：</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://cdn.jsdelivr.net/gh/adan-ning/images/202403251520035.png"
        data-srcset="https://cdn.jsdelivr.net/gh/adan-ning/images/202403251520035.png, https://cdn.jsdelivr.net/gh/adan-ning/images/202403251520035.png 1.5x, https://cdn.jsdelivr.net/gh/adan-ning/images/202403251520035.png 2x"
        data-sizes="auto"
        alt="https://cdn.jsdelivr.net/gh/adan-ning/images/202403251520035.png"
        title="https://cdn.jsdelivr.net/gh/adan-ning/images/202403251520035.png" /></p>
</li>
<li>
<p>G1<em>称为<strong>组进位产生函数</strong>，P1</em>称为<strong>组进位传递函数</strong>；这两个函数类似于进位产生函数G和进位传递函数P.</p>
</li>
<li>
<p>四个组内的最高进位C16、C12、C8、C4可以分别表示为:</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://cdn.jsdelivr.net/gh/adan-ning/images/202403251522438.png"
        data-srcset="https://cdn.jsdelivr.net/gh/adan-ning/images/202403251522438.png, https://cdn.jsdelivr.net/gh/adan-ning/images/202403251522438.png 1.5x, https://cdn.jsdelivr.net/gh/adan-ning/images/202403251522438.png 2x"
        data-sizes="auto"
        alt="https://cdn.jsdelivr.net/gh/adan-ning/images/202403251522438.png"
        title="https://cdn.jsdelivr.net/gh/adan-ning/images/202403251522438.png" /></p>
</li>
</ol>
<p>例：某加法器最低位为第1位，采用串行进位方式。写出进位信号C3的逻辑式（操作数Ai、Bi、初始进位C0）。</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://cdn.jsdelivr.net/gh/adan-ning/images/202403251522804.png"
        data-srcset="https://cdn.jsdelivr.net/gh/adan-ning/images/202403251522804.png, https://cdn.jsdelivr.net/gh/adan-ning/images/202403251522804.png 1.5x, https://cdn.jsdelivr.net/gh/adan-ning/images/202403251522804.png 2x"
        data-sizes="auto"
        alt="https://cdn.jsdelivr.net/gh/adan-ning/images/202403251522804.png"
        title="https://cdn.jsdelivr.net/gh/adan-ning/images/202403251522804.png" /></p>
<p>例2：某加法器采用组内并行、组间并行的进位链，四位一组。写出进位信号C6的的逻辑式（操作数Ai、Bi、初始进位C0）。</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://cdn.jsdelivr.net/gh/adan-ning/images/202403251523893.png"
        data-srcset="https://cdn.jsdelivr.net/gh/adan-ning/images/202403251523893.png, https://cdn.jsdelivr.net/gh/adan-ning/images/202403251523893.png 1.5x, https://cdn.jsdelivr.net/gh/adan-ning/images/202403251523893.png 2x"
        data-sizes="auto"
        alt="https://cdn.jsdelivr.net/gh/adan-ning/images/202403251523893.png"
        title="https://cdn.jsdelivr.net/gh/adan-ning/images/202403251523893.png" /></p>
<h2 id="多功能算术逻辑部件alu">多功能算术逻辑部件ALU</h2>
<ol>
<li>参加运算的两个数$A_i、B_i$和低位进位Ci-1先不进行全加，先把两个输入$A_i、B_i$和四个控制参数$S_0、S_1、S_2、S_3$进行组合，形成函数$X_i和Y_i$，</li>
<li>然后再将$X_i、Y_i$和低位进位$C_{i-1}$通过全加器进行全加。</li>
<li>这样一来，控制参数不同，得到的组合函数也不同，从而实现多种算术和逻辑运算。</li>
</ol>
<h3 id="算术逻辑部件alu">算术逻辑部件ALU</h3>
<ol>
<li>
<p>算术逻辑部件ALU大体上有三部分组成</p>
<ol>
<li>全加器</li>
<li>进位链</li>
<li>输入选择器</li>
</ol>
</li>
<li>
<p>下面以ALU的一位逻辑为例，原理性地说明算术、逻辑功能是如何实现的。</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://cdn.jsdelivr.net/gh/adan-ning/images/202403251554276.png"
        data-srcset="https://cdn.jsdelivr.net/gh/adan-ning/images/202403251554276.png, https://cdn.jsdelivr.net/gh/adan-ning/images/202403251554276.png 1.5x, https://cdn.jsdelivr.net/gh/adan-ning/images/202403251554276.png 2x"
        data-sizes="auto"
        alt="https://cdn.jsdelivr.net/gh/adan-ning/images/202403251554276.png"
        title="https://cdn.jsdelivr.net/gh/adan-ning/images/202403251554276.png" /></p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://cdn.jsdelivr.net/gh/adan-ning/images/202403251554007.png"
        data-srcset="https://cdn.jsdelivr.net/gh/adan-ning/images/202403251554007.png, https://cdn.jsdelivr.net/gh/adan-ning/images/202403251554007.png 1.5x, https://cdn.jsdelivr.net/gh/adan-ning/images/202403251554007.png 2x"
        data-sizes="auto"
        alt="https://cdn.jsdelivr.net/gh/adan-ning/images/202403251554007.png"
        title="https://cdn.jsdelivr.net/gh/adan-ning/images/202403251554007.png" /></p>
<p>通过不同的输入选择，实现不同的功能，这进一步说明：数据是在传送过程实现运算、并得到处理的。多位ALU的实现思路完全一样</p>
</li>
</ol>
<h4 id="运算器的组织">运算器的组织</h4>
<ol>
<li>运算器主要由算逻部件ALU、寄存器、多路转换器、内部数据总线组成。</li>
<li>在运算器内部，各功能模块之间的连接大都采用总线结构，称为运算器的<strong>内部总线</strong>，ALU和各寄存器都挂在上面。</li>
<li>运算器大体上有如下三种结构：<strong>单总线结构、双总线结构和三总线总线结构。</strong></li>
</ol>
<h5 id="单总线结构的运算器">单总线结构的运算器</h5>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://cdn.jsdelivr.net/gh/adan-ning/images/202403251556032.png"
        data-srcset="https://cdn.jsdelivr.net/gh/adan-ning/images/202403251556032.png, https://cdn.jsdelivr.net/gh/adan-ning/images/202403251556032.png 1.5x, https://cdn.jsdelivr.net/gh/adan-ning/images/202403251556032.png 2x"
        data-sizes="auto"
        alt="https://cdn.jsdelivr.net/gh/adan-ning/images/202403251556032.png"
        title="https://cdn.jsdelivr.net/gh/adan-ning/images/202403251556032.png" /></p>
<h5 id="双总线结构的运算器">双总线结构的运算器</h5>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://cdn.jsdelivr.net/gh/adan-ning/images/202403251557747.png"
        data-srcset="https://cdn.jsdelivr.net/gh/adan-ning/images/202403251557747.png, https://cdn.jsdelivr.net/gh/adan-ning/images/202403251557747.png 1.5x, https://cdn.jsdelivr.net/gh/adan-ning/images/202403251557747.png 2x"
        data-sizes="auto"
        alt="https://cdn.jsdelivr.net/gh/adan-ning/images/202403251557747.png"
        title="https://cdn.jsdelivr.net/gh/adan-ning/images/202403251557747.png" /></p>
<ol>
<li>两个操作数可以同时到达ALU进行运算，且马上可以得到运算结果，输出端需要设置一个缓冲寄存器 ；完成一次运算需要2步 。</li>
<li>特殊寄存器分成两组，它们分别与一条总线交换数据。通用寄存器中的数据就可以进入到任一组特殊寄存器中去，从而使数据传送更为灵活。</li>
</ol>
<h5 id="三总线结构的运算器">三总线结构的运算器</h5>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://cdn.jsdelivr.net/gh/adan-ning/images/202403251558483.png"
        data-srcset="https://cdn.jsdelivr.net/gh/adan-ning/images/202403251558483.png, https://cdn.jsdelivr.net/gh/adan-ning/images/202403251558483.png 1.5x, https://cdn.jsdelivr.net/gh/adan-ning/images/202403251558483.png 2x"
        data-sizes="auto"
        alt="https://cdn.jsdelivr.net/gh/adan-ning/images/202403251558483.png"
        title="https://cdn.jsdelivr.net/gh/adan-ning/images/202403251558483.png" /></p>
<p>两条总线同时供给操作数，输出与第三条总线相连；完成一次运算需要1步。特点是操作速度快，控制相对复杂一些</p>
<h2 id="浮点运算方法和浮点运算器">浮点运算方法和浮点运算器</h2>
<h3 id="浮点加法减法运算">浮点加法、减法运算</h3>
<ol>
<li>
<p>浮点加减运算</p>
<p>设有两个浮点数ｘ和ｙ,它们分别为</p>
<p>$ｘ＝2^{Ex}·M_x$</p>
<p>$ｙ＝2^{Ey}·M_y$</p>
<p>其中$E_x$和$E_y$分别为数ｘ和ｙ的<strong>阶码</strong>,$M_x$和$M_y$为数ｘ和ｙ的<strong>尾数</strong>。两浮点数进行加法和减法的运算规则是</p>
<p>$ｘ±ｙ＝(M_x2^{Ex-Ey}±M_y)2^{Ey}$，</p>
<p>　　设$E_x&lt;＝E_y$</p>
</li>
<li>
<p>浮点运算步骤如下：</p>
<ol>
<li>0 操作数的检查,看有无简化操作的可能；</li>
<li>比较阶码大小并完成对阶（<strong>小阶向大阶对齐</strong>）；</li>
<li>尾数进行加或减运算；</li>
<li>结果规格化并进行舍入处理</li>
</ol>
</li>
</ol>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://cdn.jsdelivr.net/gh/adan-ning/images/202404011946605.png"
        data-srcset="https://cdn.jsdelivr.net/gh/adan-ning/images/202404011946605.png, https://cdn.jsdelivr.net/gh/adan-ning/images/202404011946605.png 1.5x, https://cdn.jsdelivr.net/gh/adan-ning/images/202404011946605.png 2x"
        data-sizes="auto"
        alt="https://cdn.jsdelivr.net/gh/adan-ning/images/202404011946605.png"
        title="https://cdn.jsdelivr.net/gh/adan-ning/images/202404011946605.png" /></p>
<p>例:</p>
<p>设$x＝2^2×0.11011011,y=-2^4×0.10101100$</p>
<ol>
<li>
<p>0操作数检查（非0）</p>
</li>
<li>
<p>对阶：阶码对齐后才能加减。规则是阶码小的向阶码大的数对齐；</p>
<p>若△E＝0,表示两数阶码相等,即Ex＝Ey；</p>
<p>若△E&gt;0,表示Ex&gt;Ey；</p>
<p>若△E&lt;0,表示Ex&lt;Ey。</p>
<p>当Ex≠Ey 时,要通过尾数的移动以改变Ex或Ey,使之相等</p>
<p><strong>原则:小阶向大阶</strong></p>
<p>设△E&gt;0,表示Ex&gt;Ey，则移动y的尾数，My右移△E位</p>
<p>阶差=Ex-Ey=00 010- 00 100 =11 110</p>
<p>即阶差为-2，Mx右移两位，Ex加2</p>
<p>x=00100 , 0.00110110（11）</p>
</li>
<li>
<p>尾数相加</p>
<p>00.00110110（11）+11.01010100=11.10001010（11）</p>
</li>
<li>
<p>结果规格化</p>
<ol>
<li>
<p>在浮点加减运算时,尾数求和的结果也可以得到01.ф…ф或10.ф…ф,即两符号位不等,此时将运算结果右移以实现规格化表示,称为向右规格化。</p>
<p>规则：尾数右移1位，阶码加1</p>
</li>
<li>
<p>结果是00.0..01&hellip;..或11.1&hellip;10&hellip;时，则向左规格化</p>
<p>规则：尾数左移1位，阶码减1，直到规格化</p>
<p>右规，阶码加1，左规，阶码减1</p>
<p>刚才例子左规为11.00010101（10），阶码减1为00011</p>
</li>
</ol>
</li>
<li>
<p>舍入处理（对阶和向右规格化时）</p>
<ol>
<li>就近舍入(0舍1入):类似”四舍五入”,丢弃的最高位为1,进1</li>
<li>朝0舍入:截尾</li>
<li>朝＋∞舍入:正数多余位不全为”0”,进1;负数,截尾</li>
<li>朝－∞ 舍入:负数多余位不全为”0”,进1;正数,截尾</li>
</ol>
</li>
<li>
<p>溢出判断和处理</p>
<ol>
<li>阶码上溢，一般将其认为是＋∞和－∞ 。</li>
<li>阶码下溢，则数值为0</li>
<li>尾数上溢，两个同符号位的数相加。处理方法是尾数右移，阶码 加1</li>
<li>尾数下溢。尾数右移时，最低位从最右端流出。要进行舍入处理 。</li>
</ol>
</li>
</ol>
<p><strong>课堂练习：x=0.1101<em>21   y=-0.1010</em>23</strong></p>
<p>尾数和阶符都采用补码表示，都采用双符号位表示法。求x+y</p>
<p>[x]浮=0001，00.1101
[y]浮=0011，11.0110
阶差=1110       即为-2
Mx应当右移2位，
[x]浮=0011，00.0011（01）
尾数和为11.1001（01）
左规11.0010（10），阶码减1为0010
舍入（就近舍入）11.0011       丢弃10
x+y=-0.1101*210</p>
<h3 id="浮点乘法和除法运算">浮点乘法和除法运算</h3>
<ol>
<li>
<p>设有两个浮点数ｘ和ｙ：</p>
<p>$ｘ＝2^{Ex}·M_x　$　　　　</p>
<p>$ｙ＝2^{Ey}·M_y$</p>
</li>
<li>
<p>乘除运算分为四步</p>
<ol>
<li>0操作数检查</li>
<li>阶码加减操作（无需对阶）</li>
<li>尾数乘除操作</li>
<li>结果规格化和舍入处理</li>
</ol>
<p>浮点数的阶码运算（移码的运算规则）</p>
<p>$[X]_移+[Y]_移=2^n+[X+Y]_移$</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://cdn.jsdelivr.net/gh/adan-ning/images/202404012023984.png"
        data-srcset="https://cdn.jsdelivr.net/gh/adan-ning/images/202404012023984.png, https://cdn.jsdelivr.net/gh/adan-ning/images/202404012023984.png 1.5x, https://cdn.jsdelivr.net/gh/adan-ning/images/202404012023984.png 2x"
        data-sizes="auto"
        alt="https://cdn.jsdelivr.net/gh/adan-ning/images/202404012023984.png"
        title="https://cdn.jsdelivr.net/gh/adan-ning/images/202404012023984.png" /></p>
</li>
<li>
<p>移码采用双符号位，为了对溢出进行判断</p>
<p><strong>01     为正           00        为负</strong></p>
<p>10     上溢           11        下溢</p>
<p>x＝＋011,y＝＋110,求[$x+y]_移 和 [x-y]_移$,并判断是否溢出</p>
<p>$[x]_移＝01 011, [y]_补＝00 110, [-y]_补＝11 010$</p>
<p>$[x+y]_移＝[x]_移＋[y]_补＝10 001$, 结果上溢。</p>
<p>$[x-y]_移＝[x]_移＋[-y]_补＝00 101$, 结果正确,为－3。</p>
</li>
<li>
<p>尾数处理</p>
<ol>
<li>截断</li>
<li>舍入
<ol>
<li>尾数用原码表示时
<ol>
<li>只要尾数最低为1或者移出位中有1数值位，使最低位置1</li>
<li>0舍1入</li>
</ol>
</li>
<li>尾数用补码表示时
<ol>
<li>丢失的位全为0，不必舍入。</li>
<li>丢失的最高位为0，以后各位不全为0时；或者最高为1，以后各位全为0时，不必舍入</li>
<li>丢失的最高位为1，以后各位不全为0时，则在尾数的最低位入1的修正操作</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<p>例：</p>
<p>设有浮点数x＝2-5×0.0110011， y＝23×(－0.1110010)，阶码用4位移码表示,尾数(含符号位)用8位补码表示。求[x×y]浮。要求用补码完成尾数乘法运算,运算结果尾数保留高8位(含符号位),并用尾数低位字长值处理舍入操作。</p>
<p>解：</p>
<p>移码采用双符号位,尾数补码采用单符号位,则有</p>
<p>$[Mx]_补＝0.0110011, [My]_补＝1.0001110,$</p>
<p>$[Ey]_移＝01 011, [Ey]_补＝00 011, [Ex]_移＝00 011,$</p>
<p>$[x]_浮＝00 011, 0.0110011, [y]_浮＝01 011, 1.0001110$</p>
<ol>
<li>
<p>判断操作是否为”0”,求阶码和</p>
<p>$[Ex＋Ey]_移＝[Ex]_移＋[Ey]_补＝00 011＋00 011＝00 110,$</p>
<p>值为移码形式－2。</p>
</li>
<li>
<p>尾数乘法运算可采用补码阵列乘法器实现,即有</p>
<p>$[Mx]_补×[My]_补＝[0.0110011]_补×[1.0001110]_补 =[1.1010010,1001010]_补$</p>
</li>
<li>
<p>规格化处理</p>
<p>乘积的尾数符号位与最高数值位符号相同，不是规格化的数,需要左规，阶码变为00 101(-3),</p>
<p>尾数变为 1.0100101,0010100。</p>
</li>
<li>
<p>舍入处理</p>
<p>尾数为负数，取尾数高位字长，按舍入规则,舍去低位字长，故尾数为1.0100101 。</p>
<p>最终相乘结果为</p>
<p>$[x×y]_浮＝00 101,1.0100101$</p>
<p>其真值为</p>
<p>$x×y＝2^{－3}×(－0.1011011)$</p>
</li>
<li>
<p>实现的逻辑框图</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://cdn.jsdelivr.net/gh/adan-ning/images/202404012057816.png"
        data-srcset="https://cdn.jsdelivr.net/gh/adan-ning/images/202404012057816.png, https://cdn.jsdelivr.net/gh/adan-ning/images/202404012057816.png 1.5x, https://cdn.jsdelivr.net/gh/adan-ning/images/202404012057816.png 2x"
        data-sizes="auto"
        alt="https://cdn.jsdelivr.net/gh/adan-ning/images/202404012057816.png"
        title="https://cdn.jsdelivr.net/gh/adan-ning/images/202404012057816.png" /></p>
</li>
<li>
<p>浮点运算器实例</p>
<ol>
<li>CPU之外的浮点运算器（数学协处理器）如80287
<ol>
<li>完成浮点运算功能，不能单用。</li>
<li>可以和80386或80286异步并行工作</li>
<li>高性能的80位字长的内部结构。有8个80位字长以堆栈方式管理的寄存器组。</li>
<li>浮点数格式完全符合IEEE标准</li>
</ol>
</li>
<li>CPU之内的浮点运算器（486DX以上）</li>
</ol>
</li>
</ol>
<h2 id="本-章-小-结">本 章 小 结</h2>
<ol>
<li>一个定点数由符号位和数值域两部分组成。按小数点位置不同，<strong>定点数有纯小数和纯整数两种表示方法。</strong></li>
<li>按<strong>IEEE754标准</strong>，一个浮点数由符号位S、阶码E、尾数M三个域组成。其中阶码E的值等于指数的真值e加上一个固定偏移值。</li>
<li>为了使计算机能直接处理十进制形式的数据，采用两种表示形式：(1)字符串形式，主要用在非数值计算的应用领域；(2)压缩的十进制数串形式，用于直接完成十进制数的算术运算。</li>
<li>数的真值变成机器码时有四种表示方法：<strong>原码表示法，反码表示法，补码表示法，移码表示法</strong>。其中移码主要用于表示浮点数的阶码E，以利于比较两个指数的大小和对阶操作</li>
<li>字符信息属于符号数据，是处理非数值领域的问题。国际上采用的字符系统是七单位的<strong>ASCII</strong>码。直接使用西文标准键盘输入汉字，进行处理，并显示打印汉字，是一项重大成就。为此要解决汉字的输入编码、汉字内码、字模码等三种不同用途的编码</li>
<li>为运算器构造的简单性，运算方法中算术运算通常采用<strong>补码加、减法，原码乘除法或补码乘除法</strong>。为了运算器的高速性和控制的简单性，采用了<strong>先行进位</strong>、阵列乘除法、流水线等并行技术措施。<strong>运算方法和运算器是本章的重点</strong></li>
</ol>
</div><div class="post-footer" id="post-footer">
    <div class="post-info">
        <div class="post-info-line">
            <div class="post-info-mod">
                <span>Updated on 2024-03-16</span>
            </div></div>
        <div class="post-info-line">
            <div class="post-info-md"></div>
            <div class="post-info-share">
                <span><a href="javascript:void(0);" title="Share on Twitter" data-sharer="twitter" data-url="https://adan-ning.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%862/" data-title="计算机组成(第二章)" data-hashtags="计算机组成原理"><i class="fab fa-twitter fa-fw" aria-hidden="true"></i></a><a href="javascript:void(0);" title="Share on Facebook" data-sharer="facebook" data-url="https://adan-ning.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%862/" data-hashtag="计算机组成原理"><i class="fab fa-facebook-square fa-fw" aria-hidden="true"></i></a><a href="javascript:void(0);" title="Share on Hacker News" data-sharer="hackernews" data-url="https://adan-ning.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%862/" data-title="计算机组成(第二章)"><i class="fab fa-hacker-news fa-fw" aria-hidden="true"></i></a><a href="javascript:void(0);" title="Share on Line" data-sharer="line" data-url="https://adan-ning.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%862/" data-title="计算机组成(第二章)"><i data-svg-src="https://cdn.jsdelivr.net/npm/simple-icons@7.3.0/icons/line.svg" aria-hidden="true"></i></a><a href="javascript:void(0);" title="Share on 微博" data-sharer="weibo" data-url="https://adan-ning.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%862/" data-title="计算机组成(第二章)"><i class="fab fa-weibo fa-fw" aria-hidden="true"></i></a></span>
            </div>
        </div>
    </div>

    <div class="post-info-more">
        <section class="post-tags"><i class="fas fa-tags fa-fw" aria-hidden="true"></i>&nbsp;<a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/">计算机组成原理</a></section>
        <section>
            <span><a href="javascript:void(0);" onclick="window.history.back();">Back</a></span>&nbsp;|&nbsp;<span><a href="/">Home</a></span>
        </section>
    </div>

    <div class="post-nav"><a href="/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A12/" class="prev" rel="prev" title="算法与程序(第二章)"><i class="fas fa-angle-left fa-fw" aria-hidden="true"></i>算法与程序(第二章)</a>
            <a href="/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%863/" class="next" rel="next" title="编译引论(第三章)">编译引论(第三章)<i class="fas fa-angle-right fa-fw" aria-hidden="true"></i></a></div>
</div>
</article></div>
            </main><footer class="footer">
        <div class="footer-container"><div class="footer-line">Powered by <a href="https://gohugo.io/" target="_blank" rel="noopener noreffer" title="Hugo 0.122.0">Hugo</a> | Theme - <a href="https://github.com/dillonzq/LoveIt" target="_blank" rel="noopener noreffer" title="LoveIt 0.2.11"><i class="far fa-kiss-wink-heart fa-fw" aria-hidden="true"></i> LoveIt</a>
                </div><div class="footer-line" itemscope itemtype="http://schema.org/CreativeWork"><i class="far fa-copyright fa-fw" aria-hidden="true"></i><span itemprop="copyrightYear">2020 - 2024</span><span class="author" itemprop="copyrightHolder">&nbsp;<a href="/" target="_blank">蓝Q曦</a></span>&nbsp;|&nbsp;<span class="license"><a rel="license external nofollow noopener noreffer" href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank">CC BY-NC 4.0</a></span></div>
        </div>
    </footer></div>

        <div id="fixed-buttons"><a href="#" id="back-to-top" class="fixed-button" title="Back to Top">
                <i class="fas fa-arrow-up fa-fw" aria-hidden="true"></i>
            </a><a href="#" id="view-comments" class="fixed-button" title="View Comments">
                <i class="fas fa-comment fa-fw" aria-hidden="true"></i>
            </a>
        </div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.css"><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/autocomplete.js@0.38.1/dist/autocomplete.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/algoliasearch@4.13.1/dist/algoliasearch-lite.umd.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lazysizes@5.3.2/lazysizes.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/clipboard@2.0.11/dist/clipboard.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/sharer.js@0.5.1/sharer.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/typeit@8.6.0/dist/index.umd.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/contrib/auto-render.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/contrib/copy-tex.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/contrib/mhchem.min.js"></script><script type="text/javascript">window.config={"code":{"copyTitle":"Copy to clipboard","maxShownLines":50},"comment":{},"data":{"id-1":"蓝Q曦的博客网站","id-2":"蓝Q曦的博客网站"},"math":{"delimiters":[{"display":true,"left":"$$","right":"$$"},{"display":true,"left":"\\[","right":"\\]"},{"display":true,"left":"\\begin{equation}","right":"\\end{equation}"},{"display":true,"left":"\\begin{equation*}","right":"\\end{equation*}"},{"display":true,"left":"\\begin{align}","right":"\\end{align}"},{"display":true,"left":"\\begin{align*}","right":"\\end{align*}"},{"display":true,"left":"\\begin{alignat}","right":"\\end{alignat}"},{"display":true,"left":"\\begin{alignat*}","right":"\\end{alignat*}"},{"display":true,"left":"\\begin{gather}","right":"\\end{gather}"},{"display":true,"left":"\\begin{CD}","right":"\\end{CD}"},{"display":false,"left":"$","right":"$"},{"display":false,"left":"\\(","right":"\\)"}],"strict":false},"search":{"algoliaAppID":"PELT26WIQD","algoliaIndex":"adan-ning.github.io","algoliaSearchKey":"f50812c72d6125140673e7245bea68cd","highlightTag":"em","maxResultLength":10,"noResultsFound":"No results found","snippetLength":50,"type":"algolia"},"typeit":{"cursorChar":"|","cursorSpeed":1000,"data":{"id-1":["id-1"],"id-2":["id-2"]},"duration":-1,"speed":100}};</script><script type="text/javascript" src="/js/theme.min.js"></script></body>
</html>
