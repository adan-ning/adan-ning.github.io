<!DOCTYPE html>
<html lang="zh-CN">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="robots" content="noodp" />
        <title>算法与程序(第二章) - 蓝Q曦的博客网站</title><meta name="Description" content="这是我的全新 Hugo 网站"><meta property="og:title" content="算法与程序(第二章)" />
<meta property="og:description" content="分治法 思想 分&#43;治&#43;合 过程 分治法产生的子问题是原问题的较小模式 反复应用分治手段，可以使子问题规模不断减小 最终使子问题缩小到很容易直接求出其解 将" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://adan-ning.github.io/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A12/" /><meta property="og:image" content="https://adan-ning.github.io/logo.png" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-03-12T00:00:00+00:00" />
<meta property="article:modified_time" content="2024-03-12T00:00:00+00:00" /><meta property="og:site_name" content="我的网站" />

<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:image" content="https://adan-ning.github.io/logo.png" /><meta name="twitter:title" content="算法与程序(第二章)"/>
<meta name="twitter:description" content="分治法 思想 分&#43;治&#43;合 过程 分治法产生的子问题是原问题的较小模式 反复应用分治手段，可以使子问题规模不断减小 最终使子问题缩小到很容易直接求出其解 将"/>
<meta name="application-name" content="我的网站">
<meta name="apple-mobile-web-app-title" content="我的网站"><meta name="theme-color" content="#ffffff"><meta name="msapplication-TileColor" content="#da532c"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" />
        <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
        <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5"><link rel="manifest" href="/site.webmanifest"><link rel="canonical" href="https://adan-ning.github.io/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A12/" /><link rel="prev" href="https://adan-ning.github.io/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" /><link rel="next" href="https://adan-ning.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%862/" /><link rel="stylesheet" href="/css/style.min.css"><link rel="preload" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
        <noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css"></noscript><link rel="preload" href="https://cdn.jsdelivr.net/npm/animate.css@4.1.1/animate.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
        <noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@4.1.1/animate.min.css"></noscript><script type="application/ld+json">
    {
        "@context": "http://schema.org",
        "@type": "BlogPosting",
        "headline": "算法与程序(第二章)",
        "inLanguage": "zh-CN",
        "mainEntityOfPage": {
            "@type": "WebPage",
            "@id": "https:\/\/adan-ning.github.io\/posts\/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A12\/"
        },"genre": "posts","keywords": "计算机算法设计与分析","wordcount":  3559 ,
        "url": "https:\/\/adan-ning.github.io\/posts\/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A12\/","datePublished": "2024-03-12T00:00:00+00:00","dateModified": "2024-03-12T00:00:00+00:00","publisher": {
            "@type": "Organization",
            "name": ""},"author": {
                "@type": "Person",
                "name": "蓝Q曦"
            },"description": ""
    }
    </script></head>
    <body data-header-desktop="fixed" data-header-mobile="auto"><script type="text/javascript">(window.localStorage && localStorage.getItem('theme') ? localStorage.getItem('theme') === 'dark' : ('auto' === 'auto' ? window.matchMedia('(prefers-color-scheme: dark)').matches : 'auto' === 'dark')) && document.body.setAttribute('theme', 'dark');</script>

        <div id="mask"></div><div class="wrapper"><header class="desktop" id="header-desktop">
    <div class="header-wrapper">
        <div class="header-title">
            <a href="/" title="蓝Q曦的博客网站"><span id="id-1" class="typeit"></span></a>
        </div>
        <div class="menu">
            <div class="menu-inner"><a class="menu-item" href="/posts/"> 文章 </a><a class="menu-item" href="/tags/"> 标签 </a><a class="menu-item" href="/categories/"> 分类 </a><span class="menu-item delimiter"></span><span class="menu-item search" id="search-desktop">
                        <input type="text" placeholder="Search titles or contents..." id="search-input-desktop">
                        <a href="javascript:void(0);" class="search-button search-toggle" id="search-toggle-desktop" title="Search">
                            <i class="fas fa-search fa-fw" aria-hidden="true"></i>
                        </a>
                        <a href="javascript:void(0);" class="search-button search-clear" id="search-clear-desktop" title="Clear">
                            <i class="fas fa-times-circle fa-fw" aria-hidden="true"></i>
                        </a>
                        <span class="search-button search-loading" id="search-loading-desktop">
                            <i class="fas fa-spinner fa-fw fa-spin" aria-hidden="true"></i>
                        </span>
                    </span><a href="javascript:void(0);" class="menu-item theme-switch" title="Switch Theme">
                    <i class="fas fa-adjust fa-fw" aria-hidden="true"></i>
                </a></div>

        </div>
    </div>
</header><header class="mobile" id="header-mobile">
    <div class="header-container">
        <div class="header-wrapper">
            <div class="header-title">
                <a href="/" title="蓝Q曦的博客网站"><span id="id-2" class="typeit"></span></a>
            </div>
            <div class="menu-toggle" id="menu-toggle-mobile">
                <span></span><span></span><span></span>
            </div>
        </div>
        <div class="menu" id="menu-mobile"><div class="search-wrapper">
                    <div class="search mobile" id="search-mobile">
                        <input type="text" placeholder="Search titles or contents..." id="search-input-mobile">
                        <a href="javascript:void(0);" class="search-button search-toggle" id="search-toggle-mobile" title="Search">
                            <i class="fas fa-search fa-fw" aria-hidden="true"></i>
                        </a>
                        <a href="javascript:void(0);" class="search-button search-clear" id="search-clear-mobile" title="Clear">
                            <i class="fas fa-times-circle fa-fw" aria-hidden="true"></i>
                        </a>
                        <span class="search-button search-loading" id="search-loading-mobile">
                            <i class="fas fa-spinner fa-fw fa-spin" aria-hidden="true"></i>
                        </span>
                    </div>
                    <a href="javascript:void(0);" class="search-cancel" id="search-cancel-mobile">
                        Cancel
                    </a>
                </div><a class="menu-item" href="/posts/" title="">文章</a><a class="menu-item" href="/tags/" title="">标签</a><a class="menu-item" href="/categories/" title="">分类</a><a href="javascript:void(0);" class="menu-item theme-switch" title="Switch Theme">
                <i class="fas fa-adjust fa-fw" aria-hidden="true"></i>
            </a></div>
    </div>
</header><div class="search-dropdown desktop">
        <div id="search-dropdown-desktop"></div>
    </div>
    <div class="search-dropdown mobile">
        <div id="search-dropdown-mobile"></div>
    </div><main class="main">
                <div class="container"><div class="toc" id="toc-auto">
            <h2 class="toc-title">Contents</h2>
            <div class="toc-content" id="toc-content-auto"></div>
        </div><article class="page single"><h1 class="single-title animate__animated animate__flipInX">算法与程序(第二章)</h1><div class="post-meta">
            <div class="post-meta-line"><span class="post-author"><a href="/" title="Author" rel="author" class="author"><i class="fas fa-user-circle fa-fw" aria-hidden="true"></i>蓝Q曦</a></span>&nbsp;<span class="post-category">included in <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/"><i class="far fa-folder fa-fw" aria-hidden="true"></i>计算机算法设计与分析</a></span></div>
            <div class="post-meta-line"><i class="far fa-calendar-alt fa-fw" aria-hidden="true"></i>&nbsp;<time datetime="2024-03-12">2024-03-12</time>&nbsp;<i class="fas fa-pencil-alt fa-fw" aria-hidden="true"></i>&nbsp;3559 words&nbsp;
                <i class="far fa-clock fa-fw" aria-hidden="true"></i>&nbsp;8 minutes&nbsp;</div>
        </div><div class="details toc" id="toc-static"  data-kept="true">
                <div class="details-summary toc-title">
                    <span>Contents</span>
                    <span><i class="details-icon fas fa-angle-right" aria-hidden="true"></i></span>
                </div>
                <div class="details-content toc-content" id="toc-content-static"><nav id="TableOfContents">
  <ul>
    <li><a href="#思想">思想</a></li>
    <li><a href="#过程">过程</a></li>
  </ul>

  <ul>
    <li><a href="#递归算法的框架">递归算法的框架</a></li>
    <li><a href="#要素">要素</a></li>
    <li><a href="#小结">小结</a></li>
  </ul>

  <ul>
    <li><a href="#最优子传构性质">最优子传构性质</a></li>
    <li><a href="#分治法时间复杂度分析">分治法时间复杂度分析</a></li>
  </ul>

  <ul>
    <li>
      <ul>
        <li><a href="#二分搜索技术递归算法">二分搜索技术(递归算法)</a></li>
        <li><a href="#二分搜索技术非递归算法">二分搜索技术(非递归算法)</a></li>
      </ul>
    </li>
    <li><a href="#快速幂算法">快速幂算法</a></li>
    <li><a href="#strassen矩阵乘法">Strassen矩阵乘法</a></li>
    <li><a href="#棋盘覆盖">棋盘覆盖</a></li>
    <li><a href="#合并排序">合并排序</a></li>
    <li><a href="#快速排序">快速排序</a></li>
    <li><a href="#线性时间选择">线性时间选择</a></li>
  </ul>
</nav></div>
            </div><div class="content" id="content"><h1 id="分治法">分治法</h1>
<h2 id="思想">思想</h2>
<p>分+治+合
<img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://cdn.jsdelivr.net/gh/adan-ning/images/202403121902318.jpg"
        data-srcset="https://cdn.jsdelivr.net/gh/adan-ning/images/202403121902318.jpg, https://cdn.jsdelivr.net/gh/adan-ning/images/202403121902318.jpg 1.5x, https://cdn.jsdelivr.net/gh/adan-ning/images/202403121902318.jpg 2x"
        data-sizes="auto"
        alt="https://cdn.jsdelivr.net/gh/adan-ning/images/202403121902318.jpg"
        title="https://cdn.jsdelivr.net/gh/adan-ning/images/202403121902318.jpg" /></p>
<h2 id="过程">过程</h2>
<ol>
<li>
<p>分治法产生的子问题是原问题的较小模式</p>
</li>
<li>
<p>反复应用分治手段，可以使子问题规模不断减小</p>
</li>
<li>
<p>最终使子问题缩小到很容易直接求出其解</p>
</li>
<li>
<p>将规模较小问题的答案逐级向上合并(递归过程)，可得大问题答案</p>
<p>分治法解决问题通常使用递归算法</p>
</li>
</ol>
<h1 id="递归的概念">递归的概念</h1>
<p>直接或间接地调用自身的算法称为递归算法</p>
<h2 id="递归算法的框架">递归算法的框架</h2>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://cdn.jsdelivr.net/gh/adan-ning/images/202403121907087.jpg"
        data-srcset="https://cdn.jsdelivr.net/gh/adan-ning/images/202403121907087.jpg, https://cdn.jsdelivr.net/gh/adan-ning/images/202403121907087.jpg 1.5x, https://cdn.jsdelivr.net/gh/adan-ning/images/202403121907087.jpg 2x"
        data-sizes="auto"
        alt="https://cdn.jsdelivr.net/gh/adan-ning/images/202403121907087.jpg"
        title="https://cdn.jsdelivr.net/gh/adan-ning/images/202403121907087.jpg" /></p>
<h2 id="要素">要素</h2>
<p>边界条件与递归方程是递归函数的两个要素
递归函数只有这两个要素才能在有限次运算得出结果</p>
<h2 id="小结">小结</h2>
<p>优点:结构清晰，可读性强，而且容易用数学归纳法来证明算法的正确性，因此它为设计算法，调试程序带来很大方便</p>
<p>缺点:递归算法的运行效率较低，无论是耗费的计算时间还是占用的存储空间都比非递归算法要多</p>
<p>建议:</p>
<ol>
<li>如果问题用递推方法可解决，就不要使用递归算法</li>
<li>用栈模拟的非递归算法，对运行效率改善有限，不建议使用</li>
</ol>
<h1 id="分治法的适用条件">分治法的适用条件</h1>
<p>n个问题分解为k个规模较小的子问题，子问题之间相互独立，不包含公共的问题，名子问题的解合并得到原问题的解</p>
<h2 id="最优子传构性质">最优子传构性质</h2>
<p>最优子结构是依赖特定问题和子问题的分割方式而成立的条件。各子问题具有最优解，就能求出整个问题的最优解，此时条件成立。</p>
<p>比如求广州到北京的最短距离，假设这个路径必经过中间的南京，那么先把路径分割为（广州，南京）和（南京，北京）。分别求出子路径的最短距离然后再连接，就可以得到广州到北京的最短路径。</p>
<p>因此，寻求最短路径的问题可以利用子路径的最优解获得整个问题的最优解。这样就可以证明，最短路径具有最优子结构。</p>
<h2 id="分治法时间复杂度分析">分治法时间复杂度分析</h2>
<p>一个分治法将规模为n的问题分成k个规模为n/m的子问题去解。为方便起见，设分解阈值n0为1，且adhoc解规模为1的问题耗费1单位时间。另外，将原问题分解为k个子问题及用merge将k个子问题的解合并为原问题的解需用f(n)单位时间</p>
<h1 id="二分搜索技术">二分搜索技术</h1>
<p>将n个元素分成个数大致相同的两半，取a[n/2]与x作比较。如果x=a[n/2]，则找到x，算法终止；如果x&lt;a[n/2]，则只在数组a的左半部继续搜索x;如果x&gt;a[n/2]，则只在数组a的右半部继续搜索x</p>
<p>具体描述算法如下：</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://cdn.jsdelivr.net/gh/adan-ning/images/202403121921051.jpg"
        data-srcset="https://cdn.jsdelivr.net/gh/adan-ning/images/202403121921051.jpg, https://cdn.jsdelivr.net/gh/adan-ning/images/202403121921051.jpg 1.5x, https://cdn.jsdelivr.net/gh/adan-ning/images/202403121921051.jpg 2x"
        data-sizes="auto"
        alt="https://cdn.jsdelivr.net/gh/adan-ning/images/202403121921051.jpg"
        title="https://cdn.jsdelivr.net/gh/adan-ning/images/202403121921051.jpg" /></p>
<h3 id="二分搜索技术递归算法">二分搜索技术(递归算法)</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">BinarySearch_Rec</span><span class="p">(</span><span class="kt">int</span> <span class="n">num</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">target</span><span class="p">,</span> <span class="kt">int</span> <span class="n">left</span><span class="p">,</span> <span class="kt">int</span> <span class="n">right</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="n">left</span> <span class="o">&lt;=</span> <span class="n">right</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="n">left</span> <span class="o">+</span> <span class="p">(</span><span class="n">right</span> <span class="o">-</span> <span class="n">left</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">num</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span> <span class="o">==</span> <span class="n">target</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="n">mid</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">num</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">target</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="nf">BinarySearch_Rec</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">mid</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">num</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">target</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="nf">BinarySearch_Rec</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">right</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p><strong>算法复杂度分析</strong></p>
<p>$T(n)\begin{cases}1,n=0\T(n/2)+1,n&gt;1\end{cases}$</p>
<p>**利用主定理或递归树可求其时间复杂性为O(logn) **</p>
<h3 id="二分搜索技术非递归算法">二分搜索技术(非递归算法)</h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">BinarySearch</span><span class="p">(</span><span class="kt">int</span> <span class="n">num</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">target</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span> <span class="c1">//非递归实现
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="n">len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// 第一个细节点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span> 
</span></span><span class="line"><span class="cl">    <span class="k">while</span> <span class="p">(</span><span class="n">left</span> <span class="o">&lt;=</span> <span class="n">right</span><span class="p">)</span> <span class="c1">// 第二个细节点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="n">left</span> <span class="o">+</span> <span class="p">(</span><span class="n">right</span> <span class="o">-</span> <span class="n">left</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="p">(</span><span class="n">num</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span> <span class="o">==</span> <span class="n">target</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span> <span class="n">mid</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">num</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">target</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="n">right</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// 第三个细节点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">num</span><span class="p">[</span><span class="n">mid</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">target</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">            <span class="n">left</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// 第四个细节点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl"> 
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p><strong>算法复杂度分析</strong></p>
<p>每执行一次while循环，待搜素数组的大小减小1/2.在最坏情况下，while循环被执行了O(logn)次，因此算法在最坏情况下计算时间复杂性为O(logn)</p>
<h2 id="快速幂算法">快速幂算法</h2>
<p>给定实数a和非负整数n，用分治法设计求$a^n$的快速算法(递归算法)</p>
<p>分析：</p>
<p>$$a^n\begin{cases}0,a=0\1,n=0\(a^\frac{n}{2})^2,n&gt;0,n为偶数\(a^\frac{n}{2})^2*n,n&gt;0,n为奇数\end{cases}$$</p>
<p><strong>算法如下</strong></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">double</span> <span class="nf">exp2</span><span class="p">(</span><span class="kt">double</span> <span class="n">a</span><span class="p">,</span><span class="kt">int</span> <span class="n">n</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span><span class="p">(</span><span class="n">a</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span><span class="p">(</span><span class="n">n</span><span class="o">&lt;=</span><span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="k">else</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="kt">int</span> <span class="n">x</span><span class="o">=</span><span class="nf">exp2</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">n</span><span class="o">/</span><span class="mi">2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span><span class="p">(</span><span class="n">n</span><span class="o">%</span><span class="mi">2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="k">return</span> <span class="n">a</span><span class="o">*</span><span class="n">x</span><span class="o">*</span><span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="k">else</span>
</span></span><span class="line"><span class="cl">			<span class="k">return</span> <span class="n">x</span><span class="o">*</span><span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p><strong>该问题满足四个条件时间复杂性O(logn)</strong></p>
<p>给定正整数a和n，用分治法设计求$a^n$的快速算法(非递归算法)</p>
<p>举例求$a^{93}$</p>
<p>n=93的二进制表示(如图)，也就是n=64+16+8+4+1,因此$a^{93}=a^{64}a^{16}a^8a^4a$</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://cdn.jsdelivr.net/gh/adan-ning/images/202403181356063.jpg"
        data-srcset="https://cdn.jsdelivr.net/gh/adan-ning/images/202403181356063.jpg, https://cdn.jsdelivr.net/gh/adan-ning/images/202403181356063.jpg 1.5x, https://cdn.jsdelivr.net/gh/adan-ning/images/202403181356063.jpg 2x"
        data-sizes="auto"
        alt="https://cdn.jsdelivr.net/gh/adan-ning/images/202403181356063.jpg"
        title="https://cdn.jsdelivr.net/gh/adan-ning/images/202403181356063.jpg" /></p>
<p><strong>算法如下</strong></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">double</span> <span class="nf">exp2</span><span class="p">(</span><span class="kt">double</span> <span class="n">a</span><span class="p">,</span><span class="kt">int</span> <span class="n">n</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">double</span> <span class="n">b</span><span class="p">,</span><span class="n">s</span><span class="o">=</span><span class="mf">1.0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="n">i</span><span class="o">=</span><span class="n">n</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="n">b</span><span class="o">=</span><span class="n">a</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="k">while</span><span class="p">(</span><span class="n">i</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span><span class="p">(</span><span class="n">i</span><span class="o">%</span><span class="mi">2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="n">s</span><span class="o">*=</span><span class="n">b</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="n">i</span><span class="o">/=</span><span class="mi">2</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">		<span class="n">b</span><span class="o">*=</span><span class="n">b</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="n">s</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h2 id="strassen矩阵乘法">Strassen矩阵乘法</h2>
<p>首先，仍假设n是2的幂。将矩阵A,B和C中的每个矩阵都分块成4个大小相等的子矩阵，每个子矩阵都是n/2*n/2的方阵。由此可将方程C=AB重写为：</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://cdn.jsdelivr.net/gh/adan-ning/images/202403181407169.jpg"
        data-srcset="https://cdn.jsdelivr.net/gh/adan-ning/images/202403181407169.jpg, https://cdn.jsdelivr.net/gh/adan-ning/images/202403181407169.jpg 1.5x, https://cdn.jsdelivr.net/gh/adan-ning/images/202403181407169.jpg 2x"
        data-sizes="auto"
        alt="https://cdn.jsdelivr.net/gh/adan-ning/images/202403181407169.jpg"
        title="https://cdn.jsdelivr.net/gh/adan-ning/images/202403181407169.jpg" /></p>
<p><strong>时间复杂性分析</strong></p>
<p>上述分治法的计算时间耗费T(n)应满足</p>
<p>$T(n)\begin{cases}O(1),n=2\8T(n/2)+O(n^2),n&gt;2\end{cases}$</p>
<p>这个递归方程的解仍然是T(n)=O($n^3$)。因此，该方法并不比用原始定义直接计算更有效。究其原因，由于是该方法并没有减少矩阵的乘法次数。</p>
<p>要想改进矩阵乘法的计算时间复杂性，必须减少乘法运算</p>
<p><strong>优化</strong></p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://cdn.jsdelivr.net/gh/adan-ning/images/202403181415067.jpg"
        data-srcset="https://cdn.jsdelivr.net/gh/adan-ning/images/202403181415067.jpg, https://cdn.jsdelivr.net/gh/adan-ning/images/202403181415067.jpg 1.5x, https://cdn.jsdelivr.net/gh/adan-ning/images/202403181415067.jpg 2x"
        data-sizes="auto"
        alt="https://cdn.jsdelivr.net/gh/adan-ning/images/202403181415067.jpg"
        title="https://cdn.jsdelivr.net/gh/adan-ning/images/202403181415067.jpg" /></p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://cdn.jsdelivr.net/gh/adan-ning/images/202403181416658.jpg"
        data-srcset="https://cdn.jsdelivr.net/gh/adan-ning/images/202403181416658.jpg, https://cdn.jsdelivr.net/gh/adan-ning/images/202403181416658.jpg 1.5x, https://cdn.jsdelivr.net/gh/adan-ning/images/202403181416658.jpg 2x"
        data-sizes="auto"
        alt="https://cdn.jsdelivr.net/gh/adan-ning/images/202403181416658.jpg"
        title="https://cdn.jsdelivr.net/gh/adan-ning/images/202403181416658.jpg" /></p>
<p><strong>时间复杂性分析</strong></p>
<p>Strassen矩阵乘法中用了7次对于n/2阶矩阵乘积的递归调用和18次n/2阶矩阵的加减运算。由此可知，该算法所需的计算时间T(n)满足如下递归方程：</p>
<p>$T(n)\begin{cases}O(1),n=2\7T(n/2)+O(n^2),n&gt;2\end{cases}$</p>
<p>解此递归方程得T(n)=O($n^{log7}$)$\approx$O($n^{2.81}$)。由此可见，Strassen矩阵乘法的计算时间复杂性比普通矩阵乘法有较大改进</p>
<h2 id="棋盘覆盖">棋盘覆盖</h2>
<p>当k&gt;0时，将$2^k\times 2^k$棋盘分割为4个$2^{k-1}\times 2{k-1}$子棋盘，如图a所示。特殊方格必位4个较小子棋盘之一中，其余3个子棋盘中无特殊方格。为了将这3个无特殊方格的子棋盘转化为特殊棋盘，可以用一个L型骨牌覆盖这3个较小棋盘的会合处，如b所示，这3个子棋盘上被L型骨牌覆盖的方格就成为该棋盘上的特殊方格，从而将原问题转化为4个较小规模的棋盘覆盖问题。递归地使用这种分割，直至棋盘简化为$1\times1$棋盘</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://cdn.jsdelivr.net/gh/adan-ning/images/202403191822190.jpg"
        data-srcset="https://cdn.jsdelivr.net/gh/adan-ning/images/202403191822190.jpg, https://cdn.jsdelivr.net/gh/adan-ning/images/202403191822190.jpg 1.5x, https://cdn.jsdelivr.net/gh/adan-ning/images/202403191822190.jpg 2x"
        data-sizes="auto"
        alt="https://cdn.jsdelivr.net/gh/adan-ning/images/202403191822190.jpg"
        title="https://cdn.jsdelivr.net/gh/adan-ning/images/202403191822190.jpg" /></p>
<p><strong>算法如下</strong></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">chessBoard</span><span class="p">(</span><span class="kt">int</span> <span class="n">tr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">tc</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dc</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="n">size</span><span class="o">==</span><span class="mi">1</span><span class="p">)</span> 
</span></span><span class="line"><span class="cl">    	<span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">s</span> <span class="o">=</span> <span class="n">size</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span>     <span class="c1">//分割棋盘
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">t</span> <span class="o">=</span> <span class="o">++</span><span class="n">num</span><span class="p">;</span>      <span class="c1">//L型骨牌号
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    
</span></span><span class="line"><span class="cl">    <span class="c1">//覆盖左上角子棋盘
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">dr</span> <span class="o">&lt;</span> <span class="n">tr</span> <span class="o">+</span> <span class="n">s</span> <span class="o">&amp;&amp;</span> <span class="n">dc</span> <span class="o">&lt;</span> <span class="n">tc</span> <span class="o">+</span><span class="n">s</span><span class="p">)</span>                
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">//特殊方格在此棋盘中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">chessBoard</span><span class="p">(</span><span class="n">tr</span><span class="p">,</span><span class="n">tc</span><span class="p">,</span><span class="n">dr</span><span class="p">,</span><span class="n">dc</span><span class="p">,</span><span class="n">s</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span>            <span class="c1">//此棋盘中无特殊方格
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">//用t号L型骨牌覆盖右下角
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">Matrix</span><span class="p">[</span><span class="n">tr</span><span class="o">+</span><span class="n">s</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">tc</span><span class="o">+</span><span class="n">s</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">t</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="c1">//覆盖其余方格
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">chessBoard</span><span class="p">(</span><span class="n">tr</span><span class="p">,</span><span class="n">tc</span><span class="p">,</span><span class="n">tr</span><span class="o">+</span><span class="n">s</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">tc</span><span class="o">+</span><span class="n">s</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">s</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="c1">//覆盖右上角子棋盘
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">dr</span> <span class="o">&lt;</span> <span class="n">tr</span> <span class="o">+</span> <span class="n">s</span> <span class="o">&amp;&amp;</span> <span class="n">dc</span> <span class="o">&gt;=</span> <span class="n">tc</span> <span class="o">+</span> <span class="n">s</span> <span class="p">)</span>           
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">//特殊方格在此棋盘中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">chessBoard</span><span class="p">(</span><span class="n">tr</span><span class="p">,</span><span class="n">tc</span><span class="o">+</span><span class="n">s</span><span class="p">,</span><span class="n">dr</span><span class="p">,</span><span class="n">dc</span><span class="p">,</span><span class="n">s</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span>            <span class="c1">//此棋盘中无特殊方格
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">//用t号L型骨牌覆盖左下角
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">Matrix</span><span class="p">[</span><span class="n">tr</span><span class="o">+</span><span class="n">s</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">tc</span><span class="o">+</span><span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="n">t</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="c1">//覆盖其余方格
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">chessBoard</span><span class="p">(</span><span class="n">tr</span><span class="p">,</span><span class="n">tc</span><span class="o">+</span><span class="n">s</span><span class="p">,</span><span class="n">tr</span><span class="o">+</span><span class="n">s</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">tc</span><span class="o">+</span><span class="n">s</span><span class="p">,</span><span class="n">s</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">     <span class="c1">//覆盖左下角子棋盘
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">dr</span> <span class="o">&gt;=</span> <span class="n">tr</span> <span class="o">+</span> <span class="n">s</span> <span class="o">&amp;&amp;</span> <span class="n">dc</span> <span class="o">&lt;</span> <span class="n">tc</span> <span class="o">+</span> <span class="n">s</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">//特殊方格在此棋盘中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">chessBoard</span><span class="p">(</span><span class="n">tr</span><span class="o">+</span><span class="n">s</span><span class="p">,</span><span class="n">tc</span><span class="p">,</span><span class="n">dr</span><span class="p">,</span><span class="n">dc</span><span class="p">,</span><span class="n">s</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">//用t号L型骨牌覆盖右上角
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">Matrix</span><span class="p">[</span><span class="n">tr</span><span class="o">+</span><span class="n">s</span><span class="p">][</span><span class="n">tc</span><span class="o">+</span><span class="n">s</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">t</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="c1">//覆盖其余方格
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">chessBoard</span><span class="p">(</span><span class="n">tr</span><span class="o">+</span><span class="n">s</span><span class="p">,</span><span class="n">tc</span><span class="p">,</span><span class="n">tr</span><span class="o">+</span><span class="n">s</span><span class="p">,</span><span class="n">tc</span><span class="o">+</span><span class="n">s</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">s</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">     <span class="c1">//覆盖右下角子棋盘
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">dr</span> <span class="o">&gt;=</span> <span class="n">tr</span> <span class="o">+</span> <span class="n">s</span> <span class="o">&amp;&amp;</span> <span class="n">dc</span> <span class="o">&gt;=</span> <span class="n">tc</span> <span class="o">+</span> <span class="n">s</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">          <span class="c1">//特殊方格在此棋盘中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">chessBoard</span><span class="p">(</span><span class="n">tr</span><span class="o">+</span><span class="n">s</span><span class="p">,</span><span class="n">tc</span><span class="o">+</span><span class="n">s</span><span class="p">,</span><span class="n">dr</span><span class="p">,</span><span class="n">dc</span><span class="p">,</span><span class="n">s</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">//用t号L型骨牌覆盖左上角
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">Matrix</span><span class="p">[</span><span class="n">tr</span><span class="o">+</span><span class="n">s</span><span class="p">][</span><span class="n">tc</span><span class="o">+</span><span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="n">t</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="c1">//覆盖其余方格
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nf">chessBoard</span><span class="p">(</span><span class="n">tr</span><span class="o">+</span><span class="n">s</span><span class="p">,</span><span class="n">tc</span><span class="o">+</span><span class="n">s</span><span class="p">,</span><span class="n">tr</span><span class="o">+</span><span class="n">s</span><span class="p">,</span><span class="n">tc</span><span class="o">+</span><span class="n">s</span><span class="p">,</span><span class="n">s</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p><strong>复杂度分析</strong></p>
<p>$T(n)\begin{cases}O(1),n=1\4T({n\over2})+O(1),n&gt;1\end{cases}$</p>
<p>T(n)=O($n^2$)</p>
<p>本算法可使用队列或者栈实现，非递归算法</p>
<h2 id="合并排序">合并排序</h2>
<p>将待排序元素分成大小大致相同的两个子集合，分别对两个子集合进行排序，最终将排好序的子集合合并成要求好的排好序的集合</p>
<p><strong>算法描述(可递归)</strong></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">Type</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">MergeSort</span><span class="p">(</span><span class="n">Type</span> <span class="n">a</span><span class="p">[],</span><span class="kt">int</span> <span class="n">left</span><span class="p">,</span><span class="kt">int</span> <span class="n">right</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span><span class="p">(</span><span class="n">left</span><span class="o">&lt;</span><span class="n">right</span><span class="p">){</span>			<span class="c1">//至少有2个元素
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span><span class="p">(</span><span class="n">left</span> <span class="o">+</span> <span class="n">right</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span>	<span class="c1">//取中点
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nf">MergeSort</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">left</span><span class="p">,</span><span class="n">i</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">		<span class="nf">MergeSort</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">right</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">		<span class="nf">Merge</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">left</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">right</span><span class="p">);</span>		<span class="c1">//合并到数组b
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nf">Copy</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">left</span><span class="p">,</span><span class="n">right</span><span class="p">);</span>		<span class="c1">//复制回数组a
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="p">}</span>				
</span></span><span class="line"><span class="cl">	
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p><strong>算法MergeSort的递归过程可以消去</strong></p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://cdn.jsdelivr.net/gh/adan-ning/images/202403191730648.jpg"
        data-srcset="https://cdn.jsdelivr.net/gh/adan-ning/images/202403191730648.jpg, https://cdn.jsdelivr.net/gh/adan-ning/images/202403191730648.jpg 1.5x, https://cdn.jsdelivr.net/gh/adan-ning/images/202403191730648.jpg 2x"
        data-sizes="auto"
        alt="https://cdn.jsdelivr.net/gh/adan-ning/images/202403191730648.jpg"
        title="https://cdn.jsdelivr.net/gh/adan-ning/images/202403191730648.jpg" /></p>
<p><strong>复杂度分析</strong></p>
<p>最坏时间复杂度：O(nlogn)</p>
<p>平均时间复杂度：O(nlogn)</p>
<p>辅助空间：O(n)</p>
<p>稳定性：稳定</p>
<h2 id="快速排序">快速排序</h2>
<p><strong>快速排序算法是基于分治策略的另一个排序算法。其基本思想是，对于输入的子数组a[p:r]，按以下三个步骤进行排序。</strong></p>
<ol>
<li>分解(Divide):以a[p]为基准元素将a[p:r]划分成3段a[p:q-1],a[q]和a[q+1:r]，使a[p:q-1]中任何一个元素小于等于a[q]，而a[q+1:r]中任何一个元素大于等于a[q]。下标q在划分过程中确定</li>
<li>递归求解(Conquer)：通过递归调用快速排序算法，分别对a[p:q-1]和a[q+1:r]进行排序</li>
<li>合并(Merge):由于对a[p:q-1]和a[q+1:r]的排序是就地进行的，因此在a[p:q-1]和a[q+1:r]都已排好的序后，不需要执行任何计算，a[p:r]则已排好序</li>
</ol>
<p>算法如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="nf">template</span><span class="p">(</span><span class="n">class</span> <span class="n">Type</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">QuickSort</span><span class="p">(</span><span class="n">Type</span> <span class="n">a</span><span class="p">[],</span><span class="kt">int</span> <span class="n">p</span><span class="p">,</span><span class="kt">int</span> <span class="n">r</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span><span class="p">(</span><span class="n">p</span><span class="o">&lt;</span><span class="n">r</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">		<span class="kt">int</span> <span class="n">q</span><span class="o">=</span><span class="nf">Partition</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">p</span><span class="p">,</span><span class="n">r</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">		<span class="nf">QuickSort</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">p</span><span class="p">,</span><span class="n">q</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>		<span class="c1">//对左半段排序
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nf">QuickSort</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">q</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">r</span><span class="p">);</span>		<span class="c1">//对右半段排序
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>对含有n个元素的数组a[0:n-1]进行快速排序只要调用QuickSort(a,0,n-1)即可。</p>
<p>上述算法中的函数Partition()以一个确定的基准元素a[p]对子数组a[p:r]进行划分，它是快速排序算法的关键。</p>
<p>算法如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="n">template</span><span class="o">&lt;</span><span class="n">Class</span> <span class="n">Type</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">Partition</span> <span class="p">(</span><span class="n">Type</span> <span class="n">a</span><span class="p">[],</span><span class="kt">int</span> <span class="n">p</span><span class="p">,</span><span class="kt">int</span> <span class="n">r</span><span class="p">){</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span><span class="n">p</span><span class="p">,</span><span class="n">j</span><span class="o">=</span><span class="n">r</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">Type</span> <span class="n">x</span> <span class="o">=</span><span class="n">a</span><span class="p">[</span><span class="n">p</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="c1">//将小于x的元素交换到左边区域，将大于x的元素交换到右边区域
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">while</span><span class="p">(</span><span class="nb">true</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">	<span class="k">while</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="o">++</span><span class="n">i</span><span class="p">]</span><span class="o">&lt;</span><span class="n">x</span><span class="o">&amp;&amp;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">r</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="k">while</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="o">--</span><span class="n">j</span><span class="p">]</span><span class="o">&gt;</span><span class="n">x</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span><span class="p">(</span><span class="n">i</span><span class="o">&gt;=</span><span class="n">j</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="nf">Swap</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="n">a</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">return</span> <span class="n">j</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p><strong>复杂度分析</strong></p>
<p><strong>快速排序算法的性能取决于划分的对称性</strong></p>
<p>最坏情况，每次划分出的二个子问题，一个长度为0，另一个长度为n-1，其对应的时间复杂性的递归定义为：</p>
<p>$T(n)\begin{cases}1,n=1\T(n-1)+n,n&gt;1\end{cases}$</p>
<p>最坏时间复杂度：O($n^2$)</p>
<p>平均时间复杂度：O(nlogn)</p>
<p>稳定性：不稳定</p>
<p><strong>通过修改算法partition，可以设计出采用随机选择策略的快速排序算法。可以在a[p:r]中随机选出一个元素作为划分基准。可以期望划分是较对称的。</strong></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="n">template</span><span class="o">&lt;</span><span class="n">Class</span> <span class="n">Type</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">RandomizedPartition</span><span class="p">(</span><span class="n">Type</span> <span class="n">a</span><span class="p">[],</span><span class="kt">int</span> <span class="n">p</span><span class="p">,</span><span class="kt">int</span> <span class="n">r</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="nf">Random</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="n">r</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">Swap</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">a</span><span class="p">[</span><span class="n">p</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nf">Partition</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">p</span><span class="p">,</span><span class="n">r</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">RandomizedQuickSort</span><span class="p">(</span><span class="n">Type</span> <span class="n">a</span><span class="p">[],</span><span class="kt">int</span> <span class="n">p</span><span class="p">,</span><span class="kt">int</span> <span class="n">r</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span><span class="p">(</span><span class="n">p</span><span class="o">&lt;</span><span class="n">r</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">		<span class="kt">int</span> <span class="n">q</span><span class="o">=</span><span class="nf">RandomizedPartition</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">p</span><span class="p">,</span><span class="n">r</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">		<span class="nf">RandomizedQuickSort</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">p</span><span class="p">,</span><span class="n">q</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>		<span class="c1">//对左半段排序
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nf">RandomizedQuickSort</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">q</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">r</span><span class="p">);</span>		<span class="c1">//对右半段排序
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h2 id="线性时间选择">线性时间选择</h2>
<p>给定线性序集中n个元素和一个整数k，$1\leq k \leq n$，要求找出这n个元素中第k小的元素</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="n">template</span><span class="o">&lt;</span><span class="n">Class</span> <span class="n">Type</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="n">Type</span> <span class="nf">RandomizedSelect</span><span class="p">(</span><span class="n">Type</span> <span class="n">a</span><span class="p">[],</span><span class="kt">int</span> <span class="n">p</span><span class="p">,</span><span class="kt">int</span> <span class="n">r</span><span class="p">,</span><span class="kt">int</span> <span class="n">k</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span><span class="p">(</span><span class="n">p</span><span class="o">==</span><span class="n">r</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="n">a</span><span class="p">[</span><span class="n">p</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="nf">RandomizedPartition</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">p</span><span class="p">,</span><span class="n">r</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="n">j</span><span class="o">=</span><span class="n">j</span><span class="o">-</span><span class="n">p</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span><span class="p">(</span><span class="n">j</span><span class="o">==</span><span class="n">k</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span><span class="p">(</span><span class="n">k</span><span class="o">&lt;</span><span class="n">j</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="nf">RandomizedSelect</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">p</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">k</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="k">else</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="nf">RandomizedSelect</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">r</span><span class="p">,</span><span class="n">k</span><span class="o">-</span><span class="n">j</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p><strong>时间复杂性分析</strong></p>
<p>在最坏情况下，算法RandomizedSelect需要O($n^2$)计算时间</p>
<p>但可以证明，算法RandomizedSelect可以在O(n)平均时间内找出n个输入元素中的第k小元素</p>
</div><div class="post-footer" id="post-footer">
    <div class="post-info">
        <div class="post-info-line">
            <div class="post-info-mod">
                <span>Updated on 2024-03-12</span>
            </div></div>
        <div class="post-info-line">
            <div class="post-info-md"></div>
            <div class="post-info-share">
                <span><a href="javascript:void(0);" title="Share on Twitter" data-sharer="twitter" data-url="https://adan-ning.github.io/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A12/" data-title="算法与程序(第二章)" data-hashtags="计算机算法设计与分析"><i class="fab fa-twitter fa-fw" aria-hidden="true"></i></a><a href="javascript:void(0);" title="Share on Facebook" data-sharer="facebook" data-url="https://adan-ning.github.io/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A12/" data-hashtag="计算机算法设计与分析"><i class="fab fa-facebook-square fa-fw" aria-hidden="true"></i></a><a href="javascript:void(0);" title="Share on Hacker News" data-sharer="hackernews" data-url="https://adan-ning.github.io/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A12/" data-title="算法与程序(第二章)"><i class="fab fa-hacker-news fa-fw" aria-hidden="true"></i></a><a href="javascript:void(0);" title="Share on Line" data-sharer="line" data-url="https://adan-ning.github.io/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A12/" data-title="算法与程序(第二章)"><i data-svg-src="https://cdn.jsdelivr.net/npm/simple-icons@7.3.0/icons/line.svg" aria-hidden="true"></i></a><a href="javascript:void(0);" title="Share on 微博" data-sharer="weibo" data-url="https://adan-ning.github.io/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A12/" data-title="算法与程序(第二章)"><i class="fab fa-weibo fa-fw" aria-hidden="true"></i></a></span>
            </div>
        </div>
    </div>

    <div class="post-info-more">
        <section class="post-tags"><i class="fas fa-tags fa-fw" aria-hidden="true"></i>&nbsp;<a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/">计算机算法设计与分析</a></section>
        <section>
            <span><a href="javascript:void(0);" onclick="window.history.back();">Back</a></span>&nbsp;|&nbsp;<span><a href="/">Home</a></span>
        </section>
    </div>

    <div class="post-nav"><a href="/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" class="prev" rel="prev" title="数据结构(第一章)"><i class="fas fa-angle-left fa-fw" aria-hidden="true"></i>数据结构(第一章)</a>
            <a href="/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%862/" class="next" rel="next" title="计算机组成(第二章)">计算机组成(第二章)<i class="fas fa-angle-right fa-fw" aria-hidden="true"></i></a></div>
</div>
</article></div>
            </main><footer class="footer">
        <div class="footer-container"><div class="footer-line">Powered by <a href="https://gohugo.io/" target="_blank" rel="noopener noreffer" title="Hugo 0.122.0">Hugo</a> | Theme - <a href="https://github.com/dillonzq/LoveIt" target="_blank" rel="noopener noreffer" title="LoveIt 0.2.11"><i class="far fa-kiss-wink-heart fa-fw" aria-hidden="true"></i> LoveIt</a>
                </div><div class="footer-line" itemscope itemtype="http://schema.org/CreativeWork"><i class="far fa-copyright fa-fw" aria-hidden="true"></i><span itemprop="copyrightYear">2020 - 2024</span><span class="author" itemprop="copyrightHolder">&nbsp;<a href="/" target="_blank">蓝Q曦</a></span>&nbsp;|&nbsp;<span class="license"><a rel="license external nofollow noopener noreffer" href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank">CC BY-NC 4.0</a></span></div>
        </div>
    </footer></div>

        <div id="fixed-buttons"><a href="#" id="back-to-top" class="fixed-button" title="Back to Top">
                <i class="fas fa-arrow-up fa-fw" aria-hidden="true"></i>
            </a><a href="#" id="view-comments" class="fixed-button" title="View Comments">
                <i class="fas fa-comment fa-fw" aria-hidden="true"></i>
            </a>
        </div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.css"><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/autocomplete.js@0.38.1/dist/autocomplete.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/algoliasearch@4.13.1/dist/algoliasearch-lite.umd.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lazysizes@5.3.2/lazysizes.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/clipboard@2.0.11/dist/clipboard.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/sharer.js@0.5.1/sharer.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/typeit@8.6.0/dist/index.umd.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/contrib/auto-render.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/contrib/copy-tex.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/contrib/mhchem.min.js"></script><script type="text/javascript">window.config={"code":{"copyTitle":"Copy to clipboard","maxShownLines":50},"comment":{},"data":{"id-1":"蓝Q曦的博客网站","id-2":"蓝Q曦的博客网站"},"math":{"delimiters":[{"display":true,"left":"$$","right":"$$"},{"display":true,"left":"\\[","right":"\\]"},{"display":true,"left":"\\begin{equation}","right":"\\end{equation}"},{"display":true,"left":"\\begin{equation*}","right":"\\end{equation*}"},{"display":true,"left":"\\begin{align}","right":"\\end{align}"},{"display":true,"left":"\\begin{align*}","right":"\\end{align*}"},{"display":true,"left":"\\begin{alignat}","right":"\\end{alignat}"},{"display":true,"left":"\\begin{alignat*}","right":"\\end{alignat*}"},{"display":true,"left":"\\begin{gather}","right":"\\end{gather}"},{"display":true,"left":"\\begin{CD}","right":"\\end{CD}"},{"display":false,"left":"$","right":"$"},{"display":false,"left":"\\(","right":"\\)"}],"strict":false},"search":{"algoliaAppID":"PELT26WIQD","algoliaIndex":"adan-ning.github.io","algoliaSearchKey":"f50812c72d6125140673e7245bea68cd","highlightTag":"em","maxResultLength":10,"noResultsFound":"No results found","snippetLength":50,"type":"algolia"},"typeit":{"cursorChar":"|","cursorSpeed":1000,"data":{"id-1":["id-1"],"id-2":["id-2"]},"duration":-1,"speed":100}};</script><script type="text/javascript" src="/js/theme.min.js"></script></body>
</html>
