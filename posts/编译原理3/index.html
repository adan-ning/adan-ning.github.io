<!DOCTYPE html>
<html lang="zh-CN">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="robots" content="noodp" />
        <title>编译引论(第三章) - 蓝Q曦的博客网站</title><meta name="Description" content="这是我的全新 Hugo 网站"><meta property="og:title" content="编译引论(第三章)" />
<meta property="og:description" content="词法分析 词法分析程序的功能 词法分析程序的主要任务是按语言的词法规则从源程序中逐个识别单词，把字符串形式的源程序转换为单词串的形式，并把每个单" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://adan-ning.github.io/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%863/" /><meta property="og:image" content="https://adan-ning.github.io/logo.png" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-03-19T00:00:00+00:00" />
<meta property="article:modified_time" content="2024-03-19T00:00:00+00:00" /><meta property="og:site_name" content="我的网站" />

<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:image" content="https://adan-ning.github.io/logo.png" /><meta name="twitter:title" content="编译引论(第三章)"/>
<meta name="twitter:description" content="词法分析 词法分析程序的功能 词法分析程序的主要任务是按语言的词法规则从源程序中逐个识别单词，把字符串形式的源程序转换为单词串的形式，并把每个单"/>
<meta name="application-name" content="我的网站">
<meta name="apple-mobile-web-app-title" content="我的网站"><meta name="theme-color" content="#ffffff"><meta name="msapplication-TileColor" content="#da532c"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" />
        <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
        <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5"><link rel="manifest" href="/site.webmanifest"><link rel="canonical" href="https://adan-ning.github.io/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%863/" /><link rel="prev" href="https://adan-ning.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%862/" /><link rel="next" href="https://adan-ning.github.io/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A13/" /><link rel="stylesheet" href="/css/style.min.css"><link rel="preload" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
        <noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css"></noscript><link rel="preload" href="https://cdn.jsdelivr.net/npm/animate.css@4.1.1/animate.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
        <noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@4.1.1/animate.min.css"></noscript><script type="application/ld+json">
    {
        "@context": "http://schema.org",
        "@type": "BlogPosting",
        "headline": "编译引论(第三章)",
        "inLanguage": "zh-CN",
        "mainEntityOfPage": {
            "@type": "WebPage",
            "@id": "https:\/\/adan-ning.github.io\/posts\/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%863\/"
        },"genre": "posts","keywords": "编译原理","wordcount":  5934 ,
        "url": "https:\/\/adan-ning.github.io\/posts\/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%863\/","datePublished": "2024-03-19T00:00:00+00:00","dateModified": "2024-03-19T00:00:00+00:00","publisher": {
            "@type": "Organization",
            "name": ""},"author": {
                "@type": "Person",
                "name": "蓝Q曦"
            },"description": ""
    }
    </script></head>
    <body data-header-desktop="fixed" data-header-mobile="auto"><script type="text/javascript">(window.localStorage && localStorage.getItem('theme') ? localStorage.getItem('theme') === 'dark' : ('auto' === 'auto' ? window.matchMedia('(prefers-color-scheme: dark)').matches : 'auto' === 'dark')) && document.body.setAttribute('theme', 'dark');</script>

        <div id="mask"></div><div class="wrapper"><header class="desktop" id="header-desktop">
    <div class="header-wrapper">
        <div class="header-title">
            <a href="/" title="蓝Q曦的博客网站"><span id="id-1" class="typeit"></span></a>
        </div>
        <div class="menu">
            <div class="menu-inner"><a class="menu-item" href="/posts/"> 文章 </a><a class="menu-item" href="/tags/"> 标签 </a><a class="menu-item" href="/categories/"> 分类 </a><span class="menu-item delimiter"></span><span class="menu-item search" id="search-desktop">
                        <input type="text" placeholder="Search titles or contents..." id="search-input-desktop">
                        <a href="javascript:void(0);" class="search-button search-toggle" id="search-toggle-desktop" title="Search">
                            <i class="fas fa-search fa-fw" aria-hidden="true"></i>
                        </a>
                        <a href="javascript:void(0);" class="search-button search-clear" id="search-clear-desktop" title="Clear">
                            <i class="fas fa-times-circle fa-fw" aria-hidden="true"></i>
                        </a>
                        <span class="search-button search-loading" id="search-loading-desktop">
                            <i class="fas fa-spinner fa-fw fa-spin" aria-hidden="true"></i>
                        </span>
                    </span><a href="javascript:void(0);" class="menu-item theme-switch" title="Switch Theme">
                    <i class="fas fa-adjust fa-fw" aria-hidden="true"></i>
                </a></div>

        </div>
    </div>
</header><header class="mobile" id="header-mobile">
    <div class="header-container">
        <div class="header-wrapper">
            <div class="header-title">
                <a href="/" title="蓝Q曦的博客网站"><span id="id-2" class="typeit"></span></a>
            </div>
            <div class="menu-toggle" id="menu-toggle-mobile">
                <span></span><span></span><span></span>
            </div>
        </div>
        <div class="menu" id="menu-mobile"><div class="search-wrapper">
                    <div class="search mobile" id="search-mobile">
                        <input type="text" placeholder="Search titles or contents..." id="search-input-mobile">
                        <a href="javascript:void(0);" class="search-button search-toggle" id="search-toggle-mobile" title="Search">
                            <i class="fas fa-search fa-fw" aria-hidden="true"></i>
                        </a>
                        <a href="javascript:void(0);" class="search-button search-clear" id="search-clear-mobile" title="Clear">
                            <i class="fas fa-times-circle fa-fw" aria-hidden="true"></i>
                        </a>
                        <span class="search-button search-loading" id="search-loading-mobile">
                            <i class="fas fa-spinner fa-fw fa-spin" aria-hidden="true"></i>
                        </span>
                    </div>
                    <a href="javascript:void(0);" class="search-cancel" id="search-cancel-mobile">
                        Cancel
                    </a>
                </div><a class="menu-item" href="/posts/" title="">文章</a><a class="menu-item" href="/tags/" title="">标签</a><a class="menu-item" href="/categories/" title="">分类</a><a href="javascript:void(0);" class="menu-item theme-switch" title="Switch Theme">
                <i class="fas fa-adjust fa-fw" aria-hidden="true"></i>
            </a></div>
    </div>
</header><div class="search-dropdown desktop">
        <div id="search-dropdown-desktop"></div>
    </div>
    <div class="search-dropdown mobile">
        <div id="search-dropdown-mobile"></div>
    </div><main class="main">
                <div class="container"><div class="toc" id="toc-auto">
            <h2 class="toc-title">Contents</h2>
            <div class="toc-content" id="toc-content-auto"></div>
        </div><article class="page single"><h1 class="single-title animate__animated animate__flipInX">编译引论(第三章)</h1><div class="post-meta">
            <div class="post-meta-line"><span class="post-author"><a href="/" title="Author" rel="author" class="author"><i class="fas fa-user-circle fa-fw" aria-hidden="true"></i>蓝Q曦</a></span>&nbsp;<span class="post-category">included in <a href="/categories/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"><i class="far fa-folder fa-fw" aria-hidden="true"></i>编译原理</a></span></div>
            <div class="post-meta-line"><i class="far fa-calendar-alt fa-fw" aria-hidden="true"></i>&nbsp;<time datetime="2024-03-19">2024-03-19</time>&nbsp;<i class="fas fa-pencil-alt fa-fw" aria-hidden="true"></i>&nbsp;5934 words&nbsp;
                <i class="far fa-clock fa-fw" aria-hidden="true"></i>&nbsp;12 minutes&nbsp;</div>
        </div><div class="details toc" id="toc-static"  data-kept="true">
                <div class="details-summary toc-title">
                    <span>Contents</span>
                    <span><i class="details-icon fas fa-angle-right" aria-hidden="true"></i></span>
                </div>
                <div class="details-content toc-content" id="toc-content-static"><nav id="TableOfContents">
  <ul>
    <li><a href="#词法分析程序的功能">词法分析程序的功能</a></li>
    <li><a href="#单词的种类及词法分析的输出">单词的种类及词法分析的输出</a></li>
    <li><a href="#词法分析的手工设计">词法分析的手工设计</a>
      <ul>
        <li><a href="#新程序的输入">新程序的输入</a></li>
        <li><a href="#单词的识别和超前搜索">单词的识别和超前搜索</a></li>
        <li><a href="#状态转换图">状态转换图</a></li>
        <li><a href="#词法分析的手工构造">词法分析的手工构造</a></li>
      </ul>
    </li>
    <li><a href="#正规式与正规集">正规式与正规集</a></li>
    <li><a href="#有限自动机">有限自动机</a>
      <ul>
        <li><a href="#确定有限自动机">确定有限自动机</a></li>
        <li><a href="#非确定有限自动机">非确定有限自动机</a></li>
      </ul>
    </li>
    <li><a href="#词法分析器的自动生成">词法分析器的自动生成</a>
      <ul>
        <li><a href="#lex正则约定">LEX正则约定</a></li>
        <li><a href="#lex的元字符约定">LEX的元字符约定</a></li>
        <li><a href="#lex源程序的结构lex输入文件的格式">lex源程序的结构(lex输入文件的格式)</a></li>
      </ul>
    </li>
  </ul>
</nav></div>
            </div><div class="content" id="content"><h1 id="词法分析">词法分析</h1>
<h2 id="词法分析程序的功能">词法分析程序的功能</h2>
<p>词法分析程序的主要任务是按语言的词法规则从源程序中逐个识别单词，把字符串形式的源程序转换为单词串的形式，并把每个单词转换成他们的内部表示，即所谓的“TOKEN”，同时进行词法检测</p>
<p>词法分析和语法分析之间的关系通常由两种形式</p>
<ol>
<li>词法分析程序既可作为编译器的独立一遍来完成</li>
<li>也可作为词法分析的一个子程序</li>
</ol>
<h2 id="单词的种类及词法分析的输出">单词的种类及词法分析的输出</h2>
<p>单词符号是一个程序语言的最小语法单位，一般分为5类：</p>
<ol>
<li>保留字。保留字是由程序语言定义的具有固定意义的标识符。有时称这些标识符为关键字或基本字。例如，Pascal中的begin,end,if,while都是保留字。这些字通常不用作一般标识符</li>
<li>标识符。用来表示各种名字，如变量名，数组名，过程名等</li>
<li>常数。常数的类型一般有整型，实型，布尔型，文字性等。例如，100，3.14159，TRUE，‘Sample’</li>
<li>运算符。如+，-，*，/等</li>
<li>界符。如逗号，分号，括号，/*，*/等</li>
</ol>
<p>词法分析器所输出的单词符号通常表示成二元式：(单词类别，单词符号的属性值)</p>
<p>单词类别通常用整数编码。标识符一般统归为一类。常数则宜按类型(整，实，布尔等)分类。关键字可将全体视为一类，也可以一字一类。采用一字一类的分法实际处理起来较为方便。运算符可采用一类的分法，但也可以把具有一定共性的运算符视为一类。至于界符一般用一类的分法</p>
<p>单词符号的属性是指单词符号的特性或特征。属性值则是反应特性或特征的值。例如，对于某个标识符，常将存放它的有关信息的符号表项的指针作为其属性值；对于某个常数，则将存放它的常数表项的指针作为其属性值</p>
<h2 id="词法分析的手工设计">词法分析的手工设计</h2>
<h3 id="新程序的输入">新程序的输入</h3>
<ol>
<li>利用词法分析器生成器：此时生成器将提供用于源程序字符流的读入和缓冲的若干子程序</li>
<li>利用传统的系统程序设计语言来编写词法分析器：此时要利用该语言所具有的输入/输出能力来处理读入操作</li>
</ol>
<p>不论扫描缓冲区设得多大都不能保证单词符号不会被它的边界所打断。因此，扫描缓冲区最好是用一个如图所示得一分为二的缓冲区域</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://cdn.jsdelivr.net/gh/adan-ning/images/202403201651569.jpg"
        data-srcset="https://cdn.jsdelivr.net/gh/adan-ning/images/202403201651569.jpg, https://cdn.jsdelivr.net/gh/adan-ning/images/202403201651569.jpg 1.5x, https://cdn.jsdelivr.net/gh/adan-ning/images/202403201651569.jpg 2x"
        data-sizes="auto"
        alt="https://cdn.jsdelivr.net/gh/adan-ning/images/202403201651569.jpg"
        title="https://cdn.jsdelivr.net/gh/adan-ning/images/202403201651569.jpg" /></p>
<h3 id="单词的识别和超前搜索">单词的识别和超前搜索</h3>
<p>有些语言(如FORTRAN)对于保留字不加保护，用户可以用它们作为普通标识符，这就使得保留字的识别相当困难。请看下面两条正确的FORTRAN语言语句：</p>
<ol>
<li>DO99K=1,10</li>
<li>DO99K=1.10</li>
</ol>
<p>若下一个界符是逗号，则可以肯定DO是保留字，否则，DO不构成保留字，它只是用户标识符的头两个字母，因此，为了区别语句1，2，必须超前扫描到等号后的第一个界符处。</p>
<ol>
<li>
<p>标识符的识别</p>
<p>大多数语言的标识符是字母开头的字母和数字组成的串，而且在程序中标识符出现后都跟着算符和界符，因此标识符的识别比较简单</p>
</li>
<li>
<p>常数的识别</p>
<p>大多数语言算数常数的表示大体相似，对于它们的识别比较直接。但对于某些语言的常数的识别也需要用超前搜索的方法。例如，对于FORTRAN语言的语句：</p>
<p>IF(5.EQ.M)I=10</p>
<p>其中，5.EQ.M只有当超前扫描到字母Q时才能断定5的词性。因为5.EO8和5.EQ.M的前三个字符完全一样</p>
</li>
<li>
<p>算符和界符的识别</p>
<p>词法分析器将那些有多个字符复合成的算符和界符(如C语言中的++)拼合成一个单词符号。因为这些字符串是不可分的整体，若分化开来，便失去了原来的意义。在这里同样需要超前搜索</p>
</li>
</ol>
<h3 id="状态转换图">状态转换图</h3>
<p>所谓状态转换图，就是一张有穷的有向图。在状态转换图中，结点代表状态，用圆圈表示。状态之间用箭弧连接。箭弧上的标记(字符)代表在射出结点状态下可能出现的合法的输入字符。如图a;</p>
<p>一个状态转换图可用于识别(或接受)一定的字符串，如图b;</p>
<p>如果在状态i时输入字符不为“字母”，则意味着识别不出标识符，或者说这个转换图工作不成功。有如，识别整数的状态转换图如图c所示，其中，i为初态，k为终态。大多数程序语言的单词符号都可以用状态转换图予以识别</p>
<p>注：终态结上打个星号“*”意味着多读进一个不属于标识符部分的字符，应把它退还给输入串</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://cdn.jsdelivr.net/gh/adan-ning/images/202403201717041.jpg"
        data-srcset="https://cdn.jsdelivr.net/gh/adan-ning/images/202403201717041.jpg, https://cdn.jsdelivr.net/gh/adan-ning/images/202403201717041.jpg 1.5x, https://cdn.jsdelivr.net/gh/adan-ning/images/202403201717041.jpg 2x"
        data-sizes="auto"
        alt="https://cdn.jsdelivr.net/gh/adan-ning/images/202403201717041.jpg"
        title="https://cdn.jsdelivr.net/gh/adan-ning/images/202403201717041.jpg" /></p>
<h3 id="词法分析的手工构造">词法分析的手工构造</h3>
<h4 id="简单语言的单词符号">简单语言的单词符号</h4>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://cdn.jsdelivr.net/gh/adan-ning/images/202403201728746.jpg"
        data-srcset="https://cdn.jsdelivr.net/gh/adan-ning/images/202403201728746.jpg, https://cdn.jsdelivr.net/gh/adan-ning/images/202403201728746.jpg 1.5x, https://cdn.jsdelivr.net/gh/adan-ning/images/202403201728746.jpg 2x"
        data-sizes="auto"
        alt="https://cdn.jsdelivr.net/gh/adan-ning/images/202403201728746.jpg"
        title="https://cdn.jsdelivr.net/gh/adan-ning/images/202403201728746.jpg" /></p>
<h4 id="状态转换图-1">状态转换图</h4>
<p>单词可分为单字符单词和多字符单词。对于单字符的识别比较简单，见字符即知，如=，+，*等，无须多读，无须退回。对于多字符单词的识别比较麻烦，存在多读，退回处理。一个程序设计语言的单词识别，可以用若干张状态转换图予以描述，也可以用一张状态图转换图来描述。</p>
<p>为了把这个例子阐述得更简单，有几点重要限制：</p>
<ol>
<li>所有保留字(如IF,WHILE等)都是“保留字”，用户不得使用它们作为自己定义的标识符，这样就避免了识别保留字时使用超前搜索技术。例如，DO(2)=x这种写法是绝对禁止的</li>
<li>把保留字作为一类特殊标识符来处理，对保留字不专门设计对应的状态图。把保留字及其类别编码预先安排在一张表格中(即保留字表)。当状态转换图识别出一个标识符时，就去查保留字表，确定是它是否为保留字。</li>
<li>如果保留字，标识符和常数之间没有运算符或界符作间隔时，则必须至少用一个空白符作间隔</li>
</ol>
<p>在上述限制条件下，多数单词符号的识别就不必使用超前搜索技术。在此，可通过一张状态转换图来识别上图的单词符号，如图所示：</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://cdn.jsdelivr.net/gh/adan-ning/images/202403201745514.jpg"
        data-srcset="https://cdn.jsdelivr.net/gh/adan-ning/images/202403201745514.jpg, https://cdn.jsdelivr.net/gh/adan-ning/images/202403201745514.jpg 1.5x, https://cdn.jsdelivr.net/gh/adan-ning/images/202403201745514.jpg 2x"
        data-sizes="auto"
        alt="https://cdn.jsdelivr.net/gh/adan-ning/images/202403201745514.jpg"
        title="https://cdn.jsdelivr.net/gh/adan-ning/images/202403201745514.jpg" /></p>
<h4 id="状态转换图的程序实现">状态转换图的程序实现</h4>
<p>用程序实现状态转换图的办法是让每个状态结点对应一段程序</p>
<ol>
<li>
<p>设计一组全局变量，过程和函数</p>
<ol>
<li>ch：字符变量，存放最新读入的源程序字符</li>
<li>strtoken：字符数组，存放构成单词符号的字符串</li>
<li>Get_char：过程，将下一输出字符读到ch中，搜索指示器前一字符位置</li>
<li>Get_BC：过程，检查ch中的字符是否是空白符，若是，则调用Get_char直到ch中进入一个非空白字符</li>
<li>Concat：过程，将ch中的字符连接到字符数组strtoken之后。如调用Concat之前，strtoken中存放的是“VA”，而ch中存放着“R”，则调用Concat后，strtoken的值就变为“VAR”</li>
<li>Retract：过程，将搜索指示器回调一个字符位置，将ch置为空白字符</li>
<li>Letter和Digit：布尔函数，分别用于判断ch中的字符是否为字母和数字</li>
<li>Reserve：整型函数，对字符数组strtoken中的字符串查找保留字表，若它是一个保留字则返回它的编码，否则返回0值(假定0不是保留字的编码)</li>
<li>Insert_Id：整型函数，将字符数组strtoken中的标识符插入符号表，返回符号表指针</li>
<li>Insert_Const：整型函数，将字符数组strtoken中的常数插入常数表，返回常数表指针</li>
<li>Error：出错处理</li>
</ol>
</li>
<li>
<p>状态转换图的具体实现</p>
<p>一般来说，构造识别状态转换图的程序，可让每个状态节点对应一段程序。具体实现时，可分为不含回路的分叉状态节点和含回路的状态节点来讨论。</p>
<ol>
<li>
<p>对于不含回路的分叉状态结点，可让它对应一个switch语句或一组if&hellip;then&hellip;else语句</p>
<p>例如，如图所示的不含回路的分叉状态结点的转换图，其状态节点0所对应的程序段可表示为</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://cdn.jsdelivr.net/gh/adan-ning/images/202403202121528.jpg"
        data-srcset="https://cdn.jsdelivr.net/gh/adan-ning/images/202403202121528.jpg, https://cdn.jsdelivr.net/gh/adan-ning/images/202403202121528.jpg 1.5x, https://cdn.jsdelivr.net/gh/adan-ning/images/202403202121528.jpg 2x"
        data-sizes="auto"
        alt="https://cdn.jsdelivr.net/gh/adan-ning/images/202403202121528.jpg"
        title="https://cdn.jsdelivr.net/gh/adan-ning/images/202403202121528.jpg" /></p>
<pre tabindex="0"><code>Get_char();
If(Letter());	{...状态1的对应程序段...;}
	else if(Digit())	{...状态2的对应程序段...;}
	else if(ch=&#39;_&#39;)		{...状态3的对应程序段...;}
else	{...错误处理}
</code></pre></li>
</ol>
<p>当程序执行达到&quot;错误处理&quot;时,意味着现行状态0和当前所面临的输入串不匹配.</p>
<ol start="2">
<li>
<p>对于含有回路的状态结点，可让它对应一个有while语句的if语句构成的程序段。例如，如图所示的按回路的状态节点的转换图，其状态节点0所对应的程序段可为</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://cdn.jsdelivr.net/gh/adan-ning/images/202403202125889.jpg"
        data-srcset="https://cdn.jsdelivr.net/gh/adan-ning/images/202403202125889.jpg, https://cdn.jsdelivr.net/gh/adan-ning/images/202403202125889.jpg 1.5x, https://cdn.jsdelivr.net/gh/adan-ning/images/202403202125889.jpg 2x"
        data-sizes="auto"
        alt="https://cdn.jsdelivr.net/gh/adan-ning/images/202403202125889.jpg"
        title="https://cdn.jsdelivr.net/gh/adan-ning/images/202403202125889.jpg" /></p>
<pre tabindex="0"><code>Get_char();
While(Letter() or Digit())
Get_char();
...状态1的对应程序段...
</code></pre><p>对于<a href="https://cdn.jsdelivr.net/gh/adan-ning/images/202403201745514.jpg" target="_blank" rel="noopener noreffer ">上图</a>  中的状态c,由于它既是标识符的出口又是保留字的出口，因此，需要对strtoue查询保留字表。这项工作由整型函数过程Reserve来完成。若此过程工作结果所得的值为0，则表示strtoken中的字符串是一个标识符(假定0不是保留字的编码)；否则，表示保留字编码。</p>
<p>综上，<a href="https://cdn.jsdelivr.net/gh/adan-ning/images/202403201745514.jpg" target="_blank" rel="noopener noreffer ">如图</a>  所示的状态转换图所对应的词法分析器的主题程序如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">code</span><span class="p">,</span><span class="n">value</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nl">strtoken</span><span class="p">:</span><span class="o">=</span><span class="s">&#34; &#34;</span><span class="p">;</span> <span class="cm">/*将strtoken初始化为空串*/</span>
</span></span><span class="line"><span class="cl"><span class="nf">Get_char</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="nf">Get_BC</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="k">if</span><span class="p">(</span><span class="nf">Letter</span><span class="p">())</span>
</span></span><span class="line"><span class="cl"><span class="n">begin</span>
</span></span><span class="line"><span class="cl">	<span class="k">while</span><span class="p">(</span><span class="nf">Letter</span><span class="p">()</span> <span class="n">or</span> <span class="nf">Digit</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">	<span class="n">begin</span>
</span></span><span class="line"><span class="cl">		<span class="nf">Concat</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">		<span class="nf">Get_char</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">	<span class="n">end</span>
</span></span><span class="line"><span class="cl">	<span class="nf">Retract</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">	<span class="nl">code</span><span class="p">:</span><span class="o">=</span><span class="nf">Reserve</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span><span class="p">(</span><span class="n">code</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="n">begin</span>
</span></span><span class="line"><span class="cl">		<span class="nl">vaue</span><span class="p">:</span><span class="o">=</span><span class="nf">Insert_Id</span><span class="p">(</span><span class="n">strtoken</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span><span class="p">(</span><span class="err">$</span><span class="n">ID</span><span class="p">,</span><span class="n">value</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="n">end</span>
</span></span><span class="line"><span class="cl">	<span class="k">else</span>
</span></span><span class="line"><span class="cl">		<span class="nf">return</span><span class="p">(</span><span class="n">code</span><span class="p">,</span><span class="o">-</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="n">end</span>
</span></span><span class="line"><span class="cl">	<span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="nf">Digit</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">	<span class="n">begin</span>
</span></span><span class="line"><span class="cl">		<span class="k">while</span><span class="p">(</span><span class="nf">Digit</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">		<span class="n">begin</span>
</span></span><span class="line"><span class="cl">			<span class="nf">Concat</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">			<span class="nf">Get_char</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">		<span class="n">end</span>
</span></span><span class="line"><span class="cl">		<span class="nf">Retract</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">		<span class="nl">value</span><span class="p">:</span><span class="o">=</span><span class="nf">Insert_Const</span><span class="p">(</span><span class="n">strtoken</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span><span class="p">(</span><span class="err">$</span><span class="n">INT</span><span class="p">,</span><span class="n">value</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="n">end</span>
</span></span><span class="line"><span class="cl">	<span class="k">else</span> <span class="nf">if</span><span class="p">(</span><span class="n">ch</span><span class="o">=</span><span class="sc">&#39;=&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span><span class="p">(</span><span class="err">$</span><span class="n">ASSIGN</span><span class="p">,</span><span class="o">-</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="k">else</span> <span class="nf">if</span><span class="p">(</span><span class="n">ch</span><span class="o">=</span><span class="sc">&#39;+&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span><span class="p">(</span><span class="err">$</span><span class="n">PLUS</span><span class="p">,</span><span class="o">-</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="k">else</span> <span class="nf">if</span><span class="p">(</span><span class="n">ch</span><span class="o">=</span><span class="sc">&#39;*&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="n">begin</span>
</span></span><span class="line"><span class="cl">		<span class="nf">Get_char</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span><span class="p">(</span><span class="n">ch</span><span class="o">=</span><span class="sc">&#39;*&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="k">return</span><span class="p">(</span><span class="err">$</span><span class="n">POWER</span><span class="p">,</span><span class="o">-</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">		<span class="nf">Retract</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span><span class="p">(</span><span class="err">$</span><span class="n">STAR</span><span class="p">,</span><span class="o">-</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="n">end</span>
</span></span><span class="line"><span class="cl">	<span class="k">else</span> <span class="nf">if</span><span class="p">(</span><span class="n">ch</span><span class="o">=</span><span class="sc">&#39;,&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span><span class="p">(</span><span class="err">$</span><span class="n">COMMA</span><span class="p">,</span><span class="o">-</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="k">else</span> <span class="nf">if</span><span class="p">(</span><span class="n">ch</span><span class="o">=</span><span class="sc">&#39;(&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span><span class="p">(</span><span class="err">$</span><span class="n">LPAR</span><span class="p">,</span><span class="o">-</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="k">else</span> <span class="nf">if</span><span class="p">(</span><span class="n">ch</span><span class="o">=</span><span class="err">&#39;</span><span class="p">)</span><span class="err">&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span><span class="p">(</span><span class="err">$</span><span class="n">RPAR</span><span class="p">,</span><span class="o">-</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="k">else</span>
</span></span><span class="line"><span class="cl">		<span class="nf">Error</span><span class="p">();</span>	<span class="cm">/*错误处理*/</span>
</span></span></code></pre></div></li>
</ol>
</li>
</ol>
<h2 id="正规式与正规集">正规式与正规集</h2>
<p>设字母表为$\sum$，辅助字母表$*\sum = {\varepsilon,\phi,|,\cdot , * ,( , )}$，下面是正则表达式和它所表示的正规集的递归定义：</p>
<ol>
<li>
<p>$\varepsilon$和$\phi$都是$\sum$上的正规式，它们所表示的正规集分别为{$\varepsilon$}和$\phi$ ;</p>
</li>
<li>
<p>任何$a \in \sum$,a是$\sum$ 上的一个正规式，它所表示的正规集为{a};</p>
</li>
<li>
<p>假定U和V都是$\sum$上的正规式，它们所表示的正规集分别记为L(U)和L(V),则：</p>
<p>U|V是正规式，它所表示的正规集为L(U)$\cup$L(V)；</p>
<p>U$\cdot$V是正规式，它所表示的正规集L(U)L(V)(即连接积)。</p>
<p>$U^<em>$是正规式，它所表示的正规集为$(L(U))^</em>$</p>
</li>
</ol>
<p>仅有有限次使用上述3步骤而得到的表达式才是$\sum$上的正规式。仅有这些正规式所表示的字符集才是$\sum$上的正规集</p>
<h2 id="有限自动机">有限自动机</h2>
<h3 id="确定有限自动机">确定有限自动机</h3>
<p>一个确定有限自动机(DFA)M是一个五元式：$M=(S, \sum ,f,s_0,Z)$</p>
<ol>
<li>S是一个有限集，它的每个元素称为一个状态</li>
<li>$\sum$是一个有穷字母表，它的每个元素称为一个输入字符</li>
<li>f是转换函数，是一个从$S \times \sum$至S的单值映射，f($S_1$,x)=$S_2$意指：当现行状态为$S_1$,面临的输入符号为x时,将转到下一状态$S_2,S_2$称为$S_1$的一个后继状态；</li>
<li>$S_0 \in S$,它是唯一的一个初态；</li>
<li>$Z \subseteq S$称为终止状态集（可空）。</li>
</ol>
<p>一个DFA的转换函数可用一个状态转换矩阵或状态转换表来表示，该矩阵的行表示状态$S_i（S_i∈S）$,列表示输入字符$a_j（a_j∈∑）$,矩阵中的元素则是转换函数$ f (S_i , a_j)$的值。</p>
<p>例：已知DFA  M=（{A,B,C,D},{x, y}, f ,A,{D}）其中f为：</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://cdn.jsdelivr.net/gh/adan-ning/images/202403261844089.png"
        data-srcset="https://cdn.jsdelivr.net/gh/adan-ning/images/202403261844089.png, https://cdn.jsdelivr.net/gh/adan-ning/images/202403261844089.png 1.5x, https://cdn.jsdelivr.net/gh/adan-ning/images/202403261844089.png 2x"
        data-sizes="auto"
        alt="https://cdn.jsdelivr.net/gh/adan-ning/images/202403261844089.png"
        title="https://cdn.jsdelivr.net/gh/adan-ning/images/202403261844089.png" /></p>
<p><strong>确定有限自动机识别的符号串</strong></p>
<p>对于Σ上的任意符号串$W ∈Σ^＊$，若存在一条从初态结点到终态结点的路径，该路径上每条箭弧的标记连接成的符号串恰好是W，则称W为DFA  $M_D$所识别。</p>
<p>DFA $M_D$所能识别的符号串的全体记为$L(M_D)$,称为$M_D$所识别的语言。</p>
<p>例：已知自动机的状态转换图如下：</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://cdn.jsdelivr.net/gh/adan-ning/images/202403261848738.png"
        data-srcset="https://cdn.jsdelivr.net/gh/adan-ning/images/202403261848738.png, https://cdn.jsdelivr.net/gh/adan-ning/images/202403261848738.png 1.5x, https://cdn.jsdelivr.net/gh/adan-ning/images/202403261848738.png 2x"
        data-sizes="auto"
        alt="https://cdn.jsdelivr.net/gh/adan-ning/images/202403261848738.png"
        title="https://cdn.jsdelivr.net/gh/adan-ning/images/202403261848738.png" /></p>
<p><strong>DFA的确定性</strong></p>
<p>DFA的确定性表现在转换函数f：S×∑→S是一个单值函数。也就是说，对任何状态Si∈S和输入符号a∈∑，f (Si ,a) 唯一地确定了下一状态。从状态转换图的角度来看，假定字母表∑含有n个输入字符，那么，任何一个状态结点最多只有n条弧射出，而且每条箭弧以一个不同的输入字符来标记。如果f是一个多值函数，这就涉及到非确定有限自动机的概念。</p>
<h3 id="非确定有限自动机">非确定有限自动机</h3>
<p>一个非确定有限自动机(NFA)M是一个五元式：$M=(S, \sum ,f,S_0,Z)$</p>
<ol>
<li>S是一个有限集，它的每个元素称为一个状态。</li>
<li>∑是一个有穷字母表，它的每个元素称为一个输入字符。</li>
<li>f是转换函数，是一个从S×Σ* 到S的子集的映射，即f：S×Σ*→2s</li>
<li>$S_0 \subseteq S$，是一个非空初态集；</li>
<li>$Z \subseteq S$称为终止状态集（可空）。</li>
</ol>
<p><strong>和确定有限自动机一样，非确定有限自动机也可以用状态转换图和状态转换矩阵来表示。</strong></p>
<p>显然，一个含有m个状态和n个输入字符的NFA可表示成如下的状态转换图：该图含有m个状态结点，每个节点可射出若干条箭弧与别的结点相连接，每条弧用Σ*中的一个字（不一定要不同的字而且可以使空串ε）做标记，整张图至少含有一个初态结点以及若干个（可以是0个）终态结点。某些结点既可以是初态结点也可以是终态结点。</p>
<p>例：已知NFA M=$({0,1,2,3},{a,b}, f , S_0,{3})$其中f为：</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://cdn.jsdelivr.net/gh/adan-ning/images/202403261854632.png"
        data-srcset="https://cdn.jsdelivr.net/gh/adan-ning/images/202403261854632.png, https://cdn.jsdelivr.net/gh/adan-ning/images/202403261854632.png 1.5x, https://cdn.jsdelivr.net/gh/adan-ning/images/202403261854632.png 2x"
        data-sizes="auto"
        alt="https://cdn.jsdelivr.net/gh/adan-ning/images/202403261854632.png"
        title="https://cdn.jsdelivr.net/gh/adan-ning/images/202403261854632.png" /></p>
<p><strong>非确定有限自动机识别的语言</strong></p>
<p>对于Σ*中的α，若存在一条从某一初态结点到某一终态结点的通路，且这条通路上所有箭弧的标记字依序连接成的字（忽略那些标记为ε的弧）等于α，则称α可为NFA M所识别（即接受）。</p>
<p>NFA M所能识别的所有字的集合称为该自动机识别的语言，记为L(M)。</p>
<p>若M的某些结点既是初态结点又是终态结点，或者存在一条从某个初态结点到某个终态结点的ε通路，那么，空字ε可为M所接受</p>
<p>如图所示的就是一个NFA，该NFA能识别Σ上所有含有相继两个a或相继两个b的字</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://cdn.jsdelivr.net/gh/adan-ning/images/202403261856843.png"
        data-srcset="https://cdn.jsdelivr.net/gh/adan-ning/images/202403261856843.png, https://cdn.jsdelivr.net/gh/adan-ning/images/202403261856843.png 1.5x, https://cdn.jsdelivr.net/gh/adan-ning/images/202403261856843.png 2x"
        data-sizes="auto"
        alt="https://cdn.jsdelivr.net/gh/adan-ning/images/202403261856843.png"
        title="https://cdn.jsdelivr.net/gh/adan-ning/images/202403261856843.png" /></p>
<p><strong>DFA与NFA的关系</strong></p>
<p>DFA 是NFA的特例，凡是能被DFA接受的符号串必然能被NFA所接受。NFA与DFA的区别在于DFA只有唯一的一个初态， NFA有一个非空初态集（即可以有若干初态）；DFA的转换函数f是一个单值函数，NFA的转换函数f是一个多值函数。</p>
<h2 id="词法分析器的自动生成">词法分析器的自动生成</h2>
<p>Lex是一个基于正规式的描述构造词法分析器的工具，也称为Lex编译器，它已经广泛用于产生各种语言的词法分析器。它输入的是用Lex语言编写的源程序，输出的是词法分析的C语言程序。 Lex的流程如下图所示</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://cdn.jsdelivr.net/gh/adan-ning/images/202403261858670.png"
        data-srcset="https://cdn.jsdelivr.net/gh/adan-ning/images/202403261858670.png, https://cdn.jsdelivr.net/gh/adan-ning/images/202403261858670.png 1.5x, https://cdn.jsdelivr.net/gh/adan-ning/images/202403261858670.png 2x"
        data-sizes="auto"
        alt="https://cdn.jsdelivr.net/gh/adan-ning/images/202403261858670.png"
        title="https://cdn.jsdelivr.net/gh/adan-ning/images/202403261858670.png" /></p>
<h3 id="lex正则约定">LEX正则约定</h3>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://cdn.jsdelivr.net/gh/adan-ning/images/202403261859977.png"
        data-srcset="https://cdn.jsdelivr.net/gh/adan-ning/images/202403261859977.png, https://cdn.jsdelivr.net/gh/adan-ning/images/202403261859977.png 1.5x, https://cdn.jsdelivr.net/gh/adan-ning/images/202403261859977.png 2x"
        data-sizes="auto"
        alt="https://cdn.jsdelivr.net/gh/adan-ning/images/202403261859977.png"
        title="https://cdn.jsdelivr.net/gh/adan-ning/images/202403261859977.png" /></p>
<h3 id="lex的元字符约定">LEX的元字符约定</h3>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://cdn.jsdelivr.net/gh/adan-ning/images/202403261900388.png"
        data-srcset="https://cdn.jsdelivr.net/gh/adan-ning/images/202403261900388.png, https://cdn.jsdelivr.net/gh/adan-ning/images/202403261900388.png 1.5x, https://cdn.jsdelivr.net/gh/adan-ning/images/202403261900388.png 2x"
        data-sizes="auto"
        alt="https://cdn.jsdelivr.net/gh/adan-ning/images/202403261900388.png"
        title="https://cdn.jsdelivr.net/gh/adan-ning/images/202403261900388.png" /></p>
<h3 id="lex源程序的结构lex输入文件的格式">lex源程序的结构(lex输入文件的格式)</h3>
<pre tabindex="0"><code>说明部分(辅助定义部分)
% % 
识别规则部分 
% %
辅助程序部分(用户子程序部分) 
</code></pre><p>其中规则部分是必须的，定义和辅助程序部分是任选的。如果没有辅助程序部分，则第二个分隔号%%（双百分号）可以省去；但由于第一个%%用来指示规则部分的开始，故即使没有说明部分，也不能将其省去</p>
<p><strong>说明部分</strong></p>
<p>它是 C 和 Lex 的全局声明。它的作用，在于对规则部分要引用的文件和变量进行说明，通常可包含头文件，常数定义、全局变量定义、正则式定义等。每一个正则式定义由分隔符（适当个数的空格或制表符）连接的正则式的名字和正则式表达式组成,即: $D_i   R_i$</p>
<p>其中，$ D_i$表示正则式的名字，Ri表示正则表达式。除正则式定义以外，定义部分的其余代码须用符号%{和%}括起来，其间可以是包括include语句、声明语句在内的C语句。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="o">%</span><span class="p">{</span>        
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">wordCount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">noCount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl"><span class="o">%</span><span class="p">}</span>  
</span></span><span class="line"><span class="cl"><span class="n">chars</span> 		<span class="p">[</span><span class="n">A</span><span class="o">-</span><span class="n">za</span><span class="o">-</span><span class="n">z</span><span class="p">]</span>        
</span></span><span class="line"><span class="cl"><span class="nf">numbers</span>     	<span class="p">([</span><span class="mi">0</span><span class="o">-</span><span class="mi">9</span><span class="p">])</span><span class="o">+</span>        
</span></span><span class="line"><span class="cl"><span class="n">words</span>          	<span class="p">{</span><span class="n">chars</span><span class="p">}</span><span class="o">+</span> 
</span></span></code></pre></div><p><strong>注意</strong></p>
<p>凡是对已经定义的正则表达式的名字的引用，都必须用花括号将它们括起来。在LEX源程序中，起标识作用的符号%%，%{以及%}都必须处在所在行的最左字符位置。</p>
<p><strong>识别规则部分</strong></p>
<p>识别规则部分<strong>起始于“%%”符号，终止于“%%”符号，其间则是词法规则。词法规则由词形和动作两部分组成</strong>。即：
$ P_i$      {ACTION i}
<strong>$P_i$词形部分可以由任意的正则表达式组成,ACTION i动作部分是由C语言语句组成</strong>，这些语句用来对所匹配的词形进行相应处理。规则部分完全决定了词法分析程序的功能，它只能识别出词形中正则表达式所定义的单词。</p>
<p>例如:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl">	<span class="o">%%</span>
</span></span><span class="line"><span class="cl">	<span class="p">{</span><span class="n">words</span><span class="p">}</span>   <span class="p">{</span><span class="n">wordCount</span><span class="o">++</span><span class="p">;</span> <span class="cm">/*increase the word count */</span> <span class="p">}</span>                    
</span></span><span class="line"><span class="cl">	<span class="p">{</span><span class="n">numbers</span><span class="p">}</span> <span class="p">{</span><span class="n">noCount</span><span class="o">++</span><span class="p">;</span> <span class="cm">/*increase the number count */</span> <span class="p">}</span> 
</span></span><span class="line"><span class="cl">	<span class="err">\</span><span class="n">n</span>     	   <span class="p">{;}</span>
</span></span><span class="line"><span class="cl">	<span class="p">.</span>         <span class="p">{;}</span>
</span></span></code></pre></div><p><strong>辅助程序部分</strong></p>
<p>这部分包含了识别规则部分的动作代码段中所调用的各个局部函数，着写函数由用户用C语言编写的，这样就可以达到简化编程的目的。它们将由LEX系统直接拷贝到输出文件lex.yy.c中。</p>
<p>例如：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="o">%%</span>
</span></span><span class="line"><span class="cl"><span class="nf">main</span><span class="p">(</span>  <span class="p">)</span>         
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="nf">yylex</span><span class="p">();</span> <span class="cm">/* start the  analysis*/</span>         
</span></span><span class="line"><span class="cl"><span class="nf">printf</span><span class="p">(</span><span class="s">&#34; Count of words:%d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">wordCount</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="nf">printf</span><span class="p">(</span><span class="s">&#34; Count of nombers:%d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">noCount</span><span class="p">);</span>          
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p><strong>综合上述几个例子，我们可以编一个字(由字母组成的)和数字（由数字组成）的个数统计的词法分析器了。</strong></p>
<p>LEX输入源程序</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="o">%</span><span class="p">{</span>        
</span></span><span class="line"><span class="cl">	<span class="kt">int</span> <span class="n">wordCount</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">,</span><span class="n">noCount</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>    
</span></span><span class="line"><span class="cl"><span class="o">%</span><span class="p">}</span>  
</span></span><span class="line"><span class="cl">	<span class="n">chars</span> 		<span class="p">[</span><span class="n">A</span><span class="o">-</span><span class="n">za</span><span class="o">-</span><span class="n">z</span><span class="p">]</span>        
</span></span><span class="line"><span class="cl">	<span class="nf">numbers</span>     	<span class="p">([</span><span class="mi">0</span><span class="o">-</span><span class="mi">9</span><span class="p">])</span><span class="o">+</span>        
</span></span><span class="line"><span class="cl">	<span class="n">words</span>          	<span class="p">{</span><span class="n">chars</span><span class="p">}</span><span class="o">+</span>
</span></span><span class="line"><span class="cl">        
</span></span><span class="line"><span class="cl"><span class="o">%%</span>
</span></span><span class="line"><span class="cl">	<span class="p">{</span><span class="n">words</span><span class="p">}</span> 	<span class="p">{</span><span class="n">wordCount</span><span class="o">++</span><span class="p">;</span> <span class="cm">/*increase the word count */</span> <span class="p">}</span>                    
</span></span><span class="line"><span class="cl">	<span class="p">{</span><span class="n">numbers</span><span class="p">}</span> 	<span class="p">{</span><span class="n">noCount</span><span class="o">++</span><span class="p">;</span> <span class="cm">/*increase the number count */</span> <span class="p">}</span> 
</span></span><span class="line"><span class="cl">	<span class="err">\</span><span class="n">n</span>             	<span class="p">{;</span> <span class="cm">/*do  nothing */</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">.</span>              	<span class="p">{;</span> <span class="cm">/*do  nothing */</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="o">%%</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl"><span class="nf">main</span><span class="p">(</span>  <span class="p">)</span>         
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nf">yylex</span><span class="p">();</span> <span class="cm">/* start the  analysis*/</span>         
</span></span><span class="line"><span class="cl">	<span class="nf">printf</span><span class="p">(</span><span class="s">&#34; No of words:%d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">wordCount</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">	<span class="nf">printf</span><span class="p">(</span><span class="s">&#34; Count of nombers:%d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">noCount</span><span class="p">);</span>          
</span></span><span class="line"><span class="cl"><span class="p">}</span> 
</span></span></code></pre></div></div><div class="post-footer" id="post-footer">
    <div class="post-info">
        <div class="post-info-line">
            <div class="post-info-mod">
                <span>Updated on 2024-03-19</span>
            </div></div>
        <div class="post-info-line">
            <div class="post-info-md"></div>
            <div class="post-info-share">
                <span><a href="javascript:void(0);" title="Share on Twitter" data-sharer="twitter" data-url="https://adan-ning.github.io/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%863/" data-title="编译引论(第三章)" data-hashtags="编译原理"><i class="fab fa-twitter fa-fw" aria-hidden="true"></i></a><a href="javascript:void(0);" title="Share on Facebook" data-sharer="facebook" data-url="https://adan-ning.github.io/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%863/" data-hashtag="编译原理"><i class="fab fa-facebook-square fa-fw" aria-hidden="true"></i></a><a href="javascript:void(0);" title="Share on Hacker News" data-sharer="hackernews" data-url="https://adan-ning.github.io/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%863/" data-title="编译引论(第三章)"><i class="fab fa-hacker-news fa-fw" aria-hidden="true"></i></a><a href="javascript:void(0);" title="Share on Line" data-sharer="line" data-url="https://adan-ning.github.io/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%863/" data-title="编译引论(第三章)"><i data-svg-src="https://cdn.jsdelivr.net/npm/simple-icons@7.3.0/icons/line.svg" aria-hidden="true"></i></a><a href="javascript:void(0);" title="Share on 微博" data-sharer="weibo" data-url="https://adan-ning.github.io/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%863/" data-title="编译引论(第三章)"><i class="fab fa-weibo fa-fw" aria-hidden="true"></i></a></span>
            </div>
        </div>
    </div>

    <div class="post-info-more">
        <section class="post-tags"><i class="fas fa-tags fa-fw" aria-hidden="true"></i>&nbsp;<a href="/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/">编译原理</a></section>
        <section>
            <span><a href="javascript:void(0);" onclick="window.history.back();">Back</a></span>&nbsp;|&nbsp;<span><a href="/">Home</a></span>
        </section>
    </div>

    <div class="post-nav"><a href="/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%862/" class="prev" rel="prev" title="计算机组成(第二章)"><i class="fas fa-angle-left fa-fw" aria-hidden="true"></i>计算机组成(第二章)</a>
            <a href="/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A13/" class="next" rel="next" title="c&#43;&#43;(three)">c++(three)<i class="fas fa-angle-right fa-fw" aria-hidden="true"></i></a></div>
</div>
</article></div>
            </main><footer class="footer">
        <div class="footer-container"><div class="footer-line">Powered by <a href="https://gohugo.io/" target="_blank" rel="noopener noreffer" title="Hugo 0.122.0">Hugo</a> | Theme - <a href="https://github.com/dillonzq/LoveIt" target="_blank" rel="noopener noreffer" title="LoveIt 0.2.11"><i class="far fa-kiss-wink-heart fa-fw" aria-hidden="true"></i> LoveIt</a>
                </div><div class="footer-line" itemscope itemtype="http://schema.org/CreativeWork"><i class="far fa-copyright fa-fw" aria-hidden="true"></i><span itemprop="copyrightYear">2020 - 2024</span><span class="author" itemprop="copyrightHolder">&nbsp;<a href="/" target="_blank">蓝Q曦</a></span>&nbsp;|&nbsp;<span class="license"><a rel="license external nofollow noopener noreffer" href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank">CC BY-NC 4.0</a></span></div>
        </div>
    </footer></div>

        <div id="fixed-buttons"><a href="#" id="back-to-top" class="fixed-button" title="Back to Top">
                <i class="fas fa-arrow-up fa-fw" aria-hidden="true"></i>
            </a><a href="#" id="view-comments" class="fixed-button" title="View Comments">
                <i class="fas fa-comment fa-fw" aria-hidden="true"></i>
            </a>
        </div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.css"><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/autocomplete.js@0.38.1/dist/autocomplete.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/algoliasearch@4.13.1/dist/algoliasearch-lite.umd.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lazysizes@5.3.2/lazysizes.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/clipboard@2.0.11/dist/clipboard.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/sharer.js@0.5.1/sharer.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/typeit@8.6.0/dist/index.umd.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/contrib/auto-render.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/contrib/copy-tex.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/contrib/mhchem.min.js"></script><script type="text/javascript">window.config={"code":{"copyTitle":"Copy to clipboard","maxShownLines":50},"comment":{},"data":{"id-1":"蓝Q曦的博客网站","id-2":"蓝Q曦的博客网站"},"math":{"delimiters":[{"display":true,"left":"$$","right":"$$"},{"display":true,"left":"\\[","right":"\\]"},{"display":true,"left":"\\begin{equation}","right":"\\end{equation}"},{"display":true,"left":"\\begin{equation*}","right":"\\end{equation*}"},{"display":true,"left":"\\begin{align}","right":"\\end{align}"},{"display":true,"left":"\\begin{align*}","right":"\\end{align*}"},{"display":true,"left":"\\begin{alignat}","right":"\\end{alignat}"},{"display":true,"left":"\\begin{alignat*}","right":"\\end{alignat*}"},{"display":true,"left":"\\begin{gather}","right":"\\end{gather}"},{"display":true,"left":"\\begin{CD}","right":"\\end{CD}"},{"display":false,"left":"$","right":"$"},{"display":false,"left":"\\(","right":"\\)"}],"strict":false},"search":{"algoliaAppID":"PELT26WIQD","algoliaIndex":"adan-ning.github.io","algoliaSearchKey":"f50812c72d6125140673e7245bea68cd","highlightTag":"em","maxResultLength":10,"noResultsFound":"No results found","snippetLength":50,"type":"algolia"},"typeit":{"cursorChar":"|","cursorSpeed":1000,"data":{"id-1":["id-1"],"id-2":["id-2"]},"duration":-1,"speed":100}};</script><script type="text/javascript" src="/js/theme.min.js"></script></body>
</html>
