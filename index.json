[{"categories":["计算机算法设计与分析"],"content":"分支限界法 ","date":"2024-04-30","objectID":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A16/:0:0","tags":["计算机算法设计与分析"],"title":"算法与程序(第六章)","uri":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A16/"},{"categories":["计算机算法设计与分析"],"content":"分支限界法的基本思想 分支限界法与回溯法的不同 求解目标 回溯法求解目标是找出解空间树中满足约束条件所有解 分支限界法的求解目标则是找出满足约束条件的一个解（或一个最优解） 搜索方式的不同 回溯法以深度优先方式搜索解空间树 分支限界法则以广度优先或以最小耗费优先方式搜索解空间树 分支限界法基本思想 让根结点成为当前扩展结点 当前扩展结点一次性产生其所有儿子结点。 舍弃导致不可行解或非最优解的儿子结点，其余儿子结点加入活结点表 从活结点表中取下一结点成为当前扩展结点， 如果找到所需的解或活结点表为空，算法结束，否则重复步骤2,3,4。从活结点表中取下一个扩展结点：广度优先、最小耗费（最大效益）优先 广度优先和最小耗费优先的区别 常见的两种分支限界法 队列式(FIFO)分支限界法 按照队列先进先出（FIFO）原则选取下一个结点为扩展结点。 优先队列式分支限界法 按照优先队列中规定的优先级选取优先级最高的结点成为当前扩展结点。 ","date":"2024-04-30","objectID":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A16/:1:0","tags":["计算机算法设计与分析"],"title":"算法与程序(第六章)","uri":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A16/"},{"categories":["计算机算法设计与分析"],"content":"装载问题 有一批共个集装箱要装上2艘载重量分别为C1和C2的轮船，其中集装箱i的重量为Wi，且$\\stackrel{n}{\\sum\\limits_{i=1}} w_i \\leq c_i+c_2$ 采用下面的策略可得到最优装载方案。 将第一艘轮船尽可能装满； 将剩余集装箱装上第二艘轮船； 队列式分支限界法 检测当前扩展结点的左儿子结点，可行入队 将其右儿子结点加入队列(右儿子结点一定可行) 舍弃当前扩展结点。 每层结点之后都加一个尾部标记-1，将活结点分层 只考虑求最大载重量，不考虑构造最优解 ","date":"2024-04-30","objectID":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A16/:2:0","tags":["计算机算法设计与分析"],"title":"算法与程序(第六章)","uri":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A16/"},{"categories":["计算机算法设计与分析"],"content":"装载问题队列式分支限界法算法 Ew=0, Q.Add(-1) ;i=1; bestw=0； //Ew为当前结点对应的在船的集装箱重量 while (true) { // 检查左儿子结点 if (Ew + w[i] \u003c= c) // x[i] = 1 EnQueue(Q, Ew + w[i], bestw, i, n); // 右儿子结点总是可行的 EnQueue(Q, Ew, bestw, i, n); // x[i] = 0 Q.Delete(Ew); // 取下一扩展结点 if (Ew == -1) { // 同层结点尾部 if (Q.IsEmpty()) return bestw; Q.Add(-1); // 同层结点尾部标志 Q.Delete(Ew); // 取下一扩展结点 i++;} // 进入下一层 } void EnQueue(Queue\u003cType\u003e \u0026Q, Type wt, Type \u0026bestw, int i, int n) { if(i==n){ if(wt\u003ebestw)bestw=wt; }//叶子结点不入队列 else Q.add(wt); } 算法中右分支不剪枝，效率差如何改进? ","date":"2024-04-30","objectID":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A16/:2:1","tags":["计算机算法设计与分析"],"title":"算法与程序(第六章)","uri":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A16/"},{"categories":["计算机算法设计与分析"],"content":"算法的改进（右子树加入剪枝条件） 策略：当$Ew+r \\leq bestw$时，可将其右子树剪去。 bestw:当前最优解；Ew:当前扩展结点所相应重量； r:剩余集装箱的重量和 算法每一次进入左子树的时候更新bestw的值，确保右子树有效剪枝，不要等待i=n时才去更新。 // 检查左儿子结点 Type wt = Ew + w[i]; // 左儿子结点的重量 if (wt \u003c= c) { // 可行结点 if (wt \u003e bestw) bestw = wt; if (i \u003c n) Q.Add(wt); // 加入活结点队列 } // 检查右儿子结点 if (Ew + r \u003e bestw \u0026\u0026 i \u003c n) Q.Add(Ew); // 可能含最优解 入队列函数 EnQueue( ）就可以去掉了 ","date":"2024-04-30","objectID":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A16/:2:2","tags":["计算机算法设计与分析"],"title":"算法与程序(第六章)","uri":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A16/"},{"categories":["计算机算法设计与分析"],"content":"构造最优解 class QNode { QNode *parent; // 指向父结点的指针 bool LChild; // 左儿子标志 Type weight; // 结点所相应的载重量 } 记住最优值结点，根据parent可回溯到根节点，找到最优解 // 构造当前最优解 for (int j = n ; j \u003e =1; j--) { bestx[j] = bestE-\u003eLChild; bestE = bestE-\u003eparent; } 解空间树中L结点构造出最优值9 根据构造最优解的算法，最优解bestx[1..3]={0,1,1} ","date":"2024-04-30","objectID":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A16/:2:3","tags":["计算机算法设计与分析"],"title":"算法与程序(第六章)","uri":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A16/"},{"categories":["计算机算法设计与分析"],"content":"优先队列式分支限界法 活结点x的优先级:根到结点x的路径相应的载重量+剩余集装箱重量之和 优先队列中优先级最高的活结点成为下一个扩展结点。 用最大优先队列存储活结点表（大顶堆） 以结点x为根的子树中所有结点相应的路径的载重量不会超过x的优先级。叶结点所相应的载重量与其优先级相同。 一旦优先队列中有一个叶结点成为当前扩展结点，则可以断言该叶结点所相应的载重量即为最优值。此时即可终止算法的搜索过程。 注意：算法中扩展出的叶子结点要进队列 模拟优先队列（堆） Templete\u003cclass Type \u003e Type MaxLoading(Type w[], Type c, int n, int bestx[]) { //优先队列分支限界法，返回最大装载量Ew，最优解bestx MaxHeap\u003cHeapNode\u003cType\u003e\u003e H(1000); //定义最大堆的容量为1000 Type *r=new Type [n+1]; r[n]=0; for(int j=n-1;j\u003e0;j--) r[j]=r[j+1]+w[j+1]; int i=1; bbnode *E=0; Type Ew=0; while (i!=n+1){ //搜索子集树 if (Ew+w[i] \u003c= c) AddLiveNode(H, E, Ew+w[i]+r[i], true, i+1); AddLiveNode(H, E, Ew+r[i], false, i+1); HeapNode\u003cType\u003e N; H.DeleteMax(N); i=N.level; E=N.ptr; Ew=N.uweight-r[i-1]; } for（int j=n;j\u003e0;j--）{//构造最优解 bestx[j]=E-\u003elchild; E=E-\u003eparent;｝ return Ew; } ","date":"2024-04-30","objectID":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A16/:2:4","tags":["计算机算法设计与分析"],"title":"算法与程序(第六章)","uri":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A16/"},{"categories":["计算机算法设计与分析"],"content":"总结 回溯法与分支限界法的区别：求解目标、搜索方式 分支限界法的基本思想： 五个步骤 分支限界法的分类：** 队列与优先队列，同活结点表有关** 装载问题的分支限界法：队列式与优先队列式，重点内容包括算法设计，剪枝条件，算法结束条件，优先队列式的优先级的定义,构造最优解 ","date":"2024-04-30","objectID":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A16/:2:5","tags":["计算机算法设计与分析"],"title":"算法与程序(第六章)","uri":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A16/"},{"categories":["计算机算法设计与分析"],"content":"布线问题 布线问题分支限界法 ","date":"2024-04-30","objectID":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A16/:3:0","tags":["计算机算法设计与分析"],"title":"算法与程序(第六章)","uri":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A16/"},{"categories":["计算机算法设计与分析"],"content":"0-1背包问题 算法的思想 先进行预处理：将各物品依其单位重量价值从大到小排列。 优先队列的优先级：已装物品价值+后面物品装满剩余容量的价值 算法： 先检查当前扩展结点的左儿子结点。如果该左儿子结点是可行结点，则将它加 入活结点优先队列中，如优于当前最优值，则更新当前最优值。 当前扩展结点的右儿子结点一定是可行结点，仅当右儿子结点满足上界约束时 （优先级大于当前最优值）才将它加入活结点优先队列。 从优先队列中取下一个活结点成为扩展结点，继续扩展。 当叶节点为扩展结点时即为问题的最优值，算法结束。 b=背包已有物品价值；cleft=背包剩余容量，从第i~n物品为剩余的物品，用剩余物品装满剩余背包容量的背包的贪心算法（主要代码如下） while (i \u003c= n \u0026\u0026 w[i] \u003c= cleft) // n表示物品总数，cleft为剩余空间 { cleft -= w[i]; //w[i]表示i所占空间 b += p[i]; //p[i]表示i的价值 i++; } if (i \u003c= n) b += p[i] / w[i] * cleft; // 装填剩余容量装满背包 return b; //b为上界函数值 优先队列中的结点信息包含： 当前背包价值、重量； 结点的优先级（价值上界）； 左孩子标志； 父结点地址； 本结点对应的下一个要装入背包的物品编号； 搜索算法的主代码 while (i != n+1) {// 非叶结点 // 检查当前扩展结点的左儿子结点 Typew wt = cw + w[i]; if (wt \u003c= c) {// 左儿子结点为可行结点 if (cp+p[i] \u003e bestp) bestp = cp+p[i]; AddLiveNode(up, cp+p[i], cw+w[i], true, i+1);} up = Bound(i+1); // 检查当前扩展结点的右儿子结点 if (up \u003e= bestp) // 右子树可能含最优解 AddLiveNode(up, cp, cw, false, i+1); // 取下一个扩展节点（略）； } ","date":"2024-04-30","objectID":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A16/:4:0","tags":["计算机算法设计与分析"],"title":"算法与程序(第六章)","uri":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A16/"},{"categories":["操作系统"],"content":"设备管理 ","date":"2024-04-25","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F6/:0:0","tags":["操作系统"],"title":"操作系统(第六章)","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F6/"},{"categories":["操作系统"],"content":"I/O系统组成 I/O设备：打印机和磁盘 I/O设备控制器 I/O通道 四级结构 $存储器 \\rightarrow I/O通道 \\rightarrow I/O控制器 \\rightarrow I/O设备$ 总线 ","date":"2024-04-25","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F6/:1:0","tags":["操作系统"],"title":"操作系统(第六章)","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F6/"},{"categories":["操作系统"],"content":"I/O控制方式(4种) ","date":"2024-04-25","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F6/:2:0","tags":["操作系统"],"title":"操作系统(第六章)","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F6/"},{"categories":["操作系统"],"content":"cpu与外部设备之间信息交换方式 cpu与外部设备的关系 传输信息的方式 程序I/O方式 定义：cpu通过执行测试指令判断I/O设备状态busy 0 1 cpu与I/O串行工作 每次只能传输一个字符 中断控制 定义：因为内部某些原因，cpu停止当前程序的执行而转去执行中断服务程序(I/O操作)，当中断程序执行完以后，又返回到中断的程序继续执行 分类 硬中断 软中断 中断的过程 保存中断现场(入栈) PSW(状态寄存器) PC(程序寄存器) 转入中断服务程序执行($中断向量 \\rightarrow 入口地址$) 返回中断(出栈)：$PC+1 \\rightarrow PC$ 数据寄存器：存放一个字符 cpu与I/O设备在启动中断操作的时候只串行，而其他都是并行 $中断频率高 \\rightarrow cpu的干预多$ 中断方式适用于打印机(字符设备) DMA控制方式 定义：在DMA控制器的控制下，完成cpu与I/O设备的信息交换 DMA控制器的组成 寄存器，控制逻辑与I/O设备的接口 四个寄存器：DR(数据寄存器)，MAR(内存地址寄存器)，DC(数据计数器)，CR(命令/状态寄存器) 传输用系统总线 cpu与I/O设备并行工作(周期的挪用) cpu执行简单指令(访问cpu寄存器)(几乎可以做到并行) cpu执行复杂指令(访问内存)(不可以并行) 中断驱动与DMA控制方式的区别 产生中断的频率不同 数据传输方式不同 I/O通道控制(了解) I/O通道控制 ","date":"2024-04-25","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F6/:2:1","tags":["操作系统"],"title":"操作系统(第六章)","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F6/"},{"categories":["操作系统"],"content":"缓冲区 ","date":"2024-04-25","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F6/:3:0","tags":["操作系统"],"title":"操作系统(第六章)","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F6/"},{"categories":["操作系统"],"content":"缓冲的引入 缓和CPU与I/O设备间速度不匹配的矛盾 减少对CPU的中断频率,放宽对CPU中断响应时间的限制 提高CPU和I/O设备之间的并行性 实现方法 内存(连续一片存储空间，作为缓冲区) 寄存器 例：在分页系统中：快表(联想寄存器) 两种缓冲区(数据块处理时间的计算) 单缓冲：设置一个与数据块大小相等的缓冲区 处理过程 T：从I/O设备输入到单缓冲的时间 M：从单缓冲取出数据传送到内存工作区的时间 C：cpu执行时间 其中，T,M为串行工作，T,C并行工作 一个数据块处理：T+M+C 多个数据块处理：MAX(T,C)+M 例：假设把磁盘上一个数据块中的信息输入一单缓冲区的时间T为100us,将缓冲区的数据传送到用户区的时间M为50us，CPU对这一块数据进行计算的时间C为50us。请问系统对一块数据的处理时间为多少 解： 单个为：100+50+50=200us 例：设系统缓冲区和用户工作区均采用单缓冲区，从外设读入1个数据块到系统缓冲区的时间为100，从系统缓冲区读入1个数据块到用户工作区的时间为5，对用户工作区中的1个数据块进行分析的时间为90，问：进程从外设读入并分析2个数据块的最短时间是多少？ 解： $T_1+M_1+T_2+M_2+C_2$=100+5+100+5+90=300us 例：已知有包括10个数据块的文件用单缓冲进行数据处理，其中从磁盘输入到缓冲区的时间是15us；再从缓冲区传送到内存时间为5us，最后对数据块执行时间为1us 解： $T_1+M_1+C_{10}+(10-1) \\times 20$=15+5+1+9 X 20=201us 双缓冲 缓冲区1 缓冲区2 处理过程 T：从I/O设备输入到单缓冲的时间 M：从单缓冲取出数据传送到内存工作区的时间 C：cpu执行时间 其中，T,M为并行工作，T,C并行工作 一个数据块处理：T+M+C 多个数据块处理：MAX(T,M+C) 例：假设把磁盘上一个数据块中的信息输入一双缓冲区的时间T为100us,将缓冲区的数据传送到用户区的时间M为50us，CPU对这一块数据进行计算的时间C为50us。请问系统对一块数据的处理时间为多少？ 单个为：100+50+50=200us 例：设系统缓冲区和用户工作区均采用双缓冲区，从外设读入1个数据块到系统缓冲区的时间为100，从系统缓冲区读入1个数据块到用户工作区的时间为5，对用户工作区中的1个数据块进行分析的时间为90，问：进程从外设读入并分析2个数据块的最短时间是多少？ 解： $T_1+T_2+M_2+C_2$=100+100+5+90=295us 例：已知有包括10个数据块的文件用双缓冲进行数据处理，其中从磁盘输入到缓冲区的时间是15us；再从缓冲区传送到内存时间为5us，最后对数据块执行时间为1us 解： $T_1+T \\times 9 +M_{10}+C_{10}$=150+6=156us ","date":"2024-04-25","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F6/:3:1","tags":["操作系统"],"title":"操作系统(第六章)","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F6/"},{"categories":["计算机组成原理"],"content":"中央处理器 ","date":"2024-04-25","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%865/:0:0","tags":["计算机组成原理"],"title":"计算机组成(第五章)","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%865/"},{"categories":["计算机组成原理"],"content":"CPU的功能和组成 当代主流计算机所遵循的仍然是冯.诺依曼的“存储程序、程序控制”思想 程序告诉计算机：应该逐步执行什么操作；在什么地方找到用来操作的数据，结果存到何处等 中央处理器是控制计算机自动完成取出指令和执行指令任务的部件。它是计算机的核心部件，通常简称为CPU（Central Processing Unit） ","date":"2024-04-25","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%865/:1:0","tags":["计算机组成原理"],"title":"计算机组成(第五章)","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%865/"},{"categories":["计算机组成原理"],"content":"CPU的功能 **指令控制 ** 保证机器按程序规定的顺序取出执行 操作控制 CPU产生每条指令所对应的操作信号，并把各种操作信号送往相应的部件，从而控制这些部件按指令的要求进行动作 **时间控制 ** 对各种操作的实施时间进行定时 数据加工 对数据进行算术运算和逻辑运算处理 ","date":"2024-04-25","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%865/:1:1","tags":["计算机组成原理"],"title":"计算机组成(第五章)","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%865/"},{"categories":["计算机组成原理"],"content":"CPU的基本组成 控制器完成对整个计算机系统操作的协调与指挥 控制机器从内存中取出一条指令，并指出下一条指令在内存中的位置 对指令进行译码，并产生相应的操作控制信号，送往相应的部件，启动规定的动作 指挥并控制CPU、内存与输入/输出（I/O）设备之间数据流动的方向 运算器是数据加工处理部件，所进行的全部操作由控制器发出的控制信号指挥 执行所有的算术运算 执行所有的逻辑运算，并进行逻辑测试 ","date":"2024-04-25","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%865/:1:2","tags":["计算机组成原理"],"title":"计算机组成(第五章)","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%865/"},{"categories":["计算机组成原理"],"content":"CPU中的主要寄存器 数据缓冲寄存器(DR) 暂时存放由内存读出或写入的指令或数据字 指令寄存器（IR） 保存当前正在执行的一条指令 程序计数器（PC） 确定下一条指令的地址 地址寄存器（AR） 保存当前CPU所访问的内存单元的地址 通用寄存器组 为ALU提供工作区 状态条件寄存器（PSW） 保存由算术和逻辑指令的结果建立的各种条件码 ","date":"2024-04-25","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%865/:1:3","tags":["计算机组成原理"],"title":"计算机组成(第五章)","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%865/"},{"categories":["计算机组成原理"],"content":"操作控制器与时序产生器 操作控制器在各寄存器之间建立数据通路（传送信息的通路） 操作控制器的功能: 就是根据指令操作码和时序信号，产生各种操作控制信号，以便正确地建立数据通路，从而完成取指令和执行指令的控制 硬布线控制器 微程序控制器 时序产生器产生并发出计算机所需要的时序控制信号 ","date":"2024-04-25","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%865/:1:4","tags":["计算机组成原理"],"title":"计算机组成(第五章)","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%865/"},{"categories":["计算机组成原理"],"content":"指令周期 ","date":"2024-04-25","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%865/:2:0","tags":["计算机组成原理"],"title":"计算机组成(第五章)","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%865/"},{"categories":["计算机组成原理"],"content":"指令周期的基本概念 **指令周期 **: CPU从内存取出一条指令并执行完这条指令的时间总和 取指时间＋执行指令时间 CPU周期 : 又称机器周期（总线周期），CPU访问内存所花的时间较长，因此用CPU从内存读取一条指令字的所需的最短时间来定义 T周期 : 通常称为节拍脉冲。一个CPU周期包含若干个T周期 相互关系： 1个指令周期 = 若干个CPU周期 1个CPU周期 = 若干T周期 指令运行的基本过程 取指令阶段 取指令阶段完成的任务是将现行指令从主存中取出来并送至指令寄存器中去。具体的操作如下： 将程序计数器（PC）中的内容送至存储器地址寄存器（MAR），并送地址总线（AB）。 由控制单元（CU）经控制总线（CB）向存储器发读命令 从主存中取出的指令通过数据总线（DB）送到存储器数据寄存器（MDR）。 将MDR的内容送至指令寄存器（IR）中。 将PC的内容递增，为取下一条指令做好准备 以上这些操作对任何一条指令来说都是必须要执行的操作，所以称为公共操作。完成取指阶段任务的时间称为取指周期 分析取数阶段 取出指令后，指令译码器ID可识别和区分出不同的指令类型。此时计算机进入分析取数阶段，以获取操作数。由于各条指令功能不同，寻址方式也不同，所以分析取数阶段的操作是各不相同的 完成分析阶段任务的时间又可以细分为间址周期、取数周期等 执行阶段 执行阶段完成指令规定的各种操作，形成稳定的运算结果，并将其存储起来。完成执行阶段任务的时间称为执行周期 计算机的基本工作过程就是取指令、取数、执行指令，然后再取下一条指令……如此周而复始，直至遇到停机指令或外来的干预为止 指令的微操作序列 控制器在实现一条指令的功能时，总要把每条指令分解成为一系列时间上先后有序的最基本、最简单的微操作，即微操作序列。微操作序列是与CPU的内部数据通路密切相关的，不同的数据通路就有不同的微操作序列 假设规定各部件用大写字母表示，字母加下标in表示该部件的接收控制信号，实际上就是该部件的输入开门信号；字母加下标out表示该部件的发送控制信号，实际上就是该部件的输出开门信号。例如：$MAR_{IN}、PC_{OUT}$等就是这类微操作信号 加法指令ADD (R0),R1 这条指令完成的功能是把R0的内容作为地址送到主存以取得一个操作数，再与R1中的内容相加，最后将结果送回主存中。即实现： $((R0))+(R1)→(R0)$ 取指周期 取指周期完成的微操作序列是公共的操作，与具体指令无关 $PC_{OUT}和MAR_{IN}$有效，完成PC经CPU内部总线送至MAR的操作，记作PC→MAR 通过控制总线向主存发读命令，记作Read； 存储器通过数据总线将MAR所指单元的内容（指令）送至MDR，记作M→MDR； $MDR_{OUT}$和$IR_{IN}$有效，将MDR的内容送至指令寄存器IR，记作MDR→IR。至此，指令被从主存中取出，其操作码字段开始控制CU 使PC内容加1，记作PC+1→PC 取数周期 取数周期要完成取操作数的任务，被加数在主存中，加数已放在寄存器$R_1$中 $R0_{OUT}$和$MAR_{IN}$有效，完成将被加数地址送至MAR的操作，记作$R_0$→MAR； 向主存发读命令，记作Read 存储器通过数据总线将MAR所指单元的内容（数据）送至MDR，同时$MDR_{OUT}$和$Y_{IN}$有效，记作M→MDR→Y 执行周期 执行周期完成加法运算的任务，并将结果写回主存 $R1_{OUT}$和$ALU_{IN}$有效，同时CU向ALU发“ADD”控制信号，使R1的内容和Y的内容相加，结果送寄存器Z，记作R1+Y→Z $Z_{OUT}$和$MDR_{IN}$有效，将运算结果送寄存器MDR，记作Z→MDR 向主存发写命令，记作Write 5条典型指令构成的简单程序 ","date":"2024-04-25","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%865/:2:1","tags":["计算机组成原理"],"title":"计算机组成(第五章)","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%865/"},{"categories":["计算机组成原理"],"content":"CLA指令的指令周期 取出CLA指令 执行CLA指令 ","date":"2024-04-25","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%865/:2:2","tags":["计算机组成原理"],"title":"计算机组成(第五章)","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%865/"},{"categories":["计算机组成原理"],"content":"ADD指令的指令周期 取出并执行ADD指令 ","date":"2024-04-25","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%865/:2:3","tags":["计算机组成原理"],"title":"计算机组成(第五章)","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%865/"},{"categories":["计算机组成原理"],"content":"STA指令的指令周期 取出并执行STA指令 ","date":"2024-04-25","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%865/:2:4","tags":["计算机组成原理"],"title":"计算机组成(第五章)","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%865/"},{"categories":["计算机组成原理"],"content":"NOP指令和JMP指令的指令周期 取出并执行JMP指令 ","date":"2024-04-25","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%865/:2:5","tags":["计算机组成原理"],"title":"计算机组成(第五章)","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%865/"},{"categories":["计算机组成原理"],"content":"时序产生器和控制方式 用二进制码表示的指令和数据都放在内存里，那么CPU是怎样识别出它们是数据还是指令呢? 从时间上来说: 取指令事件发生在指令周期的第一个CPU周期中，即发生在“取指令”阶段，而取数据事件发生在指令周期的后面几个CPU周期中，即发生在“执行指令”阶段 从空间上来说: 如果取出的代码是指令，那么一定经DR送往指令寄存器IR，如果取出的代码是数据，那么一定送往运算器。 时间控制对计算机来说是非常重要的！ ","date":"2024-04-25","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%865/:3:0","tags":["计算机组成原理"],"title":"计算机组成(第五章)","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%865/"},{"categories":["计算机组成原理"],"content":"时序信号的作用和体制 计算机的协调动作需要时间标志，而且需要采用多级时序体制。而时间标志则用时序信号来体现 硬布线控制器中，时序信号往往采用主状态周期-节拍电位-节拍脉冲三级体制 微程序控制器中，时序信号则一般采用节拍电位-节拍脉冲二级体制 时序产生器 一、 概念 时序部件：计算机的机内时钟。它用其产生的周期状态，节拍电位及时标脉冲去对指令周期进行时间划分，刻度和标定 指令周期：在计算机中从指令的读取到指令的执行完成，执行一条指令所需要的时间，称为指令周期 指令周期通常由若干个CPU周期来表示，CPU周期也称为机器周期 由于CPU内部的操作速度较快，而CPU访问一次内存所花的时间较长，通常用存储周期为基础来规定CPU周期 二、3级时序信号 周期 在一个控制阶段内均持续起作用的信号； 通常用周期状态寄存器来标志和指明某某周期控制 指令周期可分为取指周期、分析周期、执行周期 节拍 把一个机器周期分成若干个相等的时间段，每一个时间段对应一个电位信号，称节拍电位 一般都以能保证ALU进行一次运算操作作为一拍电位的时间宽度 时标工作脉冲 及时改变标志状态 时标脉冲的宽度一般为节拍电位宽度的1/N，只要能保证所有的触发器都能可靠地，稳定地翻转即可 三、3级时序信号的关系 一台计算机机内的控制信号一般均由若干个周期状态，若干个节拍电位及若干个时标脉冲这样3级控制时序信号定时完成。 3级控制时序信号的宽度均成正整数倍同步关系 周期状态之间，节拍电位之间，时标脉冲之间既不容许有重叠交叉，又不容许有空白间隙，应该是能一个接一个地准确连接，一个降落另一个升起而准确切换的同步信号 主状态周期-节拍电位-节拍脉冲 时序产生器 节拍电位-节拍脉冲 数据准备好后，以电位的方式送触发器 控制信号来到后，用一个脉冲信号把数据装入触发器 ","date":"2024-04-25","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%865/:3:1","tags":["计算机组成原理"],"title":"计算机组成(第五章)","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%865/"},{"categories":["计算机组成原理"],"content":"CPU的控制方式 控制器的控制方式：形成控制不同微操作序列的时序控制信号的方法 控制方式的分类 同步控制方式 异步控制方式 同异步联合控制方式 同步控制方式 一、同步控制方式 含义：又称为固定时序控制方式或无应答控制方式。任何指令的执行或指令中每个微操作的执行都受事先安排好的时序信号的控制 每个周期状态中产生统一数目的节拍电位及时标工作脉冲 以最复杂指令的实现需要为基准 优点：设计简单，操作控制容易实现 缺点：效率低 完全同步控制方式 异步控制方式 二、异步控制方式 含义：可变时序控制方式或应答控制方式。执行一条指令需要多少节拍，不作统一的规定，而是根据每条指令的具体情况而定，需要多少，控制器就产生多少时标信号 特点：每一条指令执行完毕后都必须向控制时序部件发回一个回答信号，控制器收到回答信号后，才开始下一条指令的执行 优点：指令的运行效率高 缺点：控制线路比较复杂 异步工作方式一般采用两条定时控制线来实现。我们把这两条线称为“请求”线和“回答”线。当系统中两个部件A和B进行数据交换时，若A发出“请求”信号，则必须有B的“回答”信号进行应答，这次操作才是有效的，否则无效 一般采用两条定时控制线：“请求”线和“回答”线 联合控制方式 三、同步，异步联合控制方式 含义：同步控制和异步控制相结合的方式即联合控制方式，区别对待不同指令 一般的设计思想是，在功能部件内部采用同步式，而在功能部件之间采用异步式，并且在硬件实现允许的情况下，尽可能多地采用异步控制 ","date":"2024-04-25","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%865/:3:2","tags":["计算机组成原理"],"title":"计算机组成(第五章)","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%865/"},{"categories":["计算机组成原理"],"content":"微程序控制器 微程序控制器同硬布线控制器相比较，具有规整性、灵活性、可维护性等一系列优点 它利用软件方法（微程序设计技术）来设计硬件 微程序控制的基本思想就是把操作控制信号编成所谓的“微指令”，存放到一个只读存储器里（控制存储器CM） 当机器运行时，一条又一条地读出这些微指令，从而产生全机所需要的各种操作控制信号，是相应部件执行所规定的操作 微命令 → 指令系统 处理器内部可以分为：控制部件和执行部件 微命令：控制部件向执行部件发出的控制命令 微操作：执行部件接受微命令后所进行的操作 （微操作在执行部件中是最基本的操作） 微指令：实现一定操作功能的一组微命令 微程序：实现一条机器指令功能的微指令序列 指令系统＝所有指令，指令＝微程序 微程序＝若干微指令，微指令＝一组微命令 微命令→微操作 机器指令与微指令 ","date":"2024-04-25","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%865/:4:0","tags":["计算机组成原理"],"title":"计算机组成(第五章)","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%865/"},{"categories":["计算机组成原理"],"content":"微程序设计技术 微指令结构的确定是微程序设计的关键。 微指令结构的设计的目标是： 有利于缩短微指令字的长度 有利于减少控制存储器的容量 有利于提高微程序的执行速度 有利于对微指令的修改 有利于提高微程序设计的灵活性 一、微指令编码 微命令编码就是对微指令中的操作控制字段采用的表示方法。通常有以下三种方法 直接表示法 其特点是操作控制字段中的 每一位代表一个微命令。这种方法的优点是简单直观，其输出直接用于控制。缺点是微指令字较长，因而使控制存储器容量较大 编码表示法 编码表示法是把一组相斥性的微命令信号组成一个小组(即一个字段) ，然后通过小组(字段）译码器对每一个微命令信号进行译码 ，译码输出作为操作控制信号 混合表示法 这种方法是把直接表示法与字段编码法混合使用，以便能综合考虑指令字长、灵活性、执行微程序速度等方面的要求 另外 在微指令中还可附设一个常数字段 二、微地址的形成方法 微指令执行的顺序控制问题，实际上是如何确定下一条微指令的地址问题。通常，产生后继微地址有两种方法： 计数器方式 这种方法同用程序器计数来产生机器指令地址的方法相类似。 在顺序执行微指令时，后继微地址由现行微地址加上一个增量来产生；在非顺序执行微指令时，必须通过转移方式，使现行微指令执行后，转去执行指定后继微地址的下一条微指令 在这种方法中，微地址寄存器通常改为计数器。为此，顺序执行的微指令序列就必须安排在控制存储器的连续单元中 计数器方式的基本特点是：微指令的顺序控制字段较短，微地址产生机构简单。但是多路并行转移功能较弱，速度较慢，灵活性较差 多路转移方式 一条微指令具有多个转移分支的能力称为多路转移 在多路转移方式中，当微程序不产生分支时，后继微地直接由微指令的顺序控制字段给出；当微程序出现分支时，有若干“后选”微地址可供选择：即按顺序控制字段的“判别测试”标志和“状态条件”信息来选择其中一个微地址。“状态条件”有n位标志，可实现微程序2N路转移，涉及微地址寄存器的n位 多路转移方式的特点是：能以较短的顺序控制字段配合，实现多路并行转移，灵活性好，速度较快，但转移地址逻辑需要用组合逻辑方法设计 **三、微指令格式 ** 微指令的编译方法是决定微指令格式的主要因素 微指令的格式大体分成两类：水平型微指令和垂直型微指令 水平型微指令 一次能定义并执行多个并行操作微命令的微指令，叫做水平型微指令。 其一般格式如下 按照控制字段的编码方法不同，水平型微指令又分为三种：全水平型(不译法)微指令，字段译码法水平型微指令，以及直接和译码相混合的水平型微指令 垂直型微指令 微指令中设置微操作码字段，采用微操作码编译法，由微操作码规定微指令的功能 ，称为垂直型微指令 其结构类似于机器指令的结构。它有操作码，在一条微指令中只有1—2个微操作命令，每条微指令的功能简单，因此，实现一条机器指令的微程序要比水平型微指令编写的微程序长得多。它是采用较长的微程序结构去换取较短的微指令结构 **四、 动态微程序设计 ** 微程序设计技术有静态微程序设计和动态微程序设计之分 静态微程序设计 对应于一台计算机的机器指令只有一组微程序，而且这一组微程序设计好之后，一般无须改变而且也不好改变，这种微程序设计技术称为静态微程序设计 动态微程序设计 当采用EPROM作为控制存储器时，还可以通过改变微指令和微程序来改变机器的指令系统，这种微程序设计技术称为动态微程序设计。采用动态微程序设计时，微指令和微程序可以根据需要加以改变，因而可在一台机器上实现不同类型的指令系统。这种技术又称为仿真其他机器指令系统，以便扩大机器的功能 ","date":"2024-04-25","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%865/:5:0","tags":["计算机组成原理"],"title":"计算机组成(第五章)","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%865/"},{"categories":["计算机组成原理"],"content":"硬布线控制器 硬布线控制器把控制部件看作为产生专门固定时序控制信号的逻辑电路（以使用最少元件和取得最高操作速度为设计目标） 硬布线控制的优点：速度较快； 缺点：不容易修改添加新功能 微程序控制的优点：具有规整性、灵活性、可维护性等； 缺点：采用存储程序原理，需要执行多条微指令，速度较慢 硬布线控制器设计思想： 采用适宜指令格式，合理分配指令操作码； 确定机器周期、节拍与主频； 确定机器周期数及一周期内的操作 进行指令综合； 综合所有指令的每一个操作命令，写出逻辑表达式，并进行化简 明确组合逻辑电路。 将简化后的逻辑表达式用组合逻辑电路来实现。操作命令的控制信号先用逻辑表达式列出，进行化简，考虑各种条件的约束，合理选用逻辑门电路、触发器等器件，采用组合逻辑电路的设计方法产生控制信号 总之，控制信号的设计与实现，技巧性较强，一些专门的开发系统或工具供逻辑设计使用，但是，对全局的考虑主要依靠设计人员的智慧和经验实现 ","date":"2024-04-25","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%865/:6:0","tags":["计算机组成原理"],"title":"计算机组成(第五章)","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%865/"},{"categories":["计算机组成原理"],"content":"传统CPU M6800CPU 是一个比较典型的单总线结构的微处理器 M6800CPU是一种8位微处理器，采用单一的5V电源。时钟脉冲采用两相(φ1，φ2)，主频为1MHz，由外面加入CPU M6800的CPU主要包括8位的ALU，16位的程序计数器、16位的堆栈指示器和16位的变址寄存器，两个8位的累加器和一个8位的状态条件码寄存器，一个8位的指令寄存器以及指令译码与控制部件(即操作控制器)。此外还有一个8位的数据缓冲寄存器和一个16位的地址缓冲寄存器 ALU部件执行算术运算和逻辑操作，它们包括逻辑“与”、逻辑“或”、逻辑“异或”、求补、比较、加法、减法、十进制调整等 在M6800中，主存地址和外设地址是统一编址的，因此，在65536个地址中有一部分是为外围设备使用的 Intel 8088CPU Intel 8088是一种通用的准16位微处理器，其内部结构为16位，与外部交换的数据为8位。它可以处理16位数据(具有16位运算指令，包括乘除法指令)，也可处理8位数据。它有20条地址线，直接寻址能力达到1M字节 CPU 从功能上来说分成总线接口单元BIU和执行单元EU两大部分 BIU负责与存储器和外围设备接口，即8088 CPU与存储器和外围设备之间的信息传送，都是由BIU进行的 EU 部分负责指令的执行。取指部分与执行指令部分是独立并行工作的，在一条指令的执行过程中，可取出下一条(或多条)指令，在指令流队列寄存器中排队。在一条指令执行完以后就可以立即执行下一条指令，减少了CPU为取指令而等待的时间，提高了系统的运行速度 IBM 370CPU 32位CPU ALU部件按功能不同分为如下三个子部件：(1)定点运算，包括整数计算和有效地址的计算；(2)浮点运算；(3)可变长运算，包括十进制算术运算和字符串操作 为了存放地址和数据，使用了两组独立的可编址寄存器，16个通用寄存器用来存放操作数和运算结果，且可用作变址寄存器。4个浮点寄存器用于浮点运算。数据寄存器DR、地址寄存器AR、指令寄存器IR是标准化的 Intel 80486CPU 32位CPU 通过采用流水技术，以及微程序控制和硬布线逻辑控制相结合的方式，进一步缩短可变长指令的译码时间，达到基本指令可以在一个时钟周期内完成 486芯片内部包含一个8KB的数据和指令混合性cache，为频繁访问的指令和数据提供快速的内部存储，从而使系统总线有更多的时间用于其他控制 486芯片内部包含了增强性80387协处理器，称为浮点运算部件(FPU)。由于FPU功能扩充，且放在CPU内部，使引线缩短，故速度比80387提高了3—5倍 486 CPU的内部数据总线宽度为64位，这也是它缩短指令周期的一个原因。而外部数据总线的宽度也可以自动转换 地址信号线扩充到32位，可以处理4GB(232字节)的物理存储空间。如果利用虚拟存储器，其存储空间达64TB($2^{46}$字节) ","date":"2024-04-25","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%865/:7:0","tags":["计算机组成原理"],"title":"计算机组成(第五章)","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%865/"},{"categories":["计算机组成原理"],"content":"流水CPU ","date":"2024-04-25","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%865/:8:0","tags":["计算机组成原理"],"title":"计算机组成(第五章)","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%865/"},{"categories":["计算机组成原理"],"content":"并行处理技术 并行性（Parallelism） 在同一时刻或是同一时间间隔内完成两种或两种以上性质相同或不相同的工作 同时性（Simultaneity）：同一时刻发生的并行性 并发性（Concurrency）：同一个时间间隔内发生的并行性 并行性的等级 指令内部并行：微操作之间 指令级并行（ILP：Instruction Level Parallel） 线程级并行（TLP：Thread Level Parallel ） 程序级并行 系统级并行：分布式系统、多机系统、机群系统 提高并行性的技术途径 时间重叠（Time-interleaving）＝时间并行 多个过程在时间上相互错开，轮流重叠地使用同一套硬件设备的各个部分 资源重复（Resource-replication）＝空间并行 数量取胜原则，通过重复设置资源（尤其是硬件资源），提高性能 资源共享（Resource-sharing） 使多个任务按一定时间顺序轮流使用同一套硬件设备 单机系统中并行性的发展 指令流水线，部件冗余，分时系统 多机系统中并行性的发展 多机系统 耦合度：松散耦合、紧密耦合 ","date":"2024-04-25","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%865/:8:1","tags":["计算机组成原理"],"title":"计算机组成(第五章)","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%865/"},{"categories":["计算机组成原理"],"content":"流水CPU的结构 流水线的时空图 流水线技术：把一个重复的过程分解为若干个子过程，每个子程序可以与其他子过程同时进行 描述流水线的工作，最常用的方法是时间-空间图（时空图） 横坐标：表示时间，即各个任务在流水线中所经过的时间 纵坐标：表示空间，即流水线的各个子过程，也称为级、段、流水线深度(Stage) 非流水计算机的时空图 流水计算机的时空图 流水线的特点 流水线实际上是把一个功能部件分解成多个独立的子功能部件（一个任务也就分成了几个子任务，每个子任务由一个子功能部件完成），并依靠多个子功能部件并行工作来缩短所有任务的执行时间 流水线有助于提高整个程序（所有任务）的吞吐率，但并没有减少每个指令（任务）的执行时间 流水线各个功能段所需时间应尽量相等。否则，时间长的功能段将成为流水线的“瓶颈”，会造成流水线的“阻塞”（Stall） 流水线开始需要“**通过时间”(Fill)**和最后需要“排空时间”(Drain)。流水线只有处理连续不断的任务才能发挥其效率 ","date":"2024-04-25","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%865/:8:2","tags":["计算机组成原理"],"title":"计算机组成(第五章)","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%865/"},{"categories":["计算机组成原理"],"content":"流水线中的主要问题 流水线中存在一些**相关(冲突、冒险Hazard，相关、依赖Dependence，竞争Competition)**的情况，它使得下一条指令无法在设计的时钟周期内执行。这些相关将降低流水线性能 主要有三种类型的相关（冲突） 结构相关（资源冲突）：当指令重叠执行过程中，硬件资源满足不了指令重叠执行的要求 数据相关（数据冲突） ：在同时执行的多条指令中，一条指令依赖前一条指令的执行结果(数据)却无法得到 控制相关（控制冲突）：流水线遇到分支指令或其他改变PC值的指令 **1. 资源相关 ** 资源相关是指多条指令进入流水线后，在同一机器时钟周期内争用同一个功能部件所发生的冲突 例：假定一条指令流水线由五段组成，且仅有IF过程和MEM过程需要访问存储器 2. 数据相关 3. 控制相关 **控制相关冲突由转移指令（分支指令）**引起 执行转移指令时，依据转移条件的产生结果 可能为顺序取下条指令 也可能转移到新的目标地址取指令 地址不定，流水线需要暂停、发生断流 转移指令主要有： 无条件转移指令：跳转、过程调用和返回条件分支指令 例: 流水线中有三类数据相关冲突：写后读(RAW)相关；读后写(WAR)相关；写后写(WAW)相关 指令动态调度策略 简单指令流水线技术的一个主要局限 指令顺序发射(in-order issue)＝按序发射 指令顺序执行(in-order execution) 如果一条指令在流水线中，与之相关的指令及其后面的指令都不能进行处理 改进指令流水线，只要指令操作数就绪就执行 指令乱序执行(out-of-order execution) 指令乱序结束(out-of-order completion) 多指令流出技术 进一步改进指令流水线，实现一个时钟周期发射（流出issue）多条指令 超标量(Superscalar)处理器：每个时钟周期发射多条指令（1-8) 超长指令字(VLIW: Very Long Instruction Word)：通过编译器调度无关的多条指令（4-16）形成一条长指令，每个时钟周期发射一条长指令 超级流水线(Super pipelining)：将每个功能部件进一步流水化，使得一个功能部件在一个时钟周期中可以处理多条指令（可以简单地理解为很长的流水线） 多发射流水线 80486的整数指令流水线 5级指令流水线，每级1个时钟周期 $PF \\rightarrow$指令预取（prefetch） $D1 \\rightarrow$指令译码1（decode stage 1） 对所有操作码和寻址方式信息进行译码 $D2 \\rightarrow$指令译码2（decode stage 2） 将操作码扩展为ALU的控制信号，存储器地址计算 $EX \\rightarrow$指令执行（execute） 完成ALU操作和Cache存取 $WB \\rightarrow$回写（write back） 更新在EX步骤得到的寄存器数据和状态标志 Pentium的超标量流水线 类似80486的5级流水线，后3级可以在两个流水线同时进行 指令预取PF和指令译码D1步骤可以并行取出、译码2条简单指令，然后分别发向U和V流水线 在满足指令配对的条件下，Pentium可以每个时钟周期执行完2条指令 ","date":"2024-04-25","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%865/:8:3","tags":["计算机组成原理"],"title":"计算机组成(第五章)","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%865/"},{"categories":["计算机组成原理"],"content":"RISC CPU RISC的三个要素 一个有限的简单的指令集 CPU配备大量的通用寄存器 强调对指令流水线的优化 **RISC机器的特点 ** 等长指令，典型长度是4个字节(32位）； 寻址方式少且简单，一般为2～3种； 只有取数指令和存数指令访问存储器； 指令数目一般少于100种，指令格式一般少于4种 指令功能简单，控制器多采用硬布线方式 指令的执行时间为一个处理时钟周期 整数寄存器的个数不少于32个 强调通用寄存器资源的优化使用 支持指令流水并强调指令流水的优化使用 RISC技术的编译程序复杂 RISC与CISC的主要特征对比 ","date":"2024-04-25","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%865/:9:0","tags":["计算机组成原理"],"title":"计算机组成(第五章)","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%865/"},{"categories":["计算机组成原理"],"content":"CPU性能评价 CPU性能与3个要素有关 时钟频率f 每条指令需要的时钟周期数CPI 指令条数$I_N$ 时钟周期长度t＝1/f CPU时钟周期数Nc＝CPI×$I_N$ ","date":"2024-04-25","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%865/:10:0","tags":["计算机组成原理"],"title":"计算机组成(第五章)","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%865/"},{"categories":["计算机组成原理"],"content":"CPU性能公式 补充例题 假设在一般程序中浮点开平方操作FPSQR所占的比例为2%，它的CPI为100；其他浮点操作FP所占的比例为23%，它的CPI＝4.0；其余75%指令的CPI＝1.33，计算该处理机的CPI。如果FPSQR操作的CPI也为4.0，重新计算CPI。 解答 CPI1＝100×2%＋4×23%＋1.33×75%＝3.92 CPI2＝4×25%＋1.33×75%＝2.00 ","date":"2024-04-25","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%865/:10:1","tags":["计算机组成原理"],"title":"计算机组成(第五章)","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%865/"},{"categories":["计算机组成原理"],"content":"性能评价标准 最初 执行单项操作的时间，例如：加法操作时间 改进为 平均指令执行时间＝$\\sum 每条指令数 \\times 该指令的混合比例$ 进一步成为容易理解的 每秒百万条指令（Million Instructions Per Second） 同时出现 MFLOPS（每秒百万浮点操作） 最终形成 测试程序（Benchmarks） CPU时间与CPU性能 衡量性能最可靠的标准：真实程序的执行时间 真实程序的执行时间=CPU时间＋I/O操作等时间 CPU时间=用户CPU时间＋系统CPU时间 CPU性能对应用户CPU时间 CPU时间还可细分为用户CPU时间及系统CPU时间，前者表示用户程序所花费的CPU时间，后者表示用户程序运行期间操作系统花费的CPU时间。 ","date":"2024-04-25","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%865/:10:2","tags":["计算机组成原理"],"title":"计算机组成(第五章)","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%865/"},{"categories":["计算机组成原理"],"content":"本章小结 CPU是计算机的中央处理部件，具有指令控制、操作控制、时间控制、数据加工等基本功能 早期的CPU由运算器和控制器两大部分组成。随着高密度集成电路技术的发展，当今的CPU芯片变成运算器、cache和控制器三大部分，其中还包括浮点运算器、存储管理部件等。CPU中至少要有如下六类寄存器：指令寄存器、程序计数器、地址寄存器、缓冲寄存器、通用寄存器、状态条件寄存器 CPU从存储器取出一条指令并执行这条指令的时间和称为指令周期。由于各种指令的操作功能不同，各种指令的指令周期是不尽相同的。划分指令周期，是设计操作控制器的重要依据 时序信号产生器提供CPU周期(也称机器周期)所需的时序信号。操作控制器利用这些时序信号进行定时，有条不紊地取出一条指令并执行这条指令。时序部件是计算机的机内时钟，它用其产生的周期状态、节拍电位及时标脉冲去对指令周期进行时间划分，刻度和标定 微程序设计技术是利用软件方法设计操作控制器的一门技术，具有规整性、灵活性、可维护性等一系列优点，因而在计算机设计中得到了广泛应用，并取代了早期采用的硬布线控制器设计技术。但是随着VLSI技术的发展和对机器速度的要求，硬布线逻辑设计思想又得到了重视 硬布线控制器的基本思想是：某一微操作控制信号是指令操作码译码输出、时序信号和状态条件信号的逻辑函数，即用布尔代数写出逻辑表达式，然后用门电路，触发器等器件实现 不论微型机还是巨型机，并行处理技术已成为计算机技术发展的主流。并行处理技术可贯穿于信息加工的各个步骤和阶段。概括起来，主要有三种形式：(1)时间并行，(2)空间并行，(3)时间并行+空间并行 流水CPU是以时间并行性为原理构造的处理器，是一种非常经济而实用的并行技术。目前的高性能微处理器几乎无一例外地使用了流水技术。流水中的主要问题是资源相关、数据相关和控制相关，为此需要采取相应的技术对策，才能保证流水线畅通而不断流 RISC CPU是继承CISC的成功技术，并在克服CISC机器缺点的基础上发展起来的。RISC机器的三个基本要素是：(1)一个有限的简单指令集，(2)CPU配备大量的通用寄存器，(3)强调的指令流水线的优化。注意，RISC机器一定是流水CPU，但流水CPU不一定是RISC机器。如奔腾CPU是流水CPU，但奔腾机是CISC机器。 ","date":"2024-04-25","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%865/:11:0","tags":["计算机组成原理"],"title":"计算机组成(第五章)","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%865/"},{"categories":["面向对象程序设计"],"content":"数组 指针与字符串 ","date":"2024-04-20","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A16%E4%B8%8B/:0:0","tags":["面向对象程序设计"],"title":"c++(six_2)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A16%E4%B8%8B/"},{"categories":["面向对象程序设计"],"content":"动态内存分配 ","date":"2024-04-20","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A16%E4%B8%8B/:1:0","tags":["面向对象程序设计"],"title":"c++(six_2)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A16%E4%B8%8B/"},{"categories":["面向对象程序设计"],"content":"动态申请内存操作符 new new 类型名T（初值列表） 功能： 在程序执行期间，申请用于存放T类型对象的内存空间，并依初值列表赋以初值 结果值： 成功：T类型的指针，指向新分配的内存。失败：0（NULL） int *point; point = new int (2); Point *ptr; ptr = new Point; **注意：**堆对象的生命周期是整个程序生命期 如果建立的对象是某一个类的实例对象，就是要根据实际情况调用该类的构造函数 释放内存操作符delete delete 指针名 **功能：**释放指针 P 所指向的内存。P必须是new操作的返回值 例：动态存储分配举例 #include\u003ciostream\u003e using namespace std; class Point { public: Point ( ) { X =Y = 0; cout \u003c\u003c“Default constructor call.”\u003c\u003cendl ; } Point (int xx, int yy)　{ X = xx; Y = yy; cout\u003c\u003c“constructor call.”\u003c\u003cendl ; } ~point ( ) { cout \u003c\u003c“Destructor call.”\u003c\u003cendl ; } int GetX( ) { return X; } int GetY( ) { return Y;} void Move ( int x, int y)　{ X = x; Y = y; } private: int X, Y; }; void main ( ) { cout\u003c\u003c“Step One:”\u003c\u003cendl; Point *p1 = new Point; delete p1; cout\u003c\u003c“Step One:”\u003c\u003cendl; p1 = new Point (1,2); delete p1; }; //程序运行结果如下： //Step One: //Default constructor call. //Destructor call. //Step One: //constructor call. //Destructor call. ","date":"2024-04-20","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A16%E4%B8%8B/:1:1","tags":["面向对象程序设计"],"title":"c++(six_2)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A16%E4%B8%8B/"},{"categories":["面向对象程序设计"],"content":"动态内存分配 用new创建一维数组 new 类型名T [ 下标表达式 ] ; 下标表达式表示数组元素的个数 动态为数组分配内存时不能指定数组元素的初值 结果值 成功：返回指向新分配内存首地址的 T 类型的指针 失败：返回空指针 0 (NULL) 例: 动态存储分配举例 #include\u003ciostream\u003e using namespace std; class Point { public: Point ( ) { X =Y = 0;　cout \u003c\u003c“Default constructor call.”\u003c\u003cendl ; } Point (int xx, int yy)　{ X = xx; Y = yy; out \u003c\u003c“constructor call.”\u003c\u003cendl ; } ~point ( ) {cout\u003c\u003c“Destructor call.”\u003c\u003cendl ; } int GetX( ) { return X; } int GetY( ) { return Y;} void Move ( int x, int y){ X = x; Y = y; } private: int X, Y; }; void main ( ) { Point *ptr = new Point [2]; a //创建对象数组 ptr[ 0 ].Move ( 5, 10) ; ptr[ 1 ].Move ( 15, 20); //或者这种形式也可以 //ptr -\u003e Move ( 5, 10) ; //( ptr + 1) -\u003e Move ( 15, 20); delete [ ] ptr; //删除整个对象数组 }; //运行结果如下： //Default constructor call. //Default constructor call. //Destructor call. //Destructor call. 注意： 如果是用 new 建立的数组， 用 delete 删除时必须在指针名前面加 “ [ ]” 指向多维数组的指针和指针变量 通过指针引用多维数组_多维数组指针 ","date":"2024-04-20","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A16%E4%B8%8B/:1:2","tags":["面向对象程序设计"],"title":"c++(six_2)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A16%E4%B8%8B/"},{"categories":["面向对象程序设计"],"content":"使用vector创建数组对象 vector定义动态数组的格式: vector \u003c元素类型\u003e 数组名(数组长度[，元素初值]); 注意 用vector 创建的数组对象都会被初始化，如果是基本数据类型，则要会被0初始化，如果是类类型，则要调用类的默认构造函数，这时就要保证类中一定要有默认构造函数，当然用户也可以自己为它赋值，但赋的初值都是一样的。 数组名不是首地址 访问方式与普通数组的方式一样 例： #include \u003ciostream\u003e #include \u003cvector\u003e using namespace std; //计算数组arr中元素的平均值 double average(const vector\u003cdouble\u003e \u0026arr) { double sum = 0; for (unsigned i = 0; i \u003c arr.size(); i++) sum += arr[i]; return sum / arr.size(); } int main() { unsigned n;cout \u003c\u003c \"n = \";cin \u003e\u003e n; vector\u003cdouble\u003e arr(n); //创建数组对象 cout \u003c\u003c \"Please input \" \u003c\u003c n \u003c\u003c \" real numbers:\" \u003c\u003c endl; for (unsigned i = 0; i \u003c n; i++) cin \u003e\u003e arr[i]; cout \u003c\u003c \"Average = \" \u003c\u003c average(arr) \u003c\u003c endl; return 0;} ","date":"2024-04-20","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A16%E4%B8%8B/:2:0","tags":["面向对象程序设计"],"title":"c++(six_2)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A16%E4%B8%8B/"},{"categories":["面向对象程序设计"],"content":"深复制与浅复制 ","date":"2024-04-20","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A16%E4%B8%8B/:3:0","tags":["面向对象程序设计"],"title":"c++(six_2)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A16%E4%B8%8B/"},{"categories":["面向对象程序设计"],"content":"无错误的浅拷贝 先看一个简单的例子，该例子是浅拷贝的典型代表，而且没有问题。 接下来看Example 1 Cperson.h #ifndef _CPERSON_H #define _CPERSON_H class Cperson { public: Cperson(int age); void Print(void); private: int m_age; }; #endif Cperson.cpp #include\"Cperson.h\" #include\u003ciostream.h\u003e Cperson::Cperson(int age):m_age(age) { } void Cperson::Print(void) { cout\u003c\u003c\"My age is \"\u003c\u003cm_age\u003c\u003cendl; } Main.cpp #include\"Cperson.h\" #include\u003ciostream.h\u003e void main(void) { Cperson Tom(10); Tom.Print(); Cperson Jim(Tom); Jim.Print(); } 结果 结果分析 对于语句Cperson Jim(Tom)，我们并没有定义相应的拷贝构造函数，编译器将会自动生成一个默认的拷贝构造函数 默认拷贝构造函数所做的工作是，将一个对象的全部数据成员赋值给另一个对象的数据成员 C++只把对象数据成员简单赋值这种情况称为“浅拷贝” 听起来，编译器似乎很好，会提供一个我们没有定义的拷贝构造函数 ","date":"2024-04-20","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A16%E4%B8%8B/:3:1","tags":["面向对象程序设计"],"title":"c++(six_2)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A16%E4%B8%8B/"},{"categories":["面向对象程序设计"],"content":"有错误的浅拷贝 在接下来的Example 2中，我们将看到浅拷贝带来的错误 Cperson.h #ifndef _CPERSON_H #define _CPERSON_H class Cperson { public: Cperson(int age,char *name); ~Cperson(); void Print(void); private: int m_age; char *m_name; }; #endif Cperson.cpp #include\"Cperson.h\" #include\u003ciostream.h\u003e #include\u003cstring.h\u003e Cperson::Cperson(int age,char *name) { m_name = new char[strlen(name) + 1]; if(m_name != NULL) { strcpy(m_name,name); } m_age = age; cout\u003c\u003cm_name\u003c\u003c\"的构造函数\"\u003c\u003cendl; } Cperson::~Cperson() { cout\u003c\u003c\"析构姓名:\"\u003c\u003cm_name\u003c\u003cendl; if(m_name != NULL) { delete m_name; } } void Cperson::Print(void) { cout\u003c\u003c\"My age is \"\u003c\u003cm_age\u003c\u003c\",My name is \"\u003c\u003cm_name\u003c\u003cendl; } Main.cpp #include\"Cperson.h\" #include\u003ciostream.h\u003e void main(void) { Cperson Tom(10,\"Tom\"); Tom.Print(); Cperson Jim(Tom); Jim.Print(); } 结果 结果分析 可以看到，程序出现了错误 在执行语句Cperson Tom(10,“Tom”)时，用new动态开辟了一段内存，用来存放”Tom” 在执行Cperson Jim(Tom)时，只是将Tom的成员（Tom.m_age，Tom.m_name）赋值给Jim相应的成员 此时，Tom.m_name和Jim.m_name指向同一内存空间，然而，系统并没给Jim.m_name开辟相应的内存空间 执行完Jim.Print()后，开始执行析构函数，析构函数的执行顺序和对象构造函数的执行顺序相反，所以先执行Jim的析构函数，执行完Jim的析构函数后，Jim.m_name所指的内存空间已经释放 接着执行Tom的析构函数，此时就会出现问题，即在释放Tom.m_name所指的内存空间时会出现问题，因为这段内存空间在Jim的析构函数中已经释放过了 出现这种原因的根本在于“浅拷贝”，所以需要定义自己的构造函数。 ","date":"2024-04-20","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A16%E4%B8%8B/:3:2","tags":["面向对象程序设计"],"title":"c++(six_2)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A16%E4%B8%8B/"},{"categories":["面向对象程序设计"],"content":"深拷贝 接下来看Example 3，在该例子中执行深拷贝 Cperson.h #ifndef _CPERSON_H #define _CPERSON_H class Cperson { public: Cperson(int age,char *name); Cperson(Cperson \u0026 per); ~Cperson(); void Print(void); private: int m_age; char *m_name; }; #endif Cperson.cpp #include\"Cperson.h\" #include\u003ciostream.h\u003e #include\u003cstring.h\u003e Cperson::Cperson(int age,char *name) { m_name = new char[strlen(name) + 1]; if(m_name != NULL) { strcpy(m_name,name); } m_age = age; cout\u003c\u003cm_name\u003c\u003c\"的构造函数\"\u003c\u003cendl; } Cperson::Cperson(Cperson \u0026 per) { m_name = new char[strlen(per.m_name) + 1]; if(m_name != NULL) { strcpy(m_name,per.m_name); } m_age = per.m_age; cout\u003c\u003cm_name\u003c\u003c\"的拷贝构造函数\"\u003c\u003cendl; } Cperson::~Cperson() { cout\u003c\u003c\"析构姓名:\"\u003c\u003cm_name\u003c\u003cendl; if(m_name != NULL) { delete m_name; } } void Cperson::Print(void) { cout\u003c\u003c\"My age is \"\u003c\u003cm_age\u003c\u003c\",My name is \"\u003c\u003cm_name\u003c\u003cendl; } Main.cpp #include\"Cperson.h\" #include\u003ciostream.h\u003e void main(void) { Cperson Tom(10,\"Tom\"); Tom.Print(); Cperson Jim(Tom); Jim.Print(); } 结果： 结果分析 可以看到，自己定义了拷贝构造函数后，就没有问题了 ","date":"2024-04-20","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A16%E4%B8%8B/:3:3","tags":["面向对象程序设计"],"title":"c++(six_2)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A16%E4%B8%8B/"},{"categories":["面向对象程序设计"],"content":"浅拷贝和深拷贝 深拷贝和浅拷贝可以简单理解为：如果一个类拥有资源，当这个类的对象发生复制过程的时候，资源重新分配，这个过程就是深拷贝，反之，没有重新分配资源，就是浅拷贝 在实际中应该避免浅拷贝 例: 对象的浅拷贝 #include \u003ciostream\u003e #include \u003ccassert\u003e using namespace std; class Point { //类的声明同例6-16 //…… }; class ArrayOfPoints { //类的声明同例6-18 //…… }; int main() { int count; cout \u003c\u003c \"Please enter the count of points: \"; cin \u003e\u003e count; ArrayOfPoints pointsArray1(count); //创建对象数组 pointsArray1.element(0).move(5,10); pointsArray1.element(1).move(15,20); ArrayOfPoints pointsArray2(pointsArray1); //创建副本 cout \u003c\u003c \"Copy of pointsArray1:\" \u003c\u003c endl; cout \u003c\u003c \"Point_0 of array2: \" \u003c\u003c pointsArray2.element(0).getX() \u003c\u003c \", \"\u003c\u003c pointsArray2.element(0).getY() \u003c\u003c endl; cout \u003c\u003c \"Point_1 of array2: \" \u003c\u003c pointsArray2.element(1).getX() \u003c\u003c \", \"\u003c\u003c pointsArray2.element(1).getY() \u003c\u003c endl; pointsArray1.element(0).move(25, 30); pointsArray1.element(1).move(35, 40); cout \u003c\u003c \"After the moving of pointsArray1:\" \u003c\u003c endl; cout \u003c\u003c \"Point_0 of array2: \" \u003c\u003c pointsArray2.element(0).getX() \u003c\u003c \", \"\u003c\u003c pointsArray2.element(0).getY() \u003c\u003c endl; cout \u003c\u003c \"Point_1 of array2: \" \u003c\u003c pointsArray2.element(1).getX() \u003c\u003c \", \"\u003c\u003c pointsArray2.element(1).getY() \u003c\u003c endl; return 0; } //运行结果如下： //Please enter the number of points:2 //Default Constructor called. //Default Constructor called. //Copy of pointsArray1: //Point_0 of array2: 5, 10 //Point_1 of array2: 15, 20 //After the moving of pointsArray1: //Point_0 of array2: 25, 30 Point_1 of array2: 35, 40 Deleting... Destructor called. Destructor called. Deleting... //接下来程序出现异常，也就是运行错误 例: 对象的深拷贝 #include \u003ciostream\u003e #include \u003ccassert\u003e using namespace std; class Point { //类的声明同例6-16 …… }; class ArrayOfPoints { public: ArrayOfPoints(const ArrayOfPoints\u0026 pointsArray); //其他成员同例6-18 }; ArrayOfPoints::ArrayOfPoints(const ArrayOfPoints\u0026 v) { size = v.size; points = new Point[size]; for (int i = 0; i \u003c size; i++) points[i] = v.points[i]; } int main() { //同例6-20 } //程序的运行结果如下： //Please enter the number of points:2 //Default Constructor called. //Default Constructor called. //Default Constructor called. //Default Constructor called. //Copy of pointsArray1: //Point_0 of array2: 5, 10 //Point_1 of array2: 15, 20 //After the moving of pointsArray1: //Point_0 of array2: 5, 10 //Point_1 of array2: 15, 20 //Deleting... //Destructor called. //Destructor called. //Deleting... ","date":"2024-04-20","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A16%E4%B8%8B/:3:4","tags":["面向对象程序设计"],"title":"c++(six_2)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A16%E4%B8%8B/"},{"categories":["面向对象程序设计"],"content":"字符串 ","date":"2024-04-20","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A16%E4%B8%8B/:4:0","tags":["面向对象程序设计"],"title":"c++(six_2)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A16%E4%B8%8B/"},{"categories":["面向对象程序设计"],"content":"用字符数组存储和处理字符串 字符串常量（例：“program”） 各字符连续、顺序存放，每个字符占一个字节，以‘\\0’结尾，相当于一个隐含创建的字符常量数组 “program”出现在表达式中，表示这一char数组的首地址 首地址可以赋给char常量指针： const char *STRING1 = “program”; 字符串变量 可以显式创建字符数组来表示字符串变量，例如，以下三条语句具有等价的作用 char str[8] = { ‘p’, ‘r’, ‘o’, ‘g’, ‘r’, ‘a’, ’m’, ‘\\0’ }; char str[8] = “program”; char str[] = “program”; 用字符数组表示字符串的缺点 用字符数组表示字符串的缺点 执行连接、拷贝、比较等操作，都需要显式调用库函数，很麻烦 当字符串长度很不确定时，需要用new动态创建字符数组，最后要用delete释放，很繁琐 字符串实际长度大于为它分配的空间时，会产生数组下标越界的错误 解决方法 使用字符串类string表示字符串 string实际上是对字符数组操作的封装 类string在string头文件中 ","date":"2024-04-20","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A16%E4%B8%8B/:4:1","tags":["面向对象程序设计"],"title":"c++(six_2)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A16%E4%B8%8B/"},{"categories":["面向对象程序设计"],"content":"string类 常用构造函数 string(); //缺省构造函数，建立一个长度为0的串 string(const char *s); //用指针s所指向的字符串常量初始化string类的对象 string(const string\u0026 rhs); //拷贝构造函数 string(const char *s，unsigned int n); //用指针s所指向的字符串前n个字符去初始化string类的对象 String(unsigned int n, char c);//将参数c中的 字符重复n次去初始化string类的对象。 string(const string\u0026 rhs， unsigned int pos， unsigned int n);//将rhs字符串从pos位置开始取n个字符去初始化string类的对象 例： string s1; //建立一个空字符串 string s2 = “abc”; //用常量建立一个初值为”abc”的字符串 string s3 = s2;//执行拷贝构造函数，用s2的值作为s3的初值 常用操作符 s + t //将串s和t连接成一个新串 s = t //用t更新s s == t //判断s与t是否相等 s != t //判断s与t是否不等 s \u003c t //判断s是否小于t（按字典顺序比较） s \u003c= t //判断s是否小于或等于t （按字典顺序比较） s \u003e t //判断s是否大于t （按字典顺序比较） s \u003e= t //判断s是否大于或等于t （按字典顺序比较） s[i] //访问串中下标为i的字符 例： string s1 = \"abc\", s2 = \"def\"; string s3 = s1 + s2; //结果是\"abcdef\" bool s4 = (s1 \u003c s2); //结果是true char s5 = s2[1]; //结果是'e' 例: string类应用举例 #include \u003cstring\u003e #include \u003ciostream\u003e using namespace std; //根据value的值输出true或false，title为提示文字 void test(const char *title, bool value) { cout \u003c\u003c title \u003c\u003c \" returns \" \u003c\u003c (value ? \"true\" : \"false\") \u003c\u003c endl; } int main() { string s1 = \"DEF\"; cout \u003c\u003c \"s1 is \" \u003c\u003c s1 \u003c\u003c endl; string s2; cout \u003c\u003c \"Please enter s2: \"; cin \u003e\u003e s2; cout \u003c\u003c \"length of s2: \" \u003c\u003c s2.length() \u003c\u003c endl; //比较运算符的测试 test(\"s1 \u003c= \\\"ABC\\\"\", s1 \u003c= \"ABC\"); test(\"\\\"DEF\\\" \u003c= s1\", \"DEF\" \u003c= s1); //连接运算符的测试 s2 += s1; cout \u003c\u003c \"s2 = s2 + s1: \" \u003c\u003c s2 \u003c\u003c endl; cout \u003c\u003c \"length of s2: \" \u003c\u003c s2.length() \u003c\u003c endl; return 0; } 用getline输入整行字符串 输入整行字符串 用cin的»操作符输入字符串，会以空格作为分隔符，空格后的内容会在下一回输入时被读取 用string头文件中的getline可以输入整行字符串，例如： getline(cin, s2); 以其它字符作为分隔符输入字符串 输入字符串时，可以使用其它分隔符作为字符串结束的标志（例如逗号、分号） 把分隔符作为getline的第3个参数即可，例如： getline(cin, s2, ','); 例: 用getline输入字符串 include \u003ciostream\u003e #include \u003cstring\u003e using namespace std; int main() { for (int i = 0; i \u003c 2; i++) { string city, state; getline(cin, city, ','); getline(cin, state); cout \u003c\u003c \"City:\" \u003c\u003c city \u003c\u003c “ State:\" \u003c\u003c state \u003c\u003c endl; } return 0; } //运行结果： //Beijing,China //City: Beijing State: China //San Francisco,the United States //City: San Francisco State: the United 字符串常用成员函数 字符串常用成员函数 ","date":"2024-04-20","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A16%E4%B8%8B/:4:2","tags":["面向对象程序设计"],"title":"c++(six_2)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A16%E4%B8%8B/"},{"categories":["面向对象程序设计"],"content":"数组 指针与字符串 ","date":"2024-04-18","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A16%E4%B8%8A/:0:0","tags":["面向对象程序设计"],"title":"c++(six_1)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A16%E4%B8%8A/"},{"categories":["面向对象程序设计"],"content":"数组 数组的概念 数组是具有一定顺序关系的若干相同类型变量的集合体(数组可以由除void型以外的任何类型构成），组成数组的变量称为该数组的元素。 数组属于构造类型 注意: 声明一个数组,应该包括以下几个方面 确定数组的名称； 确定数组元素的类型； 确定数组的结构（包括数组维数，每一位的大小等）。 ","date":"2024-04-18","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A16%E4%B8%8A/:1:0","tags":["面向对象程序设计"],"title":"c++(six_1)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A16%E4%B8%8A/"},{"categories":["面向对象程序设计"],"content":"数组的说明与使用 一维数组的声明与引用 一维数组的声明 类型说明符 数组名[ 常量表达式 ]； 数组名的构成方法与一般变量名相同。 例如： int a[10]; 表示 a 为整型数组,有10个元素：a[0]…a[9] 注意：常量表达式其值必须是正整数。 引用 必须先声明，后使用。 只能逐个引用数组元素，而不能一次引用整个数组（除传地址） 例如：a[0]=a[5]+a[7]-a[2*3] 例： 一维数组的声明与引用 #include \u003ciostream.h\u003e void main（ ） { int A[10],B[10]; int i; for(i=0;i\u003c10;i++) { A[i]=i*2-1; B[10-i-1]=A[i]; } for(i=0;i\u003c10;i++) { cout\u003c\u003c\"A[\"\u003c\u003ci \u003c\u003c\"]=\"\u003c\u003cA[i]; cout\u003c\u003c\" B[\"\u003c\u003ci \u003c\u003c\"]=\" \u003c\u003cB[i]\u003c\u003cendl; } } 注意: 如果数组越界,运行时有时会得到提示,但有时却得不到任何提示,不可预期的结果会悄悄发生 数组元素的下标表达式可以是任意合法的算术表达式，其结果必须是整数 ","date":"2024-04-18","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A16%E4%B8%8A/:1:1","tags":["面向对象程序设计"],"title":"c++(six_1)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A16%E4%B8%8A/"},{"categories":["面向对象程序设计"],"content":"数组的存储和初始化 一维数组的存储顺序 数组元素在内存中连续顺次存放，它们的地址是连续的。 例如：具有10个元素的数组 a，在内存中的存放次序如下： a:数组名字是数组首元素的内存地址。数组名是一个常量，不能被赋值。 一维数组的初始化 可以在编译阶段使数组得到初值： 在声明数组时对数组元素赋以初值。 例如： int a[10]={0,1,2,3,4,5,6,7,8,9}; 可以只给一部分元素赋初值 例如： int a[10]={0,1,2,3,4}; 在对全部数组元素赋初值时，可以不指定数组长度 例如： int a[ ]={1,2,3,4,5} 数组也可以声明为常量. const float a[5]={1.0,2.0}; 下面的代码对数组进行初始化是错误的： int array1[5]={ 1,2,3,4,5,6}; //error：初始化值个数多于数组元素个数 int array2[5] = {1,,2,3,4} ; //error：初始化值不能省略中间 int array3[5] = {, ,1,2,3}; //error：初始化值不能省略前面 void main( ) { //…… } 例 ：用数组来处理求Fibonacci数列问题 main( ) { int i; static int f[20]={1,1};/*初始化第0、1个数*/\u000bfor(i=2;i\u003c20;i++) f[i]=f[i-2]+f[i-1]; /*求第2~19个数*/ for(i=0;i\u003c20;i++) /*输出，每行5个数*/ { if(i%5==0) cout\u003c\u003cendl; cout\u003c\u003cf[i]; } } //输出结果： //1 1 2 3 5 //8 13 21 34 55 //89 144 233 377 610 //987 1597 2584 4181 6765 多维数组的声明及引用 数据类型 标识符[常量表达式1][常量表达式2] …; 例: int a[5][3]; 表示a为整型二维数组，其中第一维有5个下标(0~4)，第二维有3个下标(0~2)，数组的元素个数为15，可以用于存放5行3列的整型数据表格。 二维数组的声明及引用 二维数组的声明 类型说明符 数组名[常量表达式][常量表达式]; 例如：float a[3][4]; 引用 例如：b[1][2]=a[2][3]/2 注意：下标不要越界 存储顺序 在内存中按行存放，即行优先存储。 多二维数组的声明 int a [ 2 ] [ 3 ][4];声明一个三维数组 二维数组的初始化 将所有数据写在一个{}内，按顺序赋值(如果是基本数据类型的数组，初始化过程就是给数组元素赋值，对于对象数组，每一个元素都是一个类的实例，将调用类的构造函数） 例如: static int a[3][4]={1,2,3,4,5,6,7,8,9,10,11,12}; 可以对部分元素赋初值 例如： static int a[3][4]={{1},{0,6},{0,0,1,1}}; 如果给出全部元素的初值，第一维的下标个数可以不用显示说明 static int a[2][3]={1 , 0 , 0 , 0 , 1 , 0}; //或 static int a[ ][3]={1 , 0 , 0 , 0 , 1 , 0}; 例： # include\u003ciostream.h\u003e void main() { static int a[3][4]={{1,2,3,4},{5,6,7,8},{9,10,11,12}}; static int b[3][4]={1,2,3,4,5,6,7,8,9,10,11,12}; static int c[3][4] = {{1},{0,6},{0,0,1,1}}; static int d[3][4] = {1,0,6,0,0,1,1}; int i,j; for (i=0;i\u003c3;i++) for (j =0;j\u003c4;j++) cout\u003c\u003ca[i][j]\u003c\u003c\" \"; cout\u003c\u003cendl; for (i=0;i\u003c3;i++) for (j =0;j\u003c4;j++) cout\u003c\u003cb[i][j]\u003c\u003c\" \"; cout\u003c\u003cendl; for (i=0;i\u003c3;i++) for (j =0;j\u003c4;j++) cout\u003c\u003cc[i][j]\u003c\u003c\" \"; cout\u003c\u003cendl; for (i=0;i\u003c3;i++) for (j =0;j\u003c4;j++) cout\u003c\u003cd[i][j]\u003c\u003c\" \"; cout\u003c\u003cendl; } 运行结果 ","date":"2024-04-18","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A16%E4%B8%8A/:1:2","tags":["面向对象程序设计"],"title":"c++(six_1)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A16%E4%B8%8A/"},{"categories":["面向对象程序设计"],"content":"数组作为函数参数 数组元素作实参，与单个变量一样。 无论何时，将数组名作为参数传给函数，实际上只是把数组的地址传给函数。 数组名作参数，形、实参数都应是数组名，类型要一样，传送的是数组首地址。**因此实参数组的元素个数不应少于形参数组的元素个数。**对形参数组的改变会直接影响到实参数组。 数组元素作为函数参数 数组元素作为实参，和变量作为实参一样，是单向的值传递方式 int isalp (char c ) { if (c\u003e='a'\u0026\u0026c\u003c='z'||c\u003e='A'\u0026\u0026c\u003c='Z') return(1); else return(0); } void main( ) { int i, num = 0; char str[5] = { ‘c’, ‘h’, ‘0’, ‘n’, ‘5’}; for( i = 0; i \u003c 5; i++ ) if ( isalp ( str[i] ) ) num++; cout \u003c\u003c \"num=“ \u003c\u003c num; } 数组名作为函数参数 应该在主调函数和被调函数中分别定义数组，不能只在一方定义。 实参数组和形参数组类型一致。 形参数组的第一维大小不起任何作用，即使指定，也会被忽略，只是将实参数组的首地址传递给形参数组。 float average ( float array [10] ) { int i; float aver, sum = array [0]; for ( i = 1; i \u003c 10; i ++) sum = sum + array [ i ]; aver = sum /10; return aver; } void main ( ) { float score [10], aver; int i ; for ( i = 0; i \u003c 10; i ++) cin \u003e\u003e score [ i ]; aver = average ( score ); cout \u003c\u003c “average score” \u003c\u003c aver ; } 数组名作为函数参数 形参数组可以不指定大小，后面跟一个空的方括号。有时为了在被调函数中处理数组元素的需要，可以另设一个参数，传递需要处理的数组元素的个数。 float average ( float array [ ], int n ) { int i; float aver, sum = array [0]; for ( i = 1; i \u003c n; i ++) sum = sum + array [ i ]; aver = sum / n; return aver; } void main ( ) { float score_1 [5] = { 98.5,97,91.5,60,55}; float score_2[10] = {67.5,89.5,99,69.5,77,76.5,54,60,95.5,78}; cout \u003c\u003c average ( score_1, 5) ; cout \u003c\u003c average ( score_2, 10) ; } 数组名作为函数参数 数组名作为实参，不是把数组的值传递给形参，而是把实参数组的起始地址传递给形参数组，两个数组共占同一段内存单元。 void sort ( int b[ ] , int n ) { . . . } void main ( ) { int a [10]; . . . sort ( a, 10 ); . . . } 假设 a 的起始地址为1000，则 b 数组的起始地址也是 1000，显然 a 和 b 同占一段内存单元。 形参数组中各元素的值的变化会使实参数组元素的值同时发生变化。 在程序设计中有意识地利用这一点改变实参数组元素的值 （如 排序）。 数组名作为函数参数 数组名作为实参,不是把数组的值传递给形参,而是把实参数组的起始地址传递给形参数组,两个数组共占同一段内存单元。 主函数中初始化一个矩阵并将每个元素都输出，然后调用子函数，分别计算每一行的元素之和，将和直接存放在每行的第一个元素中，返回主函数之后输出各行元素的和 例: 使用数组名作为函数参数 #include \u003ciostream.h\u003e void RowSum(int A[ ][4], int nrow) { for (int i = 0; i \u003c nrow; i++) { for(int j = 0; j \u003c 4; j++) A[i][0] += A[i][j]; } } void main(void) { int Table[3][4] ={{1,2,3,4},{2,3,4,5},{3,4,5,6}}; for (int i = 0; i \u003c 3; i++) { for (int j = 0; j \u003c 4; j++) cout \u003c\u003c Table[i][j] \u003c\u003c \" \"; cout \u003c\u003c endl; } RowSum(Table,3); for (i = 0 ; i \u003c 3 ; i ++) { cout\u003c\u003c“Sum of row”\u003c\u003ci\u003c\u003c“is”\u003c\u003cTable[i][0]\u003c\u003cendl; } } //或： #include \u003ciostream.h\u003e void RowSum(int A[ ][4], int nrow) { int sum; for (int i = 0; i \u003c nrow; i++) { sum = 0; for(int j = 0; j \u003c 4; j++) sum += A[i][j]; cout \u003c\u003c \"Sum of row \" \u003c\u003c i\u003c\u003c \" is \" \u003c\u003c sum \u003c\u003c endl; } } void main(void) { int Table[3][4] = {{1,2,3,4},{2,3,4,5},{3,4,5,6}}; for (int i = 0; i \u003c 3; i++) { for (int j = 0; j \u003c 4; j++) cout \u003c\u003c Table[i][j] \u003c\u003c \" \"; cout \u003c\u003c endl; } RowSum(Table,3); } //运行结果： //1 2 3 4 //2 3 4 5 //3 4 5 6 //Sum of row 0 is 10 //Sum of row 1 is 14 //Sum of row 2 is 18 ","date":"2024-04-18","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A16%E4%B8%8A/:1:3","tags":["面向对象程序设计"],"title":"c++(six_1)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A16%E4%B8%8A/"},{"categories":["面向对象程序设计"],"content":"插入排序法( insert sort ) 插入排序法是一个简单，但相对比较高效的排序算法。 设置思想 插入排序通过把数组中的元素插入到适当的位置来进行排序。 步骤 将数组中的头两个元素按排序顺序排列 把下一个元素(第3个)插入到其对应于已排序元素的排序位置。 对于数组中的每个元素重复(2)。即把第四个元素插入到适当位置，然后是第5个元素，等。 例：待排序数据元素序列的排序码序列是(18,12,10,12,30,16)，写出简单插入排序每一趟执行后的序列状态。 # include \u003ciostream.h\u003e void isort(int * a , int size); void main( ) { int array[] = {18,12,10,12,30,16}; int size = 6; for (int i =0 ;i\u003csize;i++) //原始顺序输出 cout\u003c\u003ca[i]\u003c\u003c“,”; cout \u003c\u003c endl \u003c\u003c endl; int len = sizeof(array)/sizeof(int); //元素个数 isort( array,len); //调用排序函数 } void isort( int a[ ] ,int size) //插入排序 { int inserter,index ; for (int i =1 ;i \u003csize ; i ++ ) //共执行size-1轮 { inserter = a[i]; index = i – 1; while(index\u003e=0 \u0026\u0026 inserter\u003ca[index]) //寻找插入点 { a[index+1] = a[index]; //后挪一个位置 index - - ; } a[index+1] = inserter ; //插入 for (int j = 0 ; j \u003c size ; j++) //比较一轮后就输出 { cout \u003c\u003c a[j] \u003c\u003c“,”; if (j == i ) //已排序与未排序的分界线 cout \u003c\u003c‘|’; } cout \u003c\u003c endl ; } } //运行结果 //18,12,10,12,30,16, //12,18,|10,12,30,16, //10,12,18,|12,30,16, //10,12,12,18,|30,16, //10,12,12,18,30,|16, //10,12,12,16,18,30,| ","date":"2024-04-18","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A16%E4%B8%8A/:1:4","tags":["面向对象程序设计"],"title":"c++(six_1)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A16%E4%B8%8A/"},{"categories":["面向对象程序设计"],"content":"对象数组 声明： 类名 数组名[元素个数]； 访问方法： 通过下标访问 数组名[下标].成员名 对象数组初始化 数组中每一个元素对象被创建时，系统都会调用类构造函数初始化该对象。 通过初始化列表赋值。 例： Point A[2]={ Point(1,2), Point(3,4) }; 如果没有为数组元素指定显式初始值，数组元素便使用缺省值初始化（调用缺省构造函数） ","date":"2024-04-18","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A16%E4%B8%8A/:1:5","tags":["面向对象程序设计"],"title":"c++(six_1)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A16%E4%B8%8A/"},{"categories":["面向对象程序设计"],"content":"数组元素所属类的构造函数 不声明构造函数，则采用缺省构造函数 各元素对象的初值要求为相同的值时，可以声明具有缺省形参值的构造函数 各元素对象的初值要求为不同的值时，需要声明带形参(无缺省值)的构造函数 当数组中每一个对象被删除时，系统都要调用一次析构函数。 例：对象数组应用举例 //Location.h #if !defined(_LOCATION_H) #define _LOCATION_H class Location { public: Location（ ）; Location(int xx,int yy); ~Location（ ）; void Move(int x,int y); int GetX（ ） {return X;} int GetY（ ） {return Y;} private: int X,Y; }; #endif //Location.cpp #include\u003ciostream.h\u003e #include \"Location.h\" Location::Location（ ） { X=Y=0; cout\u003c\u003c\"Default Constructor called.\"\u003c\u003cendl; } Location::Location(int xx,int yy) { X=xx; Y=yy; cout\u003c\u003c \"Constructor called.\"\u003c\u003cendl; } Locatuon::~Location（ ） { cout\u003c\u003c\"Destructor called.\"\u003c\u003cendl; } void Location::Move(int x,int y) { X=x; Y=y; } #include\u003ciostream.h\u003e #include \"Location.h\" int main（ ） { cout\u003c\u003c\"Entering main...\"\u003c\u003cendl; Location A[2]; //定义一个对象数组 for(int i=0;i\u003c2;i++) A[i].Move(i+10,i+20); cout\u003c\u003c\"Exiting main...\"\u003c\u003cendl; return 0; } //Location A[2]＝{Location(1,2),Location(3,4)}; //就调有参构造函数 //运行结果： //Entering main... //Default Constructor called. //Default Constructor called. //Exiting main... //Destructor called. //Destructor called. ","date":"2024-04-18","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A16%E4%B8%8A/:1:6","tags":["面向对象程序设计"],"title":"c++(six_1)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A16%E4%B8%8A/"},{"categories":["面向对象程序设计"],"content":"指针（关于内存地址） ","date":"2024-04-18","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A16%E4%B8%8A/:2:0","tags":["面向对象程序设计"],"title":"c++(six_1)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A16%E4%B8%8A/"},{"categories":["面向对象程序设计"],"content":"内存空间的访问方式 地址编码 存储单元的地址 基本内存单元 从内存单元存取数据的方法 通过变量名访问 通过地址访问 ","date":"2024-04-18","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A16%E4%B8%8A/:2:1","tags":["面向对象程序设计"],"title":"c++(six_1)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A16%E4%B8%8A/"},{"categories":["面向对象程序设计"],"content":"指针变量的概念 指针和指针变量　的概念 指针： 在C和C++中，将地址形象化地称为“指针”。一个变量的地址称为该变量的 “ 指针 ” 指针变量： 专门用来存放地址的变量叫做 “ 指针变量 ” ","date":"2024-04-18","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A16%E4%B8%8A/:2:2","tags":["面向对象程序设计"],"title":"c++(six_1)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A16%E4%B8%8A/"},{"categories":["面向对象程序设计"],"content":"指针变量的应用 指针变量应用的步骤： 声明指针变量 给指针变量赋值 引用指针变量 ","date":"2024-04-18","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A16%E4%B8%8A/:2:3","tags":["面向对象程序设计"],"title":"c++(six_1)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A16%E4%B8%8A/"},{"categories":["面向对象程序设计"],"content":"指针变量的定义与应用 指针变量的声明 定义指针变量的一般形式为：　数据类型 * 指针变量名 例如： int *pointer_1 ; float *pointer_2 ; 指针变量前面的 “ * ”，表示该变量的类型为指针型变量。 “数据类型”可以是任意类型，用来指定该指针变量所指向的变量的类型，称之为指针的类型。 例如： 指针变量 pointer_1 用来存放指向 int 型变量的指针 pointer_2存放指向 float 型变量的指针 。 指针变量的赋值 声明一个指针变量，分为全局和局部，**全局未赋值时其中的地址值是0。局部未赋值时其中的地址值是一个随机的数。**因此声明指针变量之后最好先赋值后使用。 声明时同时初始化： 数据类型 *指针变量名 = 地址； 使用赋值语句赋值： 数据类型 *指针变量； 指针变量 = 地址； ","date":"2024-04-18","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A16%E4%B8%8A/:2:4","tags":["面向对象程序设计"],"title":"c++(six_1)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A16%E4%B8%8A/"},{"categories":["面向对象程序设计"],"content":"指针变量的赋值 “\u0026”是取地址运算符，用来获取一个变量的地址。将获取的变量的地址赋值给指针变量。 不能把普通非 0 整数赋值给指针变量。 int *p=(int *)100; int i; int *pointer_1=\u0026i; int i , * pointer_1; pointer_1 = \u0026 i ; //将变量 i 的地址存放到指针变量pointer_1 中，因此pointer_1 就“指向”了变量 i 指针变量的赋值 使用变量地址赋值时，该变量必须在赋值之前已声明过，且变量类型应与指针类型一致 可以用一个已赋值的指针变量去赋值给另一 个指针变量 数组名代表数组的起始地址，可以将数组名表示的地址赋值给指针变量 //正确 int i , * p1, *p2; p1 = \u0026 i; p2 = p1; int array [10] , * p1; p1 = array; //错误，类型不一致 float f; int *p; p = \u0026 f; #include \u003ciostream\u003e using namespace std; int main() { int i; //定义int型数i int *ptr = \u0026i; //取i的地址赋给ptr i = 10; //int型数赋初值 cout \u003c\u003c \"i = \" \u003c\u003c i \u003c\u003c endl;//输出int型数的值 //输出int型指针所指地址的内容 cout \u003c\u003c \"*ptr = \" \u003c\u003c *ptr \u003c\u003c endl; return 0; } 一般情况下，一种类型的指针变量只能存放相同类型的变量的地址 特殊的void 类型的指针，可以存放任何类型的变量的地址。经过类型强制转换，void 类型的指针可以访问任何类型的数据 void *p1; int i, *p2; p1 = \u0026 i; p2 = ( int * ) p1; //可以访问任何类型的数据 #include \u003ciostream\u003e using namespace std; int main() { //! void voidObject; //错，不能声明void类型的变量 void *pv; //对，可以声明void类型的指针 int i = 5; pv = \u0026i; //void类型指针指向整型变量 //void类型指针赋值给int类型指针 int *pint = static_cast\u003cint *\u003e(pv); cout \u003c\u003c \"*pint = \" \u003c\u003c *pint \u003c\u003c endl; return 0; } 指针忘了赋值比整型变量忘了赋值危险得多 例： int count; int *iPtr ; *iPtr = 58; //指针没有赋值这样非常危险 iPtr当前指向什么地方？该代码能通过编译，但没有赋初值的指针iPtr是一个随机地址 “*iPtr = 58;”是把58赋到内存中的随机位置，因此很可能已经破坏了另一变量，甚至修改了栈中的函数返回地址，计算机将死机或进入死循环。 指针变量的引用 注意：“ * ”出现在声明语句中和执行语句中含义不同。 “ * ”是指针运算符，表示指针所指向的变量。 int i , *p; p = \u0026i; p 是指针变量，* p 就是 p 所指向的变量 i , 即 *p 等价于 变量 i 。 i = 2; /* 通过变量名直接访问 */ *p = 3; /* *p是 p 所指向的变量，即变量 i ，这是通过指针的间接访问*/ “ * ”出现在声明语句中，表示声明的变量是指针变量。 //例如： int *p; “ * ”出现在执行语句中，表示访问指针所指向的变量。 //例如： *p = 3; printf ( “%d \\n”, *p ); 例： int i　= 26; int *P = \u0026i; //初始化为整型地址 *P = \u0026i; //error **不能将“int P = \u0026i ; ”与“P = \u0026i ; ”混淆 前者是定义语句，*是指针定义符，C++为P指针分配一个指针空间，并用i 的地址值初始化，后者是执行语句，左右两边类型不匹配。 *操作符在指针上的两种用途要区分开：定义或声明时，建立一个指针；执行时，间接引用一指针。 也要注意： ”\u0026”出现在声明语句中和执行语句中其含义是不同的； 例： int i , *p; int \u0026rf = i; //表示声明的是引用 p = \u0026i; //取地址 例: 指针的声明、赋值与使用 #include\u003ciostream.h\u003e void main（ ） { int *i_pointer; //声明int型指针i_pointer int i; //声明int型数i i_pointer=\u0026i; //取i的地址赋给i_pointer i=10; //int型数赋初值 cout\u003c\u003c“Output int i=”\u003c\u003ci\u003c\u003cendl; //输出int型数的值 cout\u003c\u003c\"Output int pointer i=\"\u003c\u003c*i_pointer\u003c\u003cendl;//输出int型指针所指地址的内容} 指针变量的地址 指针也是变量，是变量就具有内存地址。所以指针也有地址。 例：下面的程序输出iCount变量值，以及iPtr和iCount的地址值： # include \u003ciostream.h\u003e { int iCount = 18 ; int * iPtr = \u0026iCount ; * iPtr = 58 ; cout \u003c\u003c iCount \u003c\u003c endl ; cout \u003c\u003c iPrt \u003c\u003c endl ; cout \u003c\u003c \u0026iCount \u003c\u003c endl ; //与iPtr值相同 cout \u003c\u003c *iPtr \u003c\u003c endl ; //与 iCount值相同 cout \u003c\u003c \u0026iPtr \u003c\u003c endl ; //指针本身的地址 } // 运行结果： //58 //0x0067fe00 //0x0067fe00 //58 //0x0067fdfc 指针与整型数的区别 指针在使用中必须类型匹配 例： int iCount = 26 ; int * iPtr = \u0026iCount ; //定义语句：*在此处作定义指针变量用，而非间接引用。 * iPtr = \u0026iCount ; //error:不能将整型地址转换成整型数 * iPtr = 50 ; //执行语句：*在此处作间接引用 指针值不是整型数 赋值语句**“* iPtr = \u0026iCount *; ”在BC中会引起类型转换的错误。 (cannot convert int to int) 强制转换是合法 例：允许语句“int * iPtr = (int *) iCount ;” 但要注意其赋值的意义。该语句表示将变量iCount的值作为一个地址赋给变量 iPtr ，即iCount变量。 int iCount=50000000000; int *p=(int *)iCount; cout\u003c\u003c(int *)iCount\u003c\u003cendl; cout\u003c\u003cp\u003c\u003cendl; cout\u003c\u003c*p\u003c\u003cendl;//ERROR ","date":"2024-04-18","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A16%E4%B8%8A/:2:5","tags":["面向对象程序设计"],"title":"c++(six_1)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A16%E4%B8%8A/"},{"categories":["面向对象程序设计"],"content":"指针与常量(const指针) —指向常量的指针 例： int a = 1; int * pi ; pi = \u0026a ; * pi = 58 ; 可以看到，一个指针涉及到两个变量，指针本身pi 和指向的变量a 。修改这两个变量的对应操作为“pi = \u0026a ;”和“ pi = 58 ;”。如果不想通过指针间接改变a的值，可以声明指向常量的指针*。 不能通过指针来改变所指对象的值,但指针本身可以改变,可以指向另外的对象 在指针定义语句的类型前加const，表示指向的对象是常量 例： int n1=3; int const n2 = 5; const int *pn = \u0026n1; pn=\u0026n2; //正确 *pn=6; //错误　若声明指针常量,则指针本身的值不能被改变 在指针定义语句的指针名前加const，表示指针本身是常量 例： int n1 = 3; int const n2 = 5; int *const pn= \u0026n1; pn = \u0026n2; //错误 *pn = 6; //正确 void类型指针 一般情况下,指针的值只能赋给相同类型的指针。但是有一种特殊的void类型指针,可以存储任何类型的对象地址 例： void类型指针的使用 void vobject ; //error,不能声明void类型的变量 void * pv ; // ok ,可以声明void类型的指针 int * pint ; int i ; void main( ) // void类型的函数没有返回值 { pv = \u0026i ; //void类型指针指向整型变量 pint = (int *)pv ; // 类型强制转换 } //void类型指针赋值给整型指针 可以定义一个指向常量的指针常量，它必须在定义时进行初始化。 const int ci = 7 ; int ai ; const int * const cpc = \u0026ci ; //指向常量的指针常量 const int * const cpi = \u0026ai ; //ok cpi = \u0026ci ; // error:指针值不能修改 *cpi = 39 ; // error:不能修改所指向的对象 ai = 39 ; //ok ","date":"2024-04-18","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A16%E4%B8%8A/:2:6","tags":["面向对象程序设计"],"title":"c++(six_1)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A16%E4%B8%8A/"},{"categories":["面向对象程序设计"],"content":"指针变量的运算 指针与整数的加减运算 指针p 加上或减去 n，其意义是指针当前指向位置的后方或前方第 n 个数据的地址。 这种运算的结果值取决于指针指向的数据类型。 指针加一，减一运算 指向下一个或前一个数据的地址。 例如： y = *px++ //\u003c==\u003e y = *(px++) ( * 和 ++ 优先级相同,自右向左运算) 注意：一般来说，指针的算术运算是和数组的使用相联系的，因为只有在使用数组时，我们才会得到连续分布的可操作内存空间。对于一个独立变量的地址，如果进行算术运算，然后对其结果所指向的地址进行操作有可能会意外破坏该地址中的数据或代码。因此，对指针进行算术运算时， 一定要确保运算结果所指向的地址是程序中分配使用的地址。 指针变量的关系运算 关系运算 指向相同类型数据的指针之间可以进行各种关系运算。 指向不同数据类型的指针，以及指针与一般整数变量之间的关系运算是无意义的。 指针可以和零之间进行等于或不等于的关系运算 例如： p == 0 // 或 p! = 0 赋值运算 向指针变量赋的值必须是地址常量或地址变量，不能是普通整数（除0)。但可以赋值为 整数0，表示 空指针(NULL) 例:　int *p ; //声明一个int型指针p p = 0 ; //将p设置为空指针，不指向任何地址 ","date":"2024-04-18","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A16%E4%B8%8A/:2:7","tags":["面向对象程序设计"],"title":"c++(six_1)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A16%E4%B8%8A/"},{"categories":["面向对象程序设计"],"content":"用指针处理数组元素 声明与赋值 例： int a[10], *p; p = \u0026a[0]; //或 p = a; 通过指针引用数组元素经过上述声明及赋值后： *p 就是a[0]，(p+1) 就是a[1]，… ，**(p+i)**就是 a[i]。 a[ i ], *(p+i), *(a+i), p[ i ] 都是等效的。 不能写 a++,因为 a 是数组首地址是常量 例: 设有一个int型数组a，有10个元素。用三种方法输出各元素： 使用数组名和下标 int main（ ） { int a[10]; int i; for(i=0; i\u003c10; i++) cin\u003e\u003ea[i]; cout\u003c\u003cendl; for(i=0; i\u003c10; i++) cout\u003c\u003ca[i]; } 使用数组名和指针运算 int main（ ） { int a[10]; int i; for(i=0; i\u003c10; i++) cin\u003e\u003ea[i]; cout\u003c\u003cendl; for(i=0; i\u003c10; i++) cout\u003c\u003c*(a+i); } 使用指针变量 int main（ ） { int a[10]; int *p,i； for(i=0; i\u003c10; i++) cin\u003e\u003ea[i]; cout\u003c\u003cendl; for( p = a; p \u003c (a+10); p++) cout\u003c\u003c*p; } ","date":"2024-04-18","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A16%E4%B8%8A/:2:8","tags":["面向对象程序设计"],"title":"c++(six_1)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A16%E4%B8%8A/"},{"categories":["面向对象程序设计"],"content":"指针数组 数组的元素是指针变量 声明一维指针数组的语法形式 类型名T　*数组名[下标表达式]; 例： int *p_i[ 2 ]; //由 p_i[0], p_i[1] 两个指针组成 例：利用指针数组输出单位矩阵 void main（ ） { int line1[ ]={1,0,0}; //声明数组,矩阵的第一行 int line2[ ]={0,1,0}; //声明数组，矩阵的第二行 int line3[ ]={0,0,1}; //声明数组，矩阵的第三行 int *p_line[3]; //声明整型指针数组 p_line[0]=line1; //初始化指针数组元素 p_line[1]=line2; p_line[2]=line3; //int line1[ ]={1,0,0}; //int line2[ ]={0,1,0} ; //int line3[ ]={0,0,1}; //输出单位矩阵 cout\u003c\u003c\"Matrix test:\"\u003c\u003cendl; for(int i=0;i\u003c3;i++) //对指针数组元素循环 { for(int j=0;j\u003c3;j++) //对矩阵每一行循环 { cout \u003c\u003c p_line[ i ][ j ] \u003c\u003c \" \"; cout \u003c\u003c *( *p_line[ i ] + j ) \u003c\u003c \"\"; // (p_line[i]+j)表示指向第i行第j 个元素 *(p_line[i]+j)表示(p_line[i]+j)指针所指的变p_line[i][j],与上一句的运行效果一致 } cout\u003c\u003cendl; } } //输出结果为： //Matrix test: //1,0,0 //0,1,0 //0,0,1 一维数组 int i ; int *p; int a[10]; p = \u0026i; 因为： a == \u0026a[0] 所以： p = a; p = \u0026a[0];效果都一样 for(int i=0;i\u003c3;i++) {　cout\u003c\u003c“p_line[”\u003c\u003ci\u003c\u003c“]: ”\u003c\u003c p_line[ i ]\u003c\u003cendl; for(int j=0;j\u003c3;j++) { cout \u003c\u003c “ ”\u003c\u003cp_line[ i ] + j \u003c\u003c \" \"; } cout\u003c\u003cendl; } 二维数组 例：二维数组举例 #include \u003ciostream.h\u003e void main（ ） { int array2[2][3]={{11,12,13},{21,22,23}}; for(int i=0;i\u003c2;i++) { cout \u003c\u003c *( array2 + i ) \u003c\u003cendl; //指向i行,相当于array2[i],即第i行的数组 for(int j=0;j\u003c3;j++) { cout \u003c\u003c *(*( array2 + i ) + j) \u003c\u003c“ ”; } //指向第i行的第j个元素 cout\u003c\u003cendl; } } ","date":"2024-04-18","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A16%E4%B8%8A/:2:9","tags":["面向对象程序设计"],"title":"c++(six_1)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A16%E4%B8%8A/"},{"categories":["面向对象程序设计"],"content":"以指针作为函数参数 指针变量作为形参 在函数调用时将实参的地址传递给形参，使实参和形参指针变量指向同一内存单元 通过在被调用函数中直接处理主调函数中的数据，而将函数的处理结果返回给调用者 实参是数组名时形参可以是指针变量 在c语言中，以指针作为函数的形参有三个作用: 使实参与形参指针指向共同的内存空间，以达到参数双向传递的目的，即通过在被调用函数中直接处理主调函数中的数据，而将函数的处理结果返回给调用者 减少函数调用时数据传递的开销。这一作用在C++中有时可以通过引用实现，有时还是需要使用指针 通过指向函数的指针传递函数代码的首地址 在程序设计时，如果某个函数中以指针或引用作为形参都可以达到同样目的，则使用引用会使程序的可读性更好些 例：读入三个浮点数，将整数部分和小数部分分别输出 #include \u003ciostream.h\u003e void splitfloat ( float x, int *intpart,float *fracpart ) { //形参 intpart、 fracpart是指针变量 *intpart = int(x); // 取x的整数部分 *fracpart = x - *intpart; //取x的小数部分 } void main(void) { int i, n; float x, f; for (i = 0; i \u003c 3; i++) { cin \u003e\u003e x; splitfloat ( x, \u0026n, \u0026f); //变量地址做实参 } } 例:实参为数组名, 形参为数组名或指针变量 // 形参是数组 float average ( float array [ ], int n ) { int i; float aver, sum = array [0]; for ( i = 1; i \u003c n; i ++) sum = sum + array [ i ]; aver = sum / n; return aver; } //形参是指针变量 float average ( float *p, int n ) { int i; float aver, sum = *p; for ( i = 1; i \u003c n; i ++) sum = sum + *( p + i) ; aver = sum / n; return aver; } void main ( ) { float score_1 [5] = { 98.5,97,91.5,60,55}; float score_2[10] = {67.5,89.5,99,69.5,77,76.5,54,60,95.5,78}; cout \u003c\u003c average ( score_1, 5) ; cout \u003c\u003c average ( score_2, 10) ; } ","date":"2024-04-18","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A16%E4%B8%8A/:2:10","tags":["面向对象程序设计"],"title":"c++(six_1)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A16%E4%B8%8A/"},{"categories":["面向对象程序设计"],"content":"指针型函数 返回指针的函数称为指针函数 指针函数不能把在它内部说明的具有局部作用域的数据地址作为返回值 指针函数的一般定义形式 数据类型　*函数名(参数表) { 函数体 } 注意:: 指针函数不能把在它内部说明的具有局部作用域的数据地址作为返回值。可以返回堆地址，可以返回全局或静态变量的地址 例： # include \u003c iostream.h\u003e int * getInt(char * str ) //指针函数 { int value = 20; cout \u003c\u003c str \u003c\u003c endl; return \u0026value ; //warning:将局部变量的地址返回是不妥的 } void somefn(char * str) { int a = 40; cout \u003c\u003c str \u003c\u003c endl ;} void main( ) { int *pr = getInt(\"input a value:\"); //赋值取自返回的指针值 cout \u003c\u003c *pr \u003c\u003c endl;//第一次输出*pr somefn(\"It is uncertain.\"); cout \u003c\u003c *pr \u003c\u003c endl;//第二次输出*pr } //运行结果： //input a value: //4266377 //It is uncertain. //4198998 ","date":"2024-04-18","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A16%E4%B8%8A/:2:11","tags":["面向对象程序设计"],"title":"c++(six_1)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A16%E4%B8%8A/"},{"categories":["面向对象程序设计"],"content":"指向函数的指针 含义： 每个函数都占用一段内存单元，被分配一个入口地址（起始地址），指向函数地址的指针称为函数的指针 函数调用： 函数名( 参数表 ) 实质就是： 函数起始地址( 参数表 ) 和数组名代表数组起始地址一样，函数名代表函数入口地址。 指向函数的指针 用一个指针变量存放函数的起始地址，即指向该函数。通过指针变量就可以访问所指向的函数 函数指针声明形式 数据类型 (*函数指针名) (形参表 ); 函数指针在使用之前也要进行赋值，使指针指向一个已经存在的函数代码的起始地址 函数指针名＝函数名 例:函数指针的定义为: int (*func) (char a , char b ); 注意，与指针型函数的区别： int * func(char a , char b ); 定义中, func先与( )结合构成函数的声明，然后再得到其返回类型为整型指针 int *。 例： 函数指针 void print_stuff (float data_to_ignore); void print_message (float list_this_data); void print_float (float data_to_print); void (*function_pointer) (float); void main（ ） { float pi = 3.14159; float two_pi = 2.0 * pi; print_stuff(pi); function_pointer = print_stuff; function_pointer (pi); function_pointer = print_message; function_pointer (two_pi); function_pointer (13.0); function_pointer = print_float; function_pointer (pi); print_float(pi); return 0 ; } void print_stuff(float data_to_ignore) { cout\u003c\u003c\"This is the print stuff unction.\\n\";　} void print_message(float list_this_data) { cout\u003c\u003c“The data to be listed is” \u003c\u003c list_this_data \u003c\u003c endl; } void print_float(float data_to_print) { cout\u003c\u003c\"The data to be printed is”\u003c\u003cdata_to_print \u003c\u003c endl ;} 函数指针的内在差别 省略方括号[ ]的数组名是地址,省略括号( )的函数也是地址,所以可以将省略了( )的函数名作为函数地址赋给函数指针 函数的差别 函数类型是指函数的返回类型,这里函数的差别不但是返回类型的差异,还有参数的差异,所以,函数类型的差异不能完全说明函数的差别 例：下面的代码表示函数和函数指针操作的相互关系： int fn1(char x , char y ) ; //两个字符参数和返回整型值的函数 int * fn2(char x , char y ); //两个字符参数和返回整型指针的函数 int fn3(int a ) ; //一个整型参数和返回整型值的函数 int (*fp1) (char a , char b ) ; //两个字符参数和返回整型值的函数指针 int (*fp2) (int s ) ; //一个整型参数和返回整型值的函数指针 fp1 = fn1 ; //ok: fn1函数与指针fp1指向的函数一致 fp1 = fn2 ; //error: fn2函数与fp1指向的函数不一致 fp2 = fn3 ; //ok: 函数参数与返回类型一致,函数名赋给函数指针 fp2 = fp1 ; //error: 两个指针指向的函数不一致 fp2 = fn3 (5); //error: 函数赋给函数指针时,不能加括号 函数指针与其他数据类型的指针尽管都是地址，但在类型上有很大的差别 例： int * ip ; void (*fp) ( ) ; //函数指针 fp = ip ; //error:不能相互赋值 ip = fp ; //error:不能相互赋值 ","date":"2024-04-18","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A16%E4%B8%8A/:2:12","tags":["面向对象程序设计"],"title":"c++(six_1)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A16%E4%B8%8A/"},{"categories":["面向对象程序设计"],"content":"指向对象的指针 对象指针的一般概念 声明形式 类名 *对象指针名； 例 Point p1(5,10); Piont *ptr; ptr = \u0026 p1; 通过指针访问对象成员 对象指针名 －\u003e成员名 例: 对象指针应用举例 #include\u003c iostream.h\u003e class Point {　public: Point (int xx, int yy){ X = xx; Y = yy; } int GetX( ) { return X; } int GetY( ) { return Y; } private: int X, Y; }; void main（ ） { Point p1(5,10); Point *ptr; ptr=\u0026p1; cout \u003c\u003c ptr -\u003e GetX ( ) \u003c\u003cendl; cout \u003c\u003c p1.GetX ( ) \u003c\u003cendl; } //p1－\u003e GetX ( ) 错误 //ptr－\u003eX = 15; 错误 this指针 this 指针是一个隐含于每一个类的成员 函数中的特殊指针(包括构造函数和析构函数),它用于指向正在被成员函数操作的对象 this 指针就明确地指出了成员函数当前　所操作的数据所属的对象 实际过程 当通过一个对象调用成员函数时,系统先　将该对象的地址赋给this指针,然后调用成员　函数,成员函数对对象的数据成员进行操作时, 就隐含使用了this指针 this 是一个指针变量,因此在成员函数中,可以使用*this来标识正在调用该函数的对象 指向类的非静态成员的指针 类的成员自身也是一些变量、函数或者对象等，也可以直接将它们的地址存放到一个指针变量中，这样，就可以使指针直接指向对象的成员，进而可以通过这些指针访问对象成员 声明指针的语句形式 类型说明符　类名::*指针名 ； 类型说明符　(类名::*指针名)(参数表)； 注意：通过指向成员的指针也只能访问到公有成员 对数据成员指针赋值的一般语法形式 指针名 = \u0026类名::数据成员名 说明： 上式只是说明了被赋值的成员指针是专门　用于指向哪个数据成员的，同时在指针中存放该数据成员在类中的相对位置 当然通过这样的指针现在并不能访问什么 由于类是通过对象而实例化的，在声明类的对象时才会为具体的对象分配内存空间，这时只要将对象在内存中的起始地址与成员指针存放的相对偏移结合起来就可以访问到对象的数据成员了。 访问数据成员的两种语法形式 对象名. *类成员指针名 对象指针名-\u003e *类成员指针名 成员函数指针在声明之后要用以下形式的语句对其赋值： 指针名 = 类名::函数成员名 利用指针调用成员函数的语句形式 (对象名. *类成员指针名)(参数表) (对象指针名-\u003e *类成员指针名)(参数表) 例： 访问对象的公有成员函数的不同方式 #include\u003ciostream\u003e using namespace std; class Point {　public: Point (int xx, int yy){ X = xx; Y = yy; } int GetX( )　{ return X; } int GetY( )　{ return Y; } private: int X, Y; }; void main( ) //主函数 { point A(4,5) ; //声明对象A point *p1 = \u0026A ; //声明对象指针并初始化 int (point::*p_GetX)( ) = point::GetX; //声明成员函数指针并初始化 cout\u003c\u003c(A.*p_GetX)( ) \u003c\u003c endl; //使用成员函数指针访问成员函数 cout\u003c\u003c(p1-\u003eGetX)( ) \u003c\u003c endl; //使用对象指针访问成员函数 cout\u003c\u003c A. GetX( ) \u003c\u003c endl; } //使用对象名访问成员函数 指向类的静态成员的指针 类的静态成员可以用普通的指针来指向和访问 例：通过指针访问类的静态数据成员 #include\u003ciostream\u003e using namespace std; class point { public: point (int xx = 0, int yy = 0) //构造函数 { X = xx; Y = yy; countp++; } point (point \u0026p); //拷贝构造函数 int GetX( )　{ return X; } int GetY( )　{ return Y; }　stacit int countp ; //静态数据成员引用性说明 private: int X, Y; }; point::point(point \u0026p) { x = p.x ; y = p.y ; countp + + ; } int point::countp = 0 ; //静态数据成员定义性说明 void main( ) //主函数实现 { int *count = \u0026point::countp ; /声明一个int型指针，指向类的静态成员 point A(4,5) ; //声明对象A cout\u003c\u003c“point A,”\u003c\u003cA.GetX( )\u003c\u003c“,”\u003c\u003c A.GetY( ) ; cout\u003c\u003c“object id=”\u003c\u003c*count\u003c\u003cendl ; //直接通过指针访问静态数据成员 point B(A); //声明对象B cout\u003c\u003c“point B,”\u003c\u003cB.GetX( )\u003c\u003c“,”\u003c\u003c B.GetY( ) ; cout\u003c\u003c“object id = ”\u003c\u003c*count\u003c\u003cendl ; //直接通过指针访问静态数据成员 } 例： 通过指针访问类的静态函数成员 #include\u003ciostream\u003e using namespace std; class point { public: point (int xx = 0, int yy = 0) //构造函数 { X = xx; Y = yy; countp++; } point (point \u0026p); //拷贝构造函数 int GetX( )　{ return X; } int GetY( )　{ return Y; }　static void Getc( ) //静态函数成员 {cout\u003c\u003c“object id = ”\u003c\u003ccountp\u003c\u003cendl ; } private: int X, Y; static int countp ; //静态数据成员引用性说明 }; point::point(point \u0026p) { x = p.x ; y = p.y ; countp + + ; } int point::countp = 0 ; //静态数据成员定义性说明,初始化，使用类名限定　void main( ) //主函数实现 { void (*gc)( ) = Point::GetC ; //声明一个指向函数的指针，指向类的静态成员函数 point A(4,5) ; //声明对象A cout\u003c\u003c“point A,”\u003c\u003cA.GetX( )\u003c\u003c“,”\u003c\u003c A.GetY( ) ; gc( ) ; //输出对象序号，直接通过指针访问静态成员函数 point B(A); //声明对象B cout\u003c\u003c“point B,”\u003c\u003cB.GetX( )\u003c\u003c“,”\u003c\u003c B.GetY( ) ; gc( ) ; //输出对象序号，直接通过指针访问静态成员函数 } ","date":"2024-04-18","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A16%E4%B8%8A/:2:13","tags":["面向对象程序设计"],"title":"c++(six_1)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A16%E4%B8%8A/"},{"categories":["操作系统"],"content":"虚拟存储器 常见的存储器 一次性全部装入 常驻内存 内存的利用率低 改进 时间局部性(循环执行) 空间局部性(顺序执行) 虚拟存储器 请求式分页 请求式分段 什么是虚拟存储器 定义：内存+外存，统一起来进行管理 增加了两个功能 请求调用(中断)：访问的程序不在内存 置换：在内存物理块存放满，需要将不执行的程序先调到外存然后再将需要执行的调入内存 容量(大小) 最大容量：由系统机器指令的地址结构决定 实际容量：内存容量+外存容量 实现方法 分页 分段 特征 离散性：部分装入 若连续则不可能提供虚存），无法支持大作业小内存运行 多次性：局部装入，多次装入。 对换性 虚拟性. ","date":"2024-04-18","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F5/:0:0","tags":["操作系统"],"title":"操作系统(第五章)","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F5/"},{"categories":["操作系统"],"content":"请求式分页 硬件的变化 页表，增加4个字段：状态位(存在)/访问字段/修改位/外存地址 缺页中断：请求调入，访问的页面不在内存 地址变换：增加缺页中断 内存的物理块分配 最小物理块 页面分配 固定分配 可变式分配 页面置换 全局置换 局部置换 分配算法 平均分配算法 按进程大小比例分配算法： 考虑优先权分配算法 请求调入和置换 调入时机 预调 请求调 调页的地方 调入过程：调用缺页中断 页面置换算法：用到缺页中断(3种) 置换的是哪些页面？ 缺页中断 最佳页面置换算法(DPT)(理论上最好) 置换策略 永远不再被访问的页面 将来访问的页面中最长时间才被访问的页面 缺页率：$\\frac{缺页次数}{总数}$ $\\frac{6}{12}\\times 100% =50%$ FIFO(先进先出) 置换策略：将先装入内容物理块的页面置换出去 缺页率：$\\frac{9}{12} \\times 100% = 75%$ 注： “抖动“现象：刚刚被置换出去的页面，下一时刻又要被访问(将它调入内存) 产生2次抖动 LRU(最近最久未使用置换算法) 置换策略：将已经被访问的页面中，最长最久时间没有被访问的页面 缺页率：$\\frac{7}{12}\\times 100% \\approx 58%$ ","date":"2024-04-18","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F5/:1:0","tags":["操作系统"],"title":"操作系统(第五章)","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F5/"},{"categories":["计算机算法设计与分析"],"content":"回溯法 ","date":"2024-04-18","objectID":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A15/:0:0","tags":["计算机算法设计与分析"],"title":"算法与程序(第五章)","uri":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A15/"},{"categories":["计算机算法设计与分析"],"content":"回溯法 当需要找出问题的解集或者要求满足某些约束条件的最优解时，常使用回溯法 回溯法的基本方法就是搜索，是一种组织得井井有条的，能避免不必要搜索的穷举式搜索法 这种方法适用于解一些组合数相当大的问题，如排列、子集。0-1背包问题、n皇后安排问题等可以使用回溯法 回溯法在问题的解空间树中，按深度优先策略，从根结点出发搜索整个解空间树 算法搜索至解空间树的任意一结点时，先判断该结点是否包含问题 的解 如果不包含，跳过对该结点为根的子树的搜索，返回该结点的父结 点，继续对该结点兄弟结点的搜素（若有）。否则，进入该子树， 继续按深度优先策略搜索 问题的解向量：回溯法希望一个问题的解能够表示成一个n元组 (x1,x2,…,xn) 0-1背包问题n元组？ xi取0或1组成的n元组 显约束：对分量xi的取值限定。 隐约束：为满足问题的解而对不同分支施加的约束。 解空间：对于问题的一个实例，解向量满足显式约束条件的所有n元组，构成 了该实例的一个解空间。组织成一棵树 $\\Rightarrow$解空间树 注意：同一个问题可能有不同的解空间树表 示，有些表示方法更简单，解空间更小，搜 索方法更快。 扩展结点一个正在产生儿子的结点称为扩展结点 活结点:一个自身已生成但其儿子还没有全部生成的结点称做活结点 死结点:一个所有儿子已经产生的结点称做死结点 深度优先的问题状态生成法（演示）： 如果对一个扩展结点R，一旦产生了它的一个儿子C，就把C当做新的 扩展结点，R成为活结点。在完成对子树C（以C为根的子树）的穷尽搜索 之后，将R重新变成扩展结点，继续生成R的下一个儿子（如果存在）。 R的全部孩子结点产生完毕，R成为死结点。 宽度优先的问题状态生成法：在一个扩展结点变成死结点之前，它 一直是扩展结点（第六章内容） 回溯法为了避免生成那些不可能产生最佳解的问题状态，要不断地 利用剪枝函数来处死那些实际上不可能产生所需解或最优解的儿子 结点，以减少问题的计算量。 具有剪枝函数的深度优先生成树法称为回溯法 ","date":"2024-04-18","objectID":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A15/:1:0","tags":["计算机算法设计与分析"],"title":"算法与程序(第五章)","uri":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A15/"},{"categories":["计算机算法设计与分析"],"content":"回溯法的基本思想 针对所给问题，定义问题的解空间(所有可能的解集合） 确定易于搜索的解空间结构（树）； 以深度优先方式搜索解空间，并在搜索过程中用剪枝函 数避免无效搜索。 常用剪枝函数： 用约束函数在扩展结点处剪去不满足约束的子树； 用限界函数剪去得不到最优解的子树 回溯法解题的一个显著特征是：在搜索过程中动态产生问题的 解空间树，即边搜索边扩展分支。 (不同于数据结构中树的深度遍历方法，先创建树， 再深度遍历） 在任何时刻，算法只保存从根结点到当前扩展结点的路径。 若解空间树中从根结点到叶结点的最长路径的长度为h(n)，则回 溯法所需的计算空间通常为O(h(n))。 显式地存储整个解空间则需要$O(2^{h(n)})$或O(h(n)!)的内存空间 ","date":"2024-04-18","objectID":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A15/:2:0","tags":["计算机算法设计与分析"],"title":"算法与程序(第五章)","uri":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A15/"},{"categories":["计算机算法设计与分析"],"content":"递归回溯算法框架 回溯法对解空间作深度优先搜索，一般用递归算法实现回溯法。 void backtrack (int t) { if (t\u003en) output(x); else for (int i=f(n,t);i\u003c=g(n,t);i++) { x[t]=h(i); if (constraint(t)\u0026\u0026bound(t)) backtrack(t+1); } } 当前扩展结点依次生成其各孩子结点，并记住路 径信息，如果孩子结点满足约束条件和限界条件， 则继续搜索孩子结点为根的子树（递归调用） ","date":"2024-04-18","objectID":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A15/:3:0","tags":["计算机算法设计与分析"],"title":"算法与程序(第五章)","uri":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A15/"},{"categories":["计算机算法设计与分析"],"content":"子集树与排列树的回溯算法框架 遍历子集树需$O(2^n)$计算时间 void backtrack (int t) { if (t\u003en) output(x); else for (int i=1;i\u003e=0;i--) { x[t]=i; if (legal(t)) backtrack(t+1); } } 遍历排列树需要O(n!)计算时间 void backtrack (int t) { if (t\u003en) output(x); else for (int i=t;i\u003c=n;i++) { swap(x[t], x[i]); if (legal(t)) backtrack(t+1); swap(x[t], x[i]); } } ","date":"2024-04-18","objectID":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A15/:4:0","tags":["计算机算法设计与分析"],"title":"算法与程序(第五章)","uri":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A15/"},{"categories":["计算机算法设计与分析"],"content":"装载问题 共n个集装箱要装上2艘载重量分别为c1和c2的轮船，其中集装箱i的重量为wi， 且 $\\stackrel{n}{\\sum\\limits_{i=1}} w_i \\leq c_i+c_2$ 。装载问题要求确定是否有一个合理的装载方案可将这些集装 箱装上这2艘轮船。如果有，找出一种装载方案 最优装载方案： 首先将第一艘轮船尽可能装满； 将剩余的集装箱装上第二艘轮船 将第一艘轮船尽可能装满等价于选取全体集装箱 的一个子集，使该子集中集装箱重量之和最大。 以3个集装箱装船为例 用回溯法解装载问题的时间复杂性是O(2n)。在某些情况下该算法优于动态规划算法。 回溯法算法如何计算其复杂性呢？ 计算出解空间树中除叶子层之外的结点总数f(n) 每个非叶子结点搜索其下一层所有分支的时间复杂性（分、合）g(n)， 复杂性为O（f（n）*g(n)） 以最优装载问题为例, $f（n）=2^n-1， g（n）=O（1）$，其时间 复杂性为$O（2 ^n$） 也可用递归方程描述：T（n）=2T（n-1）+O（1），n\u003e0, T(1)=1; 本章讨论时间复杂性只有理论意义，没有实际意义，因为计算的是在没有任何剪 枝的情况下的时间复杂性， 实际上效率要好很多。 ","date":"2024-04-18","objectID":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A15/:5:0","tags":["计算机算法设计与分析"],"title":"算法与程序(第五章)","uri":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A15/"},{"categories":["计算机算法设计与分析"],"content":"批处理作业调度 n个作业集合{1,2,…,n}。每个作业先由机器1处理，再由机器2处理。作业i需 要机器j的处理时间为$M_{ij}$。 对于一个确定的作业调度，设Fij是作业i在机器j上完成的具体时间。 所有作业在机器2上完成的具体时间(时刻）之和f称为该作业调度的完成时间和。 要求：对于给定的n个作业，制定最佳作业调度方案(一个排列),使其完成时间和 达到最小。(追求的是平均等待时间最小化) 3个作业的6种可能的调度方案是1,2,3；1,3,2；2,1,3；2,3,1； 3,1,2；3,2,1；它们所相应的完成时间和分别是19，18，20，21， 19，19。易见，最佳调度方案是1,3,2，其完成时间和为18。 ","date":"2024-04-18","objectID":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A15/:6:0","tags":["计算机算法设计与分析"],"title":"算法与程序(第五章)","uri":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A15/"},{"categories":["计算机算法设计与分析"],"content":"关于排列树的时间复杂性的讨论 一颗n层的解空间树；时间复杂性的递归定义是 ","date":"2024-04-18","objectID":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A15/:7:0","tags":["计算机算法设计与分析"],"title":"算法与程序(第五章)","uri":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A15/"},{"categories":["计算机算法设计与分析"],"content":"符号三角形问题 回溯法之符号三角形问题 ","date":"2024-04-18","objectID":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A15/:8:0","tags":["计算机算法设计与分析"],"title":"算法与程序(第五章)","uri":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A15/"},{"categories":["计算机算法设计与分析"],"content":"n皇后问题 在n×n格的棋盘上放置彼此不受攻击的n个皇后。按照国际象棋的规则，皇后可 以攻击与之处在同一行或同一列或同一斜线上的棋子。n后问题等价于在n×n格 的棋盘上放置n个皇后，任何2个皇后不放在同一行或同一列或同一斜线上。 ","date":"2024-04-18","objectID":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A15/:9:0","tags":["计算机算法设计与分析"],"title":"算法与程序(第五章)","uri":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A15/"},{"categories":["计算机算法设计与分析"],"content":"以n=4皇后问题为例 第一种：解空间是4叉树 每个皇后在一行上有四个可选位置（显约束：任两皇后不同行） ","date":"2024-04-18","objectID":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A15/:9:1","tags":["计算机算法设计与分析"],"title":"算法与程序(第五章)","uri":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A15/"},{"categories":["计算机算法设计与分析"],"content":"n后问题（n叉树）算法 解向量：($x_1 , x_2 , … , x_n$ ) 显约束：$x_i$=1,2, … ,n 。 任两皇后不同行 隐约束：(1)不同列：$x_i\\neq x_j$ (2)不处于同一正\\ 反对角线：$|i-j| \\neq |x_i -x_j |$ bool Queen:Place(int k) { for (int j=1;j\u003ck;j++) if ((abs(k-j)==abs(x[j]- x[k])) ||(x[j]==x[k])) return false; return true; } void Queen::Backtrack(int t) { if (t\u003en) sum++; else for (int i=1;i\u003c=n;i++) { x[t]=i; if (Place(t)) Backtrack(t+1); } } ","date":"2024-04-18","objectID":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A15/:9:2","tags":["计算机算法设计与分析"],"title":"算法与程序(第五章)","uri":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A15/"},{"categories":["计算机算法设计与分析"],"content":"以n=4皇后问题为例 第二种:解空间是排列树 显约束： 任两个皇后不 同行、不同列 ","date":"2024-04-18","objectID":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A15/:9:3","tags":["计算机算法设计与分析"],"title":"算法与程序(第五章)","uri":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A15/"},{"categories":["计算机算法设计与分析"],"content":"n后问题（排列树）算法 解向量：($x_1 , x_2 , … , x_n$ ) 显约束：任两皇后不同行、不同列。x1x2….xn是1,2,….n排列 隐约束：不处于同一正\\ 反对角线：$|i-j| \\neq |x_i -x_j |$ bool Queen:Place(int k) { for (int j=1;j\u003ck;j++) if (abs(k-j)==abs(x[j]-x[k])) return false; return true; } void Queen::Backtrack(int t) { if (t\u003en) sum++; else for (int i=t;i\u003c=n;i++) { swap(x[t],x[i]); if (Place(t)) Backtrack(t+1); swap(x[t],x[i]); } } ","date":"2024-04-18","objectID":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A15/:9:4","tags":["计算机算法设计与分析"],"title":"算法与程序(第五章)","uri":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A15/"},{"categories":["计算机算法设计与分析"],"content":"0-1背包问题 解空间：子集树 可行性约束函数:$\\stackrel{n}{\\sum\\limits_{i=1}} w_ix_i \\leq c_i$ void Backtrack(int i) {if (i\u003en) {//到达叶节点 bestp=cp； return；} if（cw+w[i]\u003c=c){\\\\进入左子树 cw+=w[i]; cp+=p[i]; Backtrack(i+1); cw-=w[i]; cp-=p[i];} if(Bound(i+1)\u003ebestp)\\\\进入右子树 Backtrack(i+1); } 限界函数：Bound（i） template\u003cclass Typew, class Typep\u003e Typep Knap\u003cTypew, Typep\u003e::Bound(int i) {// 计算上界 Typew cleft = c - cw; // 剩余容量, cw当前在背包中物品重量 Typep b = cp; //cp当前在背包中物品价值 // 以物品单位重量价值递减序装入物品 while (i \u003c= n \u0026\u0026 w[i] \u003c= cleft) { cleft -= w[i]; b += p[i]; i++; } // 装满背包 if (i \u003c= n) b += p[i]/w[i] * cleft; return b; } ","date":"2024-04-18","objectID":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A15/:10:0","tags":["计算机算法设计与分析"],"title":"算法与程序(第五章)","uri":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A15/"},{"categories":["计算机算法设计与分析"],"content":"最大团问题 给定无向图G=(V，E)。如果UV，且对任意u，vU，有(u，v)E， 则称U是G的完全子图。 完全子图U是G的团当且仅当U不包含在G的更大的完全子图中。 G的最大团是指G中所含顶点数最多的团。 解空间：子集树 可行性约束函数：顶点i到已选入的顶点集中每一个顶点都有边相连。 上界函数:有足够多的可选择顶点使得算法有可能在右子树中找到更大的团 void backtrack(int i) { if (i \u003e n) {// 到达叶结点 for (int j = 1; j \u003c= n; j++) bestx[j] = x[j]; bestn = cn; return; } // 检查顶点 i 与当前团的连接 boolean ok = true; for (int j = 1; j \u003c i; j++) if (x[j] == 1 \u0026\u0026 !a[i][j]) {// i与j不相连 ok = false; break; } if (ok) {// 进入左子树 x[i] = 1; cn++; backtrack(i + 1); cn--; } if (cn + n - i \u003e bestn) {// 进入右子树 x[i] = 0; backtrack(i + 1); } } 复杂度分析 最大团问题的回溯算法backtrack所需的计算 时间显然为$O(n2^n )$。 ","date":"2024-04-18","objectID":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A15/:11:0","tags":["计算机算法设计与分析"],"title":"算法与程序(第五章)","uri":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A15/"},{"categories":["计算机算法设计与分析"],"content":"图的m着色问题 给定无向连通图G和m种不同的颜色。用这些颜色为图G的各顶点 着色，每个顶点着一种颜色。是否有一种着色法使G中每条边的2 个顶点着不同颜色。这个问题是图的m可着色判定问题。若一个 图最少需要m种颜色才能使图中每条边连接的2个顶点着不同颜色， 则称这个数m为该图的色数。求一个图的色数m的问题称为图的m 可着色优化问题。 解向量：($x_1 , x_2 , … , x_n$ )表示顶点i所着颜色$x_i$ 可行性约束函数：顶点i与已着色的相邻顶点颜色不重复。 void backtrack(int t) { if (t\u003en) sum++; else for (int i=1;i\u003c=m;i++) { x[t]=i; if (ok(t)) backtrack(t+1); } } boolean ok(int k) {// 检查颜色可用性 for (int j=1;j\u003ck;j++) if (a[k][j] \u0026\u0026 (x[j]==x[k])) return false; return true; } ","date":"2024-04-18","objectID":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A15/:12:0","tags":["计算机算法设计与分析"],"title":"算法与程序(第五章)","uri":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A15/"},{"categories":["计算机算法设计与分析"],"content":"圆排列问题 圆排列问题 ","date":"2024-04-18","objectID":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A15/:13:0","tags":["计算机算法设计与分析"],"title":"算法与程序(第五章)","uri":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A15/"},{"categories":["计算机算法设计与分析"],"content":"旅行售货员问题 旅行售货员问题-回溯法 ","date":"2024-04-18","objectID":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A15/:14:0","tags":["计算机算法设计与分析"],"title":"算法与程序(第五章)","uri":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A15/"},{"categories":["计算机算法设计与分析"],"content":"回溯法效率分析 回溯算法的效率在很大程度上依赖于以下因素： 产生x[k]的时间； 满足显约束的x[k]值的个数； 计算约束函数constraint的时间； 计算限界函数bound的时间； 满足约束函数和限界函数约束的所有x[k]的个数。 好的剪枝函数能显著地减少所生成的结点数。但这样的剪枝函数往往计算量较大。因此，需要权衡3，4跟5重排原理对于许多问题而言，在搜索试探时选取x[i]的值顺序是任意的。在其他 ","date":"2024-04-18","objectID":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A15/:15:0","tags":["计算机算法设计与分析"],"title":"算法与程序(第五章)","uri":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A15/"},{"categories":["计算机算法设计与分析"],"content":"重排原理 对于许多问题而言，在搜索试探时选取x[i]的值顺序是任意的。在其他条件相当的前提下，让可取值最少的x[i]优先。从图中关于同一问题的2棵不同解空间树，可以体会到这种策略的潜力。 图(a)，从第1层剪去1棵子树，则从所有应当考虑的3元组中一次消去12个3元组 图(b)，虽然同样从第1层剪去1棵子树，却只从应当考虑的3元组中消去8个3元组 ","date":"2024-04-18","objectID":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A15/:16:0","tags":["计算机算法设计与分析"],"title":"算法与程序(第五章)","uri":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A15/"},{"categories":["计算机算法设计与分析"],"content":"回溯法小结 回溯法解决的问题，其解可以表示成n元组的形式。 确定易于求解的解空间树。常用：子集树、排列树、n叉树等 一个问题若有多种解空间树，评价：最后一层叶子结 点的数量越少越好。 剪枝函数的设计：要求在保证剪枝效率的情况下计算尽量简单。 子集树：通常左分支使用约束函数、右分支使用限界函数剪枝。 排列树或n叉树：每个分支剪枝条件（函数）是相同的。 回溯法的套路：在递归调用backtrack（）前、后的代码动作是相反的 到达叶子结点时，通常一个新解就产生了。 如果是求最优解， 你要确定需不需要跟之前的最优解比较来更新最优解。有些情况是必须要经过比较确认后才能更新为当前最优解。 ","date":"2024-04-18","objectID":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A15/:17:0","tags":["计算机算法设计与分析"],"title":"算法与程序(第五章)","uri":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A15/"},{"categories":["编译原理"],"content":"语义分析及中间代码生成 ","date":"2024-04-18","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%866/:0:0","tags":["编译原理"],"title":"编译引论(第六章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%866/"},{"categories":["编译原理"],"content":"中间代码 中间代码生成在编译程序中的位置 中间代码 **即中间语言，独立于机器的，复杂性介于源语言和机器语言之间的一种表示形式。**中间代码是高级程序语言中，各种语法成分的语义结构表示；它介于源语言和目标语言之间。 采用中间语言的好处 便于进行与机器无关的代码优化工作 使编译程序改变目标机更容易； **使编译程序的结构在逻辑上更为简单明确。**以中间语言为界面，编译前端和后端的接口更清晰。 ","date":"2024-04-18","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%866/:1:0","tags":["编译原理"],"title":"编译引论(第六章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%866/"},{"categories":["编译原理"],"content":"中间语言－后缀式 后缀式 后缀表示法也叫逆波兰表示法，它是最简单一种中间代码表示法，主要用于表示算数表达式。 即将运算对象写在前面，把运算符写在后面的表示法。 定义9.1 后缀式的递归定义如下： 如果E是一个变量或常量，则E的后缀式就是E本身； 如果E是形如E1 op E2的表达式，其中op是任意的二元运算符 ，那么， E的后缀式为E1’ E2’ op，其中E1’和 E2’分别是E1和E2的后缀式； 如果E是(E1)形式的表达式，那么，E1的后缀式就是E的后缀式。 后缀式的例子 (a+b) *(a+c) 的后缀式为 ab+ac+* -a+b+c/d* (a+c) 的后缀式为 a-b+cd/ac+*+ 后缀式的特点 后缀式形式的表达式计算顺序唯一，无需使用括号来明确计算顺序； 只要知道每个算符的目数，计算参与运算数的个数，对后缀式从左到右进行扫描，就能对它进行唯一的分解。例如 表达式和与它对应的逆波兰表达式中的运算对象顺序是完全一致的，即表达式中的所有运算对象，均按原序排在其逆波兰表达式中 -a+b+c/d* (a+c) 的后缀式为 a-b+cd/ac+*+ 后缀式特别适合利用栈的结构进行计算 自左向右扫描表达式的后缀表示，每遇到一个对象就把它压入栈内 每遇到一个算符，就从栈顶取出相应个数的运算对象进行计算，再将结果压入栈顶 最后，栈顶元素就是表达式的运算结果 ","date":"2024-04-18","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%866/:1:1","tags":["编译原理"],"title":"编译引论(第六章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%866/"},{"categories":["编译原理"],"content":"三地址代码 三地址代码的一般形式的语句构成的序列 x:=y op z x,y,z: 名字,常数,编译时产生的临时变量； op: 运算符号(如定点运算符,浮点运算符,逻辑运算符等) 称为三地址代码的原因:每条语句通常包含三个地址,两个用来表示操作数,一个用来存放结果。如表达式x+y*z的三地址代码为： $T_1$:=y*z $T_2$:=x+$T_1$ 具体实现:三地址代码是中间代码的一种抽象形式。在编译过程中，三地址代码语言的具体实现通常有四元式和三元式 ","date":"2024-04-18","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%866/:1:2","tags":["编译原理"],"title":"编译引论(第六章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%866/"},{"categories":["编译原理"],"content":"语法制导翻译 对语法分析后的语法单位要进行语义分析，包括 两个阶段： 静态语义审查； 如果静态语义正确，生成中间代码 ","date":"2024-04-18","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%866/:2:0","tags":["编译原理"],"title":"编译引论(第六章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%866/"},{"categories":["编译原理"],"content":"静态语义审查 作用：验证语法结构合法的程序是否真正有意义 包含的内容 类型检查 条件表达式的类型是不是布尔型 验证指针地址访问只作用于指针 函数必须有正确的参数个数和参数类型 … ","date":"2024-04-18","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%866/:2:1","tags":["编译原理"],"title":"编译引论(第六章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%866/"},{"categories":["编译原理"],"content":"什么是语法制导翻译 语法制导翻译(syntax_directed translations) 是在语法分析过程中，随着分析(推导或归约)的逐步进 展，每识别出一个语法结构，根据文法的每个规则所对 应的语义子程序进行翻译的方法；核心技术是构造属性翻译文法 —-在原文法产生式中插入语义动作符号，借以指明属性文法中属性求值时机和顺序。 通俗地说，所谓语法制导翻译技术，是指 语法分析技术 +属性翻译文法构造技术 ","date":"2024-04-18","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%866/:2:2","tags":["编译原理"],"title":"编译引论(第六章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%866/"},{"categories":["编译原理"],"content":"语法制导翻译的基本思想 如何表示语义信息 为CFG的文法符号设置语义属性，用来表示语法成分对应的语义信息 如何计算语义属性 文法符号的语义属性值是用来与文法符号所在产生式(语法规则)相关联的语义规则来计算 对于给定的输入串x，构建x的语法分析树，并利用与产生式(语法规则)相关联的语义规则来计算分析树中各结点对应的语义属性值 ","date":"2024-04-18","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%866/:2:3","tags":["编译原理"],"title":"编译引论(第六章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%866/"},{"categories":["编译原理"],"content":"两个概念 将语义规则同语法规则(产生式)联系起来要涉及两个概念 语义制导定义 语法制导翻译方案 ","date":"2024-04-18","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%866/:2:4","tags":["编译原理"],"title":"编译引论(第六章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%866/"},{"categories":["编译原理"],"content":"语法制导定义 SDD是对CFG的推广 将每个文法符号和一个语义属性集合相关联 将每个产生式和一组语义规则相关联，这些规则用于计算该产生式中各文法符号的属性值 如果X是一个文法符号，a是X的一个属性，则用X，a表示属性a在某个标号为X的分析树结点上的值 ","date":"2024-04-18","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%866/:2:5","tags":["编译原理"],"title":"编译引论(第六章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%866/"},{"categories":["编译原理"],"content":"语法制导翻译方案 SDT是在产生式右部嵌入了程序片段的CFG，这些程序片段称为语义动作。按照惯例，语义动作放在花括号内 一个语义动作在产生式中的位置决定了这个动作的执行时间 ","date":"2024-04-18","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%866/:2:6","tags":["编译原理"],"title":"编译引论(第六章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%866/"},{"categories":["编译原理"],"content":"SDD与SDT SDD 是关于语言翻译的高层次规格说明 隐蔽了许多具体实现细节，使用户不必显式地说明翻译发生的顺序 SDT 可以看作是对SDD的一种补充，是SDD的具体实施方案 显式地指明了语义规则的计算顺序，以便说明某些实现细节 ","date":"2024-04-18","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%866/:2:7","tags":["编译原理"],"title":"编译引论(第六章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%866/"},{"categories":["编译原理"],"content":"语法制导定义SDD 语法制导定义SDD是对CFG的推广 将每个文法符号和一个语义属性集合相关联 将每个产生式和一组语义规则相关联，用来计算该产生式中各文法符号的属性值 文法符号的属性 综合属性(synthesized attribute) 继承属性(inherited attribute) ","date":"2024-04-18","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%866/:2:8","tags":["编译原理"],"title":"编译引论(第六章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%866/"},{"categories":["编译原理"],"content":"综合属性(synthesized attribute) 在分析树结点N上的非终结符A的综合属性只能通过N的子结点或N本身的属性值来定义 终结符可以具有综合属性。终结符的综合属性值是由词法分析器提供的词法值，因此在SDD中没有计算终结符属性值的语义规则 带有综合属性的SDD ","date":"2024-04-18","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%866/:2:9","tags":["编译原理"],"title":"编译引论(第六章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%866/"},{"categories":["编译原理"],"content":"继承属性(inherited attribute) 在分析树结点N上的非终结符A的继承属性只能通过N的父结点、N的兄弟结点或N本身的属性值来定义 终结符没有继承属性。终结符从词法分析器处获得的属性值被归为综合属性值 带有继承属性的SDD ","date":"2024-04-18","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%866/:2:10","tags":["编译原理"],"title":"编译引论(第六章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%866/"},{"categories":["编译原理"],"content":"属性文法(Attribute Grammar) 一个没有副作用的SDD有时也称为属性文法 属性文法的规则仅仅通过其它属性值和常量来定义一个属性值 ","date":"2024-04-18","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%866/:2:11","tags":["编译原理"],"title":"编译引论(第六章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%866/"},{"categories":["编译原理"],"content":"语法制导翻译方案SDT 语法制导翻译方案(SDT)是在产生式右部中嵌入了程序片段(称为语义动作)的CFG SDT可以看作是SDD的具体实施方案 本节主要关注如何使用SDT来实现两类重要的SDD,因为在这两种情况下，SDT可在语法分析过程中实现\u003e基本文法可以使用LR分析技术，且SDD是S属性的 基本文法可以使用LL分析技术，且SDD是L属性的 ","date":"2024-04-18","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%866/:2:12","tags":["编译原理"],"title":"编译引论(第六章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%866/"},{"categories":["编译原理"],"content":"将S-SDD转换为SDT 将一个S-SDD转换为SDT的方法:将每个语义动作都放在产生式的最后 ","date":"2024-04-18","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%866/:2:13","tags":["编译原理"],"title":"编译引论(第六章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%866/"},{"categories":["编译原理"],"content":"算术表达式四元式属性翻译文法设计 算术表达式四元式属性翻译文法设计 ","date":"2024-04-18","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%866/:3:0","tags":["编译原理"],"title":"编译引论(第六章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%866/"},{"categories":["计算机组成原理"],"content":"指令系统 ","date":"2024-04-15","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%864/:0:0","tags":["计算机组成原理"],"title":"计算机组成(第四章)","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%864/"},{"categories":["计算机组成原理"],"content":"概 述 指令：是指示计算机某种操作的命令。 微指令，机器指令，宏指令 指令系统：一台计算机中所有机器指令的集合，它是表征一台计算机性能的重要因素。 它是机器硬件设计的依据，也是软件设计的基础 它决定了一台计算机硬件的主要性能和基本功能。是硬件和软件间的界面。 系列计算机：有共同的指令集，相同的基本体系结构。 一个完善的指令系统应满足 完备性：指令丰富，功能齐全，使用方便。 有效性：程序占空间小，执行速度快 规整性：对称性，匀齐性，指令格式和数据格式的一致性 对称性：指在指令系统中所有的寄存器和存储器单元都可同等对待，所有的指令都可使用各种寻址方式； 匀齐性：是指一种操作性质的指令可以支持各种数据类型； 指令格式和数据格式的一致性：是指指令长度和数据长度有一定的关系，以方便处理和存取 兼容性：“向上兼容”—-系列机中低档机上运行的软件可以在高档机上运行。 ","date":"2024-04-15","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%864/:1:0","tags":["计算机组成原理"],"title":"计算机组成(第四章)","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%864/"},{"categories":["计算机组成原理"],"content":"计算机语言与硬件结构的关系 高级语言的语句和用法与具体机器的指令系统无关 低级语言分机器语言和汇编语言，他们和具体机器的指令系统密切相关 汇编语言与硬件的关系密切，编写的程序紧凑、占内存小、速度快，特别适合与编写经常与硬件打交道的系统软件；而高级语言不涉及机器的硬件结构，通用性强、编写程序容易，特别适合与编写与硬件没有直接关系的应用软件 概 述 机器指令的要素 操作码 源操作数 目的操作数 下一条指令的引用 指令字（简称指令）即表示一条指令的机器字。 指令格式则是指令字用二进制代码表示的结构形式，由操作码字段和地址码字段组成 操作码 设计计算机时，对指令系统的每一条指令都要规定一个操作码 指令操作码表示该指令进行什么性质的操作,表征指令的操作特性与功能 组成操作码字段的位数一般取决于计算机指令系统的规模。 例如，一个指令系统只有8条指令，则有3位操作码就够；如果有32条指令，那么就需要5位操作码 地址码 地址码字段通常指定参与操作的操作数的地址 根据一条指令中有几个操作数地址，可将该指令称为几操作数指令或几地址指令。目前，二地址指令和一地址指令用的最多 零地址指令的指令字中只有操作码，而没有地址码。 一地址指令常称为单操作数指令 OP (A) -\u003e A (AC) OP (A) -\u003e AC 二地址指令常称为双操作数指令。　(A1) OP (A2)　-\u003e　A1 三地址指令字中有三个操作数地址。 (A1) OP (A2)　-\u003e　A3　OP表示操作性质;（AC）表示累加寄存器AC中的数；（A）表示内存中地址为A的存储单元中的数或运算器中地址为A的通用寄存器中的数；→表示把操作（运算）结果传送到指定的地方 二地址指令格式中，从操作数的物理位置来说，又可归结为三种类型 存储器-存储器（SS）型指令：操作时都是涉及内存单元，参与操作的数都放在内存里，从内存某单元中取操作数，操作结果存放至内存另一单元中，因此机器执行这种指令需要多次访问内存 寄存器-寄存器（RR）型指令：需要多个通用寄存器或个别专用寄存器，从寄存器中取操作数，把操作结果放到另一寄存器。机器执行寄存器-寄存器型指令的速度很快，因为执行这类指令，不需要访问内存 寄存器-存储器（RS）型指令：执行此类指令时，既要访问内存单元，又要访问寄存器 指令字长度 一个指令字中包含二进制代码的位数，称为指令字长度。而机器字长是指计算机能直接处理的二进制数据的位数，与主存单元的位数一致，它决定了计算机的运算精度 它们之间关系如上：其中L为指令字长度，N为机器字长度 使用多字长指令，目的在于提供足够的地址位来解决访问内存任何单元的寻址问题。其主要缺点是必须两次或多次访问内存以取出一整条指令，降低了CPU的运算速度，又占用了更多的存储空间 **等长指令字结构:**各种指令字长度是相等的。这种指令字结构简单，且指令字长度是不变的。 变长指令字结构:各种指令字长度随指令功能而异。结构灵活，能充分利用指令长度，但指令的控制较复杂 指令助记符　由于硬件只能识别1和0，所以采用二进制操作码是必要的，但是书写程序却非常麻烦 为了便于书写和阅读程序，每条指令通常用3个或4个英文缩写字母来表示。这种缩写码叫做指令助记符。 在不同的计算机中，指令助记符的规定是不一样的。因此，指令助记符还必须转换成与它们相对应的二进制码 指令格式举例　**八位微型计算机的指令格式 ** 8位微型机字长只有8位，指令结构是一种可变字长形式，包含单字长、双字长、三字长指令等多种 内存按字节编址，所以单字长指令每执行一条指令后，指令地址加1 双字长指令或三字长指令每执行一条指令时，指令地址要加2或加3，可见多字长的指令格式不利于提高机器速度 指令和指令系统——指令的使用 一般的操作数类型大小选择主要有：字节、半字（16位）、单字（32位）、和双字（64位） 例：指令格式如下所示，其中机器字长16位，OP为操作码，试分析指令格式的特点。 例： 指令格式如下所示，机器字长16位，OP为操作码字段，试分析指令格式特点。 指令和数据的寻址方式 指令的寻址方式 计算机中有两种信息。即指令和数据（或称操作数），它们都存放在存储器相应的地址中。运行程序时，计算机逐条执行指令，并对数据进行处理。如何从存储器中找到所需要的指令或数据呢？很明显，只要找到它们在存储器的有效地址即可。 所谓寻址方式，就是寻找指令或操作数的有效地址的方式 顺序寻址方式：按照指令在内存的存放位置顺序地取出指令，然后执行的过程，为顺序寻址方式。 跳跃寻址方式：程序转移执行的顺序。 顺序寻址 为了达到顺序寻址的目的，CPU中必须有一个程序计数器（PC）对指令的顺序号进行计数。PC中开始时存放程序的首地址，然后每执行一条指令，PC加 1，以指出下条指令的地址，直到程序结束。 跳跃寻址 当程序中出现分支或循环时，就会改变程序的执行顺序。此时，对指令寻址就要采取跳跃寻址方式。所谓跳跃，就是指下条指令的地址不是通过程序计数器PC加1获得的，而是由指令本身给出。 隐含寻址 这种类型的指令，不是明显地给出操作数的地址，而是指令中隐含着操作数的地址。 在指令中不明显的给出而是隐含着操作数的地址。例如，单地址的指令格式，没有在地址字段中指明第二操作数地址，而是规定累加寄存器AC作为第二操作数地址，AC对单地址指令格式来说是隐含地址 立即寻址 指令的地址字段指出的不是操作数的地址，而是操作数本身，这种寻址方式称为立即寻址。立即寻址方式的特点是指令执行时间很短，因为它不需要访问内存取数，从而节省了访问内存的时间 例如：单地址的移位指令格式为 这里，D不表示地址，而是表示某寄存器中存放的操作数需要移位的次数，因此D可看做移位指令的操作数。F为标志位，当F=1时，进行右移；当F=0时，进行左移。 直接寻址 直接寻址是一种基本的寻址方法，其特点是：在指令格式的地址字段中直接指出操作数在内存的地址D。由于操作数的地址直接给出而不需要经过某种变换或运算，所以称这种寻址方式为直接寻址方式。 间接寻址 间接寻址是相对于直接寻址而言的，在间接寻址的情况下，指令地址字段中的形式地址D不是操作数的真正地址，而是操作数地址的指示器，或者说D单元的内容才是操作数的有效地址。 寄存器寻址和寄存器间接寻址方式 当操作数不放在内存中，而是放在中央处理器的通用寄存器中时，可采用寄存器寻址方式。显然，此时指令中给出的操作数地址不是内存的地址单元号，而是通用寄存器的编号，操作数在CPU的内部寄存器中。如：(AX，BX，CX，DX) 寄存器间接寻址方式与寄存器寻址方式的区别在于：指令格式中的寄存器内容不是操作数，而是操作数的地址，该地址指明的操作数在内存中。 相对寻址 把程序计数器PC的内容加上指令格式中的形式地址D而形成操作数有效地址。程序计数器的内容就是当前指令的地址。 因此，所谓“相对”寻址，就是相对于当前指令地址而言。采用相对寻址方式的好处是程序员勿需用指令的绝对地址编程，因而所编程序可以放在内存任何地方。 变址和基址寻址方式 变址寻址方式与基址寻址方式有点类似，它们都是把某个变址寄存器或基址寄存器的内容，加上指令格式中的形式地址而形成操作数的有效地址。 但使用变址寻址方式的目的不在于扩大寻址空间，而在于实现程序块的规律变化。 复合寻址方式 复合寻址方式是把间接寻址方式同相对寻址方式或变址相结合而形成的寻址方式。它分为先间接方式与后间接方式两种 变址间接式 这种寻址方式是先把变址寄存器的内容A和形式地址D相加得A+D，然后间接寻址，求得操作数的有效地址。操作数的有效地址为E=（A+D） 间接变址式 这种寻址方式是先将形式地址取间接变换（D）=N然后把N和变址寄存器的内容A相加，即得操作数的有效地址。 操作数的有效地址表达式为E=A+（D）=A+N 块寻址 通常在指令中指出数据块的起始地址和数据块的长度，常用在输入输出指令中 多用于I/O指令。对顺序连续的成块数据字进行寻址 目的：压缩程序的长度，加块执行速度 用于 两个部件间的数据交换 程序，数据块的浮动。 若块的长度可变，格式如下 段寻址 以8086的段寻址为例。这种寻址方式的实质是基址寻址。Intel 8086/8088微机中，ALU16位运算，但其寻址范围可到1M，即地址有20位。 操作数寻址方式设计的要求 指令内包含的地址尽可能短； 短地址指令占存储空间小，且能减少存储时间。 能访问尽可能大的存储空间 地址能隐含在寄存器里； 寄存器字长与机器字长相同,一般对应整个存储空间。这样在发生大跨步跳跃时,用短指令也行 希望在不改变指令的情况下改变地址的实际值；能够处理数组,表格或数据串。 寻址方式尽可能简单 例：一种二地址RS型指令的结构如下所示 分析指令格式及寻址方式特点 指令格式及寻址方式的特点如下： 单字长二地址指令；RR型 操作码可指定16条指令 源和目的均有8种寻址方式； 源地址寄存器和目的地址寄存器均有8个 ","date":"2024-04-15","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%864/:1:1","tags":["计算机组成原理"],"title":"计算机组成(第四章)","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%864/"},{"categories":["计算机组成原理"],"content":"堆栈寻址方式 堆栈——能存取数据的暂时存储单元. 串联堆栈 一组专门的寄存器，一个R保存一个数据。 数据的传送在栈顶和累加器之间进行。 特点:速度高，后进先出。 存储器堆栈 用一部分主存空间作堆栈. 优点 长度可随意; 堆栈的数目可随意指定; 寻址简单——–用访内指令. 硬件支持: SP—堆栈指示器(栈指针),CPU中一个专门寄存器。 SP的内容是栈顶的单元地址。改变SP的内容即可移动栈顶的位置 注意:主存中某一部分作为堆栈区后，该部分不能作其它用途 进栈——–累加器中的数送堆栈保存 出栈——-将堆栈中的数取出送累加器 8086 堆栈指令 设sp的初值 MOV sp, im 采用下推式 （PUSH DOWN） 堆栈的最大容量为sp的初值与ss间的距离。 例：PUSH AX 注意： 存储器堆栈中，进栈时先存入数据，后修改堆栈指示器；出栈时，先修改堆栈指示器，然后取出数据。 典型指令 一台计算机最基本的、必不可少的指令是不多的，因为很多指令都可以用这些最基本的指令组合来实现 既可以直接用硬件实现，也可以用其他指令编成子程序来实现，但两者在执行时间上差别很大，因此在指令系统中，有相当一部分指令是为了提高程序的执行速度和便于程序员编写程序而设置的 另外，指令系统的有效性还表现在用它所编制的程序占用的存储器空间小。 分类（8088/8086） 数据传送类 取数 MOV AX，TEMP 存数 MOV TEMP，AX 传送 MOV AX，CX 算术运算类 定点＋，－，×，÷，ADD，ADC（带进位加法），INC（自加1），SUB，DEC（操作数减1），MUL（乘），DIV（除）等 浮点＋，－，×，÷ ，求反，求补 NEG，比较 CMP 逻辑运算类 NOT，AND，OR，XOR，TEST（不保存结果的AND） 程序控制类 无条件转移 JMP 条件转移 C，Z，S，P，O 转子程序 JSR 子程序返回 RET 中断返回 IRET 输入/输出类 IN AX，n OUT n, AX 其他类 标志操作 CLC（clear carry flag)\rSTC (set carry flag) CLI (clear interrupt elable flag)\rHLT，WAIT，ESC，LOCK 指令和指令系统——指令的使用 CISC和RISC CISC：复杂指令系统 RISC：精简指令系统 CISC的问题 庞大的指令集 纷繁复杂的寻址模式 硬件实现复杂（硬件资源的利用率低） 精简指令集结构 RISC的理由 减小代码空间 精简指令集结构的特征 每周期一条指令 寄存器-寄存器操作（除Load/Store类型结构 简单的寻址方式 简单的指令格式 RISC指令系统的最大特点是： 选取使用频率最高的一些简单指令，指令条数少； 指令长度固定，指令格式种类少； 只有取数／存数指令访问存储器，其余指令的操作都在寄存器之间进行。 ","date":"2024-04-15","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%864/:1:2","tags":["计算机组成原理"],"title":"计算机组成(第四章)","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%864/"},{"categories":["操作系统"],"content":"存储器管理 ","date":"2024-04-10","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F4/:0:0","tags":["操作系统"],"title":"操作系统(第四章)","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F4/"},{"categories":["操作系统"],"content":"存储器 内存 主存 连续分配 单一 分区 离散分配 分页式 分段式 段页式 虚拟(主+辅) 请求式分页 请求式分段 请求式段页 外存(第五章) ","date":"2024-04-10","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F4/:1:0","tags":["操作系统"],"title":"操作系统(第四章)","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F4/"},{"categories":["操作系统"],"content":"程序的运行与存储器的关系 地址转换 逻辑地址|相对地址 物理地址|绝对地址 重定位：$逻辑地址 \\rightarrow 物理地址$ 两种重定位 静态：地址只能一次修改 动态：地址的多次修改 区别：增加了一个重定位寄存器(存放内存的起始地址) ","date":"2024-04-10","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F4/:2:0","tags":["操作系统"],"title":"操作系统(第四章)","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F4/"},{"categories":["操作系统"],"content":"连续分配 为用户作业分配的内存空间 单一连续 分区式 把内存分成若干个连续的分区，每个分区都可以存储一个作业 固定式 分区大小相等 分区大小不相等 可变式(动态分区分配) $分区分配算法 \\rightarrow 分区链接的要求$ 首次适应算法 要求：$由低地址 \\rightarrow 高地址链接$ 循环首次适应算法 要求：$由低地址 \\rightarrow 高地址链接$ 最佳适应算法(最容易产生外零头) 要求：按大小：$从小 \\rightarrow 大链接$ 最坏性算法 要求：按大小：$从大 \\rightarrow 小链接$ 碎片的处理方式： 设置分区单位：粒度(1KB) $碎片 \\leq 粒度$：可以分配作业 $碎片 \\geq 粒度$：可以进行二次分配 重定位 动态重定位：程序可以移动(整理碎片)$\\rightarrow$紧凑 ","date":"2024-04-10","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F4/:3:0","tags":["操作系统"],"title":"操作系统(第四章)","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F4/"},{"categories":["操作系统"],"content":"离散分配 分页式 页/页面，页框/物理块，逻辑地址/物理地址，页表，逻辑地址$\\rightarrow$物理地址 例： 某虚拟存储器的用户编程空间共32个页面，每页为1KB，内存为16KB。假定某时刻一用户页表中已调入内存的页面对应的物理块号如下表 则逻辑地址093C（H）所对应的物理地址为 ？ 解： 逻辑地址：$32 \\times 1KB = 32KB \\rightarrow 2^{15} \\rightarrow 15bit$ 每页大小:$1KB \\rightarrow 2^{10} \\rightarrow 10bit(页内地址)$ 15-10=5bit(页号) 000(0) 1001(9) 0011(3) 1100(C) (逻辑地址为15位，所以093C转换为2进制也为15位) 内存：$16KB=2^{14}$ 物理地址：14bit 低10bit，块内地址(页内地址) 高 4bit，块号 01/0001/0011/1100 即物理地址为：113C(H) 例： 对于表所示的段表：请将逻辑地址(0,137),(1,4000),(2,3600),(5,230)转换成物理地址 解： (0,137) 137\u003c10K ,段号0存在 转换为物理地址为：$50 \\times 1024 + 137=51337$ (1,4000) 4000\u003e3K,产生中断，无法转换 (2,3600) 3600\u003c5K,段号2存在 转换为物理地址为：$70 \\times 1024 + 3600=75280$ (5,230) 段号不存在，无法转换 例： 已知分页系统，逻辑空间32个页面，每页大小2KB，内存空间1MB 画出逻辑地址格式 如果不考虑访问权限，页表有多少项，每项至少需要多少位 32个页面=32项 内存(MB)：$\\frac{1MB}{2KB}=\\frac{1\\times 2^{20}}{2^{11}}=2^9$个 每项至少需要多9位 如果内存减少一半，则页表会发生怎么变化？ 32个页表项不变 内存：$1MB \\rightarrow 512KB$ $\\frac{2^{19}}{2^{11}}=2^8$ 每项至少需要的位从9位变为8位 ","date":"2024-04-10","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F4/:4:0","tags":["操作系统"],"title":"操作系统(第四章)","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F4/"},{"categories":["操作系统"],"content":"地址变换机构(逻辑$\\rightarrow$ 物理) 基本的地址变换(5个部分) 页表寄存器：页表地址，页表长度 越界中断机构：页表与页表长度 $\\geq$，越界 \u003c，访问页表 逻辑地址 页表：页表起始+页号 物理地址：块号与页内地址拼接而成 访问内存两次 访问页表 物理地址 有快表的地址转换 增加了快表寄存器：将经常会访问的页面以及它的块号 内存 命中快表：1次 未命中快表：2次 ","date":"2024-04-10","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F4/:5:0","tags":["操作系统"],"title":"操作系统(第四章)","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F4/"},{"categories":["操作系统"],"content":"分段式 段，逻辑地址，物理地址，段表，地址转换 段表：段号，段长，基址组成 地址变换：$逻辑地址 \\rightarrow 物理地址$ 段表寄存器：段表始址，段表长度 越界中断机构 两次越界中断比较 段号与段长关系 \u003e，中断 \u003c，访问段表 段内地址连续与段长 \u003e，中断 $\\leq$，可以转换 逻辑地址 段表 物理地址(基址+段内地址) 两次访问内存 访问段表 物理地址 ","date":"2024-04-10","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F4/:6:0","tags":["操作系统"],"title":"操作系统(第四章)","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F4/"},{"categories":["操作系统"],"content":"分页与分段区别 页是信息的物理单位，段是逻辑单位 页长度是固定的，段长度不固定(由用户指定) 一维与二维 问：分页与分段实现共享，哪个更容易实现信息共享？ 答：分段 ","date":"2024-04-10","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F4/:7:0","tags":["操作系统"],"title":"操作系统(第四章)","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F4/"},{"categories":["计算机算法设计与分析"],"content":"贪心算法 ","date":"2024-04-10","objectID":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E7%A8%8B%E5%BA%8F4/:0:0","tags":["计算机算法设计与分析"],"title":"算法与程序(第四章)","uri":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E7%A8%8B%E5%BA%8F4/"},{"categories":["计算机算法设计与分析"],"content":"贪心算法的基本要素 贪心算法通过一系列选择来得到问题的解，所做的每个选择都是当前状态下局部最好选 择，即贪心选择。这种启发式的策略并不总能奏效，但在许多情况下确能达到预期目的。 从许多可以用贪心算法求解的问题中可以看到，它们一般具有两个重要的性质：贪心选择性质和最优子结构性质。 贪心选择性质 贪心选择性质是指，所求问题的整体最优解可以通过一系列局部最优的选择，即贪心选 择来达到。这是贪心算法可行的第一个基本要素，也是贪心算法与动态规划算法的主要区别。在动态规划算法中，每步所做的选择往往依赖于相关子问题的解。 最优子结构性质 当一个问题的最优解包含其子问题的最优解时，称此问题具有最优子结构性质。问题的 最优子结构性质是该问题可用动态规划算法或贪心算法求解的关键特征 贪心算法与动态规划算法的差异 贪心算法和动态规划算法都要求问题具有最优子结构性质 0-1 背包问题 给定 n 种物品和一个背包。物品 i 的重量是 wi，其价值为 vi，背包的容 量为 c。问应如何选择装入背包中的物品，使得装入背包中物品的总价值最大？ 在选择装入背包的物品时，对每种物品 i 只有两种选择，即装入背包或不装入背包。不 能将物品 i 装入背包多次，也不能只装入部分的物品 i 此问题的形式化描述是，给定 $c\u003e0，w_i\u003e0，v_i\u003e0（1≤i≤n）$，要求找出一个 n 元的 0-1 向 量$(x_1, x_2, …, x_n)$，$x_i∈{0, 1}$，1≤i≤n，使得 $\\stackrel{n}{\\underset{i=1}{\\sum}}w_ix_i \\leq c$，而且 $\\stackrel{n}{\\underset{i=1}{\\sum}}v_ix_i$达到最大 背包问题 与 0-1 背包问题类似，不同的是在选择物品 i（1≤i≤n）装入背包时，可以选择物品 i 的一部分，而不一定要全部装入背包 此问题的形式化描述是，给定 $c\u003e0，w_i\u003e0，v_i\u003e0（1≤i≤n）$，要求找出一个 n 元向量$(x_1, x_2, …, x_n)（0≤x_i≤1，1≤i≤n）$，使得 $\\stackrel{n}{\\underset{i=1}{\\sum}}w_ix_i \\leq c$，而且 $\\stackrel{n}{\\underset{i=1}{\\sum}}v_ix_i$达到最大。 这两类问题都具有最优子结构性质。 虽然这两个问题极为相似，但背包问题可以用贪心算法求解，而 0-1 背包问题不能用贪 心算法求解。用贪心算法解背包问题的基本步骤是 首先计算每种物品单位重量的价值 $v_i/w_i$； 依贪心选择策略，将尽可能多的单位重量价值最高的物品装入背包。 若将这种物品全部 装入背包后，背包内的物品总重量未超过 c，则选择单位重量价值次高的物品并尽可能多地 装入背包 算法结束 算法描述 void Knapsack(int n, float M, float v[], float w[], float x[]) { Sort(n, v ,w); int i; for (i=1; i \u003c= n; i++) x[i] = 0; float c = M; for (i=1; i \u003c= n; i++) { if (w[i]\u003ec) break; x[i] = 1; c −= w[i]; } if (i \u003c= n) x[i]=c/w[i]; } 算法 Knapsack 的主要计算时间在于，将各种物品依其单位重量的价值从大到小排序。 因此，算法的计算时间上界为 O(nlogn)。 ","date":"2024-04-10","objectID":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E7%A8%8B%E5%BA%8F4/:1:0","tags":["计算机算法设计与分析"],"title":"算法与程序(第四章)","uri":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E7%A8%8B%E5%BA%8F4/"},{"categories":["计算机算法设计与分析"],"content":"最优装载 有一批集装箱要装上一艘载重量为 c 的轮船。其中集装箱 i 的重量为 wi。最优装载问题 要求在装载体积不受限制的情况下，将尽可能多的集装箱装上轮船 式中，变量 $x_i=0$ 表示不装入集装箱 i，$x_i=1$ 表示装入集装箱 i 算法描述 最优装载问题可用贪心算法求解。采用重量最轻者先装的贪心选择策略，可产生最优装 载问题的最优解。具体算法描述如下 template\u003cclass Type\u003e void Loading(int x[], Type w[], Type c, int n) { int *t = new int [n+1]; Sort(w, t, n); for (int i=1; i \u003c= n; i++) x[i]=0; for (int i=1; i \u003c= n \u0026\u0026 w[t[i]] \u003c= c; i++) { x[t[i]] = 1; c -= w[t[i]]; } } 贪心选择性质 设集装箱已依其重量从小到大排序，$(x_1, x_2, …, x_n)$是最优装载问题的一个最优解，设$ k= \\underset{1 \\leq i \\leq n}\\min {i|x_i=1}$，如果给定的最优装载问题有解，则 1≤k≤n。 当 k=1 时，(x1, x2, …, xn)是一个满足贪心选择性质的最优解。 当 k\u003e1 时，取 $y_1=1，y_k=0，y_i=x_i，1\u003ci≤n，i≠k$，则 因此，$(y_1, y_2, …, y_n)$是所给最优装载问题的可行解。 另一方面，由 $\\stackrel{n}{\\underset{i=1}{\\sum}}y_i=\\stackrel{n}{\\underset{i=1}{\\sum}}x_i$ 知，$(y_1, y_2, …, y_n)$是满足贪心选择性质的最优解。所以，最优 装载问题具有贪心选择性质 该证明方法只证明了任何一个最优解都可以转换为第一个集装箱上船的最优解(满足贪心策略)，此方法对于子问题同样有效，因此可将一个普通最优解转换为满足贪心策略的最优解 最优子结构性质 设$(x_1, x_2, …, x_n)$是最优装载问题的满足贪心选择性质的最优解，则 $x_1=1，(x_2, x_3, …, x_n)$ 是轮船载重量为 $c−w_1$、待装船集装箱为{2, 3, …, n}时相应最优装载问题的最优解。也就是 说，最优装载问题具有最优子结构性质。 ","date":"2024-04-10","objectID":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E7%A8%8B%E5%BA%8F4/:2:0","tags":["计算机算法设计与分析"],"title":"算法与程序(第四章)","uri":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E7%A8%8B%E5%BA%8F4/"},{"categories":["计算机算法设计与分析"],"content":"哈夫曼编码 ","date":"2024-04-10","objectID":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E7%A8%8B%E5%BA%8F4/:3:0","tags":["计算机算法设计与分析"],"title":"算法与程序(第四章)","uri":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E7%A8%8B%E5%BA%8F4/"},{"categories":["计算机算法设计与分析"],"content":"哈夫曼编码 ","date":"2024-04-10","objectID":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E7%A8%8B%E5%BA%8F4/:3:1","tags":["计算机算法设计与分析"],"title":"算法与程序(第四章)","uri":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E7%A8%8B%E5%BA%8F4/"},{"categories":["计算机算法设计与分析"],"content":"单源最短路径 给定带权有向图G =(V,E)，其中每条边的权是非负实数。V中的一个顶点，称为源。计算从源到所有其他各顶点的最短路径长度。 这个问题通常称为单源最短路径问题 路径长度是指路径上各边权之和。 算法基本思想 Dijkstra算法是解单源最短路径问题的贪心算法。 设置顶点集合S并不断地作贪心选择来扩充这个集合。一个顶点属于集合S当且仅当从源到该顶点的最短路径长度已知 初始时，S中仅含有源 从源只经过S中顶点到达u（S外）称为从源到u的特殊路径，用数组dist记录当前每个顶点的最短特殊路径长度。最短特殊路径长度最小的为最短路径已知。 每次从V-S中取出最短路径长度已知的顶点u，将u添加到S中，同时对数组dist作必要的修改。直到S包含了所有V中顶点 算法演示 算法的正确性和计算复杂性 贪心选择性质 最优子结构性质 计算复杂性 外循环需要执行n-1次（即n-1个顶点加入s集合） 内循环执行O(n)时间（更改最短特殊路径长度、找最短路径长度已知的顶点加入s）。 所以算法需要$O(n^2)$时间。 ","date":"2024-04-10","objectID":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E7%A8%8B%E5%BA%8F4/:4:0","tags":["计算机算法设计与分析"],"title":"算法与程序(第四章)","uri":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E7%A8%8B%E5%BA%8F4/"},{"categories":["计算机算法设计与分析"],"content":"最小生成树 设G =(V,E)是无向连通带权图，即一个网络 E中每条边(v,w)的权为c[v][w]。 如果G的子图G’是一棵包含G的所有顶点的树，则称G’为G的生成树 生成树上各边权的总和称为该生成树的耗费 在G的所有生成树中，耗费最小的生成树称为G的最小生成树(Minimum Spanning Tree )，简称MST 最小生成树性质 用贪心算法设计策略可以设计出构造最小生成树的有效算法。Prim算法和Kruskal算法,这2个算法做贪心选择的方式不同，但它们都利用了最小生成树性质（贪心策略） 设G=(V,E)是连通带权图，U是V的真子集。如果$(u,v)\\in E$，且$u\\in U，v\\in V-U$，且在所有这样的边中，(u,v)的权c[u][v]最小，那么一定存在G的一棵最小生成树，它以(u,v)为其中一条边。这性质有时也称为MST(最小生成树）性质。 MST在现实世界中应用非常广泛 交通 电信 网络通信 集成电路布线 最优子结构证明 Prim算法（选顶点加入集合S） 设G=(V,E)是连通带权图，V={1,2,…,n}。 构造G的最小生成树的Prim算法的基本思想是： 首先置S={1}， 然后，只要S是V的真子集，就作如下的贪心选择：选取满 足条件$i\\in S，j\\in V-S$，且c[i][j]最小的边，将顶点j添加到S中 这个过程一直进行到S=V时为止 在这个过程中选取到的所有边恰好构成G的一棵最小生成树 Prim算法 Kruskal算法(选择连接属于两个不同连通分支的最小边） 首先将G的n个顶点看成n个孤立的连通分支。 所有的边按权从小到大排序 顺序检查每条边，如果一条边的端点v和w分别是当前2个不同的连通 分支T1和T2，用边(v,w)将T1和T2连接成一个连通分支，否则放弃这条边。 该过程一直到只剩一个连通分支时为止(或者说选择了n-1条边为止） 例如，对前面的连通带权图，按Kruskal算法顺序得到的最小生成树上的边如下图所示。 ","date":"2024-04-10","objectID":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E7%A8%8B%E5%BA%8F4/:5:0","tags":["计算机算法设计与分析"],"title":"算法与程序(第四章)","uri":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E7%A8%8B%E5%BA%8F4/"},{"categories":["计算机算法设计与分析"],"content":"对比 当图的边数为e时，Kruskal算法所需的计算时间是 ， Prim算法是O(n2）。 当 时，Kruskal算法比Prim算法差，但当 时，Kruskal算法却比Prim算法好得多。 ","date":"2024-04-10","objectID":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E7%A8%8B%E5%BA%8F4/:5:1","tags":["计算机算法设计与分析"],"title":"算法与程序(第四章)","uri":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E7%A8%8B%E5%BA%8F4/"},{"categories":["计算机算法设计与分析"],"content":"贪心选择性质 局部最优即全局最优 证明 ","date":"2024-04-10","objectID":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E7%A8%8B%E5%BA%8F4/:5:2","tags":["计算机算法设计与分析"],"title":"算法与程序(第四章)","uri":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E7%A8%8B%E5%BA%8F4/"},{"categories":["计算机算法设计与分析"],"content":"多机调度问题 多机调度问题要求给出一种作业调度方案，使所给的n个作业在尽可能短的时间内由m台机器加工处理完成。 约定，每个作业均可在任何一台机器上加工处理，但未完工前不允许中断处理。作业不能拆分成更小的子作业 这个问题是NP完全问题，到目前为止还没有有效的解法。对于这一类问题,用贪心策略有时可以设计出较好的近似算法 采用最长处理时间作业优先的贪心选择策略可以设计出解多机调度问题的较好的近似算法 当 时$n \\leq m$，只要将机器i的[0, ti]时间区间分配给作业i即可，算法只需要**O(1)**时间 当 时n\u003em，首先将n个作业依其所需的处理时间从大到小排序。然后依此顺序将作业分配给占用时间少的处理机。算法所需的计算时间为 O(nlogn) 例如，设7个独立作业{1,2,3,4,5,6,7}由3台机器M1，M2和M3加工处理。各作业所需的处理时间分别为{2,14,4,16,6,5,3} ","date":"2024-04-10","objectID":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E7%A8%8B%E5%BA%8F4/:6:0","tags":["计算机算法设计与分析"],"title":"算法与程序(第四章)","uri":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E7%A8%8B%E5%BA%8F4/"},{"categories":["编译原理"],"content":"语法分析——自底向上分析 **自底向上的语法分析需要解决的关键问题是：如何确定可归约串（即可以归约的字符串）以及每个可归约串用哪个产生式左部的非终结符来归约？针对这些问题的不同解决方法，本章将描述以下两类分析算法：算法优先分析法和LR分析法。其中，LR分析法在目前编译程序中的应用最为广泛，它包括一组分析能力不同的四个算法，按照分析能力从弱到强分别是：LR（0）、SLR（1）、LALR（1）和LR（1）。 ** ","date":"2024-04-10","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%865/:0:0","tags":["编译原理"],"title":"编译引论(第五章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%865/"},{"categories":["编译原理"],"content":"自底向上的语法分析概述 ","date":"2024-04-10","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%865/:1:0","tags":["编译原理"],"title":"编译引论(第五章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%865/"},{"categories":["编译原理"],"content":"自底向上语法分析器的体系结构 它主要包括四个组成部分：待分析的输入符号串、分析栈、语法分析总控程序以及语法分析表。 在自底向上的语法分析过程中，语法分析的总控程序从左向右地逐个扫描输入字符，根据栈顶元素A和输入符号a所构成的二元组\u003cA，a\u003e查语法分析表，以执行不同的分析动作。其分析动作一共有四种，分别如下： 移进：把输入串的当前符号a压入栈顶，并把指针指向下一个输入符号； 归约：把自栈顶A向下的若干个符号用某个产生式左端的非终结符替换； 接受：表示语法分析成功，此时分析栈的指针指向栈内的唯一符号（即文法的开始符号），输入串指针指向结束符号#； 出错：发现源程序有语法错，调用出错处理程序。 ","date":"2024-04-10","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%865/:1:1","tags":["编译原理"],"title":"编译引论(第五章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%865/"},{"categories":["编译原理"],"content":"自底向上分析的归约过程 例： 实际上，规范归约过程是最右推导的逆过程，从表5.1可以看出，表中从下往上的六个归约正好对应了最右推导（规范推导）的六个步骤 $E \\Rightarrow E+T \\Rightarrow E+F \\Rightarrow E+i \\Rightarrow T+i \\Rightarrow F+i \\Rightarrow i+i$ 显然，该语法分析过程还可以用一棵语法分析树表示出来。 ","date":"2024-04-10","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%865/:1:2","tags":["编译原理"],"title":"编译引论(第五章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%865/"},{"categories":["编译原理"],"content":"LR分析法 ","date":"2024-04-10","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%865/:2:0","tags":["编译原理"],"title":"编译引论(第五章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%865/"},{"categories":["编译原理"],"content":"LR分析法概述 LR分析法是一类分析方法的简称，通常记为LR(k)分析法 L是指从左至右方式扫描输入串； R是指最右推导(规范推导)的逆过程； K是指每次根据当前输入符号最多向前查看K个符号就可以确定下一步动作； 本章重点介绍LR(0) 分析表的构造算法及相关知识。 规范归约（最左归约一最右推导的逆过程）的关键问题是寻找句柄。在一般的“移进-归约”过程中，当一串貌似句柄的符号串出现在栈顶时，用什么方法来判断它是否为一个真正的句柄呢? LR方法的基本思想是，在规范归约过程中，一方面记住已移进和归约出的整个符号串，即记住“历史”，另一方面根据所用的产生式推测未来可能碰到的输入符号，即对未来进行“展望”。当一串貌似句柄的符号串呈现于分析栈的顶端时，我们希望能够根据所记载的“历史”和“展望”以及“现实”的输入符号等三方面的材料，来确定栈顶的符号串是否构成相对某一产生式的句柄 LR(k)分析器的结构 分析栈（含状态栈和符号栈） 总控程序（也称为驱动程序） 分析表（分析动作表和状态转换表） LR分析表构成 LR分析表是LR分析器的核心部分,它由两张表组成:一是动作表(即action表);二是状态转换表(即goto表),见表5.6。表中的$S_1,S_2,…, S_n$为分析器的各个状态；$a_1,a_2,…,a_m$为文法的全部终结符号及右界符’#’；$A_1,A_2,…,A_k$为文法的非终结符号。 在action表中，$action[S_i,a_j]$（即$S_i$所在的行与$a_j$所在的列对应的单元）表示当分析状态栈的栈顶为$S_i$，输入符号为$a_j$时应执行的动作。 在goto表中，$goto[S_i,A_j]$（即$S_i$行$A_j$列对应的单元）表示当前状态为$S_i$而符号栈顶为非终结符号$A_j$后应移入状态栈的状态。 action表的动作有以下4种: 移进($S_m$)。将输入符号$a_j$移进符号栈,将状态m移进状态栈,输入指针指向下一个输入符号。 归约($r_j$)。当栈顶形成句柄时,按照第j条产生式（如U→ω）进行归约。若产生式右部ω的长度为x,则将符号栈栈顶x个符号和状态栈栈顶x个状态出栈,然后将归约后的文法非终结符号U移入符号栈,并根据此时状态栈顶的状态$S_i$及符号栈顶的符号U,查goto表,将$goto[S_i,U]$移入状态栈。 接受(acc)。当输入符号串到达右界符’#‘时,且符号栈只有文法的开始符号时,则宣布分析成功,接受输入符号串。 报错(Error)。当状态栈顶的状态为$S_i$时,如果输入符号为不应该遇到的符号时,即$action[S_i,a_j]$=空白,则报错,调用出错处理程序。 LR分析步骤 将初始状态0、句子的左界符#分别进状态栈和符号栈。 从输入串中读入当前输入符a，然后由状态栈栈顶元素i与当前输入字符a查action表，决定应取何种动作。 若$action[i,a]=s_j$，则将状态j及相应的输入符a分别移入状态栈和符号栈栈顶。 若$action[i,a]=r_j$，则按第j个生产式A→β右部符号β的长度t分别将符号栈、状态栈栈顶t个元素上托出栈，将归约后的A移入符号栈。据此时状态栈栈顶元素 i与归约后的非终结符A，查goto表的[i，A]项，设得到状态j，则将状态j移入状态栈栈顶。 若为action[i,a]=acc，则结束分析，输入串被接受。 否则转错误处理程序。 重复2的工作，直到接受或出错为止。 例： ","date":"2024-04-10","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%865/:2:1","tags":["编译原理"],"title":"编译引论(第五章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%865/"},{"categories":["编译原理"],"content":"LR(0)分析器 **拓广文法 ** 给定文法G，S是其开始符号，G的拓广文法是G，其开始符号为S，区别在于后者仅增加一个产生式$S’ \\rightarrow S$,把它作为第0个产生式添加到文法G中。 例如：文法G[A]: $A \\rightarrow (A) , A \\rightarrow a$ 则该文法的拓广文法G ‘[A ‘]： $A’ \\rightarrow A， A \\rightarrow (A)，A \\rightarrow a $ 活前缀与可规前缀 自下而上的移进——规约分析，是对句柄进行规范规约，它是规范推导的逆过程，规范推导出来的句型是规范句型。一个符号串的前缀是指该串的任意首部，包括$\\varepsilon$。 对于一个规范句型来说,其活前缀定义如下: 设λβt是一个规范句型,即λβt是能用最右推导得到的句型,其中β表示句柄,$t∈V_T^*$ ,如果$λβ= u_1u_2…u_r$,那么称符号串$u_1u_2…u_i$(其中l≤i≤r)是句型λβt的活前缀。 从活前缀的定义可知,一个规范句型的活前缀可以有多个,但观察这些活前缀,会发现其中活前缀$u_1,u_1u_2, u_1u_2…u_{r-1}$不含有完整句柄β,只有活前缀$u_1u_2…u_r$含有完整句柄β,那么这个含有句柄的活前缀$u_1u_2…u_r$称为可归前缀,是最长的活前缀。 从上述定义可知，活前缀不含句柄右边的任意符号,而可归前缀是含有句柄的活前缀。对一个规范句型来说，活前缀可有多个,可归前缀只有一个。 例： LR(0)项目 定义：在文法G的每一个产生式右部的某个位置添加一个“·”，点号左边表示该产生式的右部在符号栈的栈顶已经出现的部分，点号右边表示如果要用该产生式进行规约，还应该出现的部分。 一般产生式$A\\rightarrow β$对应的项目个数为| β |+1，特别地，产生式$A \\rightarrow ε$的项目个数为1，即$A\\rightarrow .$ $A \\rightarrow ·AB $ 希望看到从输入串中与AB对应的符号串。 $A \\rightarrow A·B $ 已识别出由A对应的输入符号，并希望看到与B对应的输入串。 $A \\rightarrow AB· $ 与AB对应的输入串已经识别出来，可以进行规约 项目的分类 不同的项目反映了分析过程中栈顶的不同情况，因此我们可以根据它们的不同作用，将一个文法的全部L(0)项目进行分类： 对于形如$A\\rightarrow α·$ 项目，因为它表示右部符号串α(可为ε)已经出现在栈顶，此时相应的动作应该是按此产生式进行归约，故将此项目称为归约项目。 项目$S’ \\rightarrow S·$仅用于分析过程中最后一次归约，所以称为接受项目。 对于形如$A\\rightarrow α· Xβ$的项目，其中α可以为空符号串： 当X为终结符号时，相应的分析动作应该将当前的输入符号移入栈中，我们称它为移进项目； 当X为非终结符号时，由于我们期待着从余留的输入串中进行归约而得到X，因此此类项目为待约项目； 注： 有的书上还把$S’ \\rightarrow · S$称为开始项目，也可称为待约项目 例： LR(0)项目集规范族的构造 项目集的闭包运算 设I为项目集（即由项目组成的集合），构造I的闭包函数CLOSURE(I)的算法如下 I中的每一基本项目都属于它； 若$A\\rightarrow \\alpha ·B \\beta$属于CLOSURE(I)，且$B\\rightarrow \\gamma$是文法中的一个产生式，则关于非终结符B的任何形如$B\\rightarrow· \\gamma$的项目也属于它； 重复上述步骤，直到它不再增大为止 项目集之间的转换函数go 设$I_i$是文法的G[S]的一个LR(0)项目集，非空符号$X \\in V_T∪V_N$，定义$I_i$及X间的函数为 $go(I_i, X)=CLOSURE (J) =I_J$ 其中$J={A\\rightarrow \\alpha X·\\beta \\in A\\rightarrow \\alpha·X \\beta \\in I_i}$ 先找出Ii中所有形如$A\\rightarrow \\alpha·X \\beta$的项目； 然后将它们变成$A\\rightarrow \\alpha X·\\beta$放入集合J中； 再求CLOSURE (J)； LR(0)项目集规范族的构造方法 要构造识别所有规范句型全部活前缀的DFA，首先要确定DFA的状态，而每一个状态都是由若干个LR(0)项目组成的集合，称为项目集。对于构成识别一个文法活前缀的DFA的项目集的全体，称为这个文法的LR(0)项目集规范族（ 即DFA的所有状态） 对于LR(0)项目集规范族——在CLOSURE(I)和go(Ii, X)作用下，可获得的项目集的全体C 令$C={I_0}$ ，其中$I_0=CLOSURE$({开始项目，如$S’\\rightarrow ·S$}) 对每个$I_i\\in C$和$I_i$中形如“· X”的项目，若$go(I_i, X)$非空且不属于C，则将$go(I_i, X)$之值加入C 重复2直至C不再增大 构造识别所有规范句型全部活前缀的DFA 方法： 把文法的LR(0)项目集规范族中的每一个项目集作为DFA的一个状态； 把含有开始项目的项目集作为DFA的初态； 每一个项目集都是DFA的终态； 把文法的终结符和非终结符作为DFA的字母表； $go(I_i, X)$作为单值转换函数 构造LR(0)分析表的算法 若项目$A \\rightarrow \\alpha ·x \\beta \\in I_i$ ，且$go(I_i, x)=I_j$ 若$x \\in V_T$ ，则置$ACTION[i , x]= S_j$ 若$x \\in V_N $，则置GOTO[i, x]=j。 若项目$A \\rightarrow \\alpha ·\\in I_i$,对于任何输入符号$a\\in (V_T∪{#})$,则置$ACTION[i,a]=r_j$,即“用第j条产生式$A \\rightarrow \\alpha $进行归约”（这里假定 $ A \\rightarrow \\alpha $ 是G’中的第j条产生式） 若项目$S’ \\rightarrow S· \\in I_k $，则置ACTION[ k , # ]=acc 分析表中凡不能用规则1~3填入信息的元素均置上ERROR（用空白表示） ​ 可以通过识别活前缀的DFA来构造LR(0)分析表 LR（0）分析器的工作过程 分析表是LR分析的关键，有了分析表后就可以在总控程序的控制下对输入符号串进行分析，其分析如下： $action[S,a]=S_j$, S为状态，a为终结符，则把a移入符号栈，状态j移入状态栈 若$action[S,a]=r_j$,a为终结符或’#’,则用第j个产生式归纳约；设k为第j个产生式右部的符号 长度，将符号栈和状态栈顶的k个元素出栈，将产生式左部符号入符号栈； 若action[S,a]=“acc”，a为’#’,则为接受，表示分析成功 若goto[S,A]=j，A为非终结符号并且是符号栈的栈顶，表示前一个动作是归约，A是归约后移入符号栈的非终结符，则将状态j移入状态栈 若action[S，a]=空白，则转入错误处理。 ","date":"2024-04-10","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%865/:2:2","tags":["编译原理"],"title":"编译引论(第五章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%865/"},{"categories":["编译原理"],"content":"构造LR(0)分析表的步骤小结 写出给定文法G的拓广文法G； 写出文法G的基本LR(0)项目——G’的LR(0)项目集； 利用CLOSURE和go函数，求出相应的LR(0)项目集规范族C； 构造识别该文法全部活前缀的DFA 根据算法构造LR(0)分析表。 ","date":"2024-04-10","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%865/:3:0","tags":["编译原理"],"title":"编译引论(第五章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%865/"},{"categories":["编译原理"],"content":"语法分析(2)——SLR(1)分析方法 观察上面的项目集会发现$I_1、I_2$和$I_9$，都存在“移进-归约”冲突。比如项目集I2包含两个项目，其中项目E→T·是归约项目，而另外一个项目E→T·*F是移进项目。故，该文法不是LR（0）文法。 按照LR（0）分析表的构造方法可得到分析表见表。 ","date":"2024-04-10","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%865/:4:0","tags":["编译原理"],"title":"编译引论(第五章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%865/"},{"categories":["编译原理"],"content":"LR(0)文法 如果文法G’的项目集规范族的每个项目集中不存在下述任何冲突项目： 移进项目和归约项目并存； 多个归约项目并存； 则称文法G’为LR(0)文法。 例： ","date":"2024-04-10","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%865/:4:1","tags":["编译原理"],"title":"编译引论(第五章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%865/"},{"categories":["编译原理"],"content":"SLR(1)分析法 例：文法G(S)的LR(0)项目集规范族中有这样一个项目集： $I_3={X\\rightarrow \\alpha · b \\beta， A \\rightarrow \\alpha · ，B \\rightarrow \\alpha · }$ 且假设$go(I_3, b)=I_4 $ $A \\rightarrow \\alpha$ $B \\rightarrow \\alpha$ 分析：由LR(0)项目集规范族构造LR(0)分析表的算法有： 所以 $ACTION[3, b]= S_4$或$r_1$或$r_2$是多重定义元素，故该分析表不是LR(0)分析表，该文法也不是LR(0)文法。 当文法的LR(0)项目集规范族中的项目集出现冲突时，就不能采用LR(0)分析法。实际上，在通过文法的LR(0)项目集规范族构造LR(0)分析表时，若项目$A \\rightarrow \\alpha.\\in I_i$,对于任何输入符号$a\\in (V_T∪{#})$,都置$ACTION[i,a]=r_j$,即“用第j条产生式$A\\rightarrow \\alpha$进行归约”。也就是当$\\alpha$在符号分析栈顶部时，我们就进行归约，此时我们根本就不管下一个输入符号是什么。 当然我们还有其他的分析方法，就是在不改变文法的LR(0)项目集规范族的前提条件下，采用向前看一个输入符号的方法来解决项目集中的冲突(即SLR(1)分析法).只不过虽然允许项目冲突，但此时对于项目集中的项目，还有其它的要求 比如在LR（0）项目集规范族中有这样一个项目集： $I={X \\rightarrow \\alpha · b \\beta， A \\rightarrow \\alpha · ，B \\rightarrow \\alpha · }$ 对于归约项目： $A \\rightarrow \\alpha · ，B \\rightarrow \\alpha · $ 求FOLLOW(A), FOLLOW(B) 对于移进项目： $X \\rightarrow \\alpha · b \\beta$ 求FIRST($b\\beta$) 如果这三个集合存在下列关系： $FOLLOW(A)∩FOLLOW(B)∩ FIRST(b\\beta)= φ $ 则通过向前看一个输入符号，移进或归约动作便可唯一确定，即可采用采用SLR(1)分析法。 ","date":"2024-04-10","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%865/:5:0","tags":["编译原理"],"title":"编译引论(第五章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%865/"},{"categories":["编译原理"],"content":"SLR(1)分析法解决LR(0)项目冲突 设LR(0)项目集规范族的某个项目集I中含有i个移进项目$A_i\\rightarrow \\alpha.a_i \\beta _i$和j个归约项目$B_j\\rightarrow \\alpha$· 若已知集合{$a_1, a_2, …，a_i$}, $FOLLOW(B_1)$, …, $FOLLOW(B_j)$两两不相交，则I中的冲突动作可通过查看当前输入符号a属于上述j+1个集合中的哪一个集合而获得解决，即 若$a\\in {a_1,a_2, …,a_i}$，则移进a； 若$a\\in FOLLOW(B_k)$，k=1,2, …, j，则用产生式$B_k\\rightarrow \\alpha$进行归约 其它则报错 这种解决动作冲突的办法称为SLR(1)分析法 ","date":"2024-04-10","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%865/:5:1","tags":["编译原理"],"title":"编译引论(第五章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%865/"},{"categories":["编译原理"],"content":"SLR分析表的构造 构造SLR(1)分析表的方法： **若项目[$A\\rightarrow \\alpha·X \\beta$]$\\in I_i$且$goto(I_i, X)=I_j$ ** 若X为终结符，则置$ACTION[i,X]= s_j$； 若X为非终结符，则置GOTO[i,A]=j ； 若项目$[A \\rightarrow \\alpha·] \\in I_i$则对所有a(或#)$\\in FOLLOW(A)$，置$ACTION[i,a]= r_k$ ； 若项目$[S’ \\rightarrow S·]\\in I_i$，则置ACTION[i,#]= acc； 分析表中凡没有由步骤1至3所定义的表项都置上ERROR（用空白表示） 如果用上述方法构造的分析表无多重定义元素，则称该分析表为SLR(1)分析表，相应的文法称为SLR(1)文法。 现在按照SLR（1）分析表的构造方法，可以得到SLR（1）分析表，如图1所示。注意与表2比较，从而找出与LR(0)分析表的构造方法的不同点 图1： 图2： 虽然SLR（1）与LR（0）的分析表构造方法略有不同，但它们的分析器的工作过程却完全一样。利用表1分析符号串″i *i#″的分析过程见表3。 例：考虑文法G(S’): 0 $S’\\rightarrow S$ 1 $S \\rightarrow (S)S$ 2 $S \\rightarrow ε $ 分析： 构造识别该文法的所有规范句型的活前缀的DFA，如下图所示 对归约项目左部符号求FOLLOW集，有FOLLOW(S)={ ） ，# } 根据SLR(1)分析表的构造方法，由它的DFA得到分析表如下 同一个DFA，在构造LR(0)分析表和SLR(1)分析表，主要的区别在于：对于归约项目的动作，一个不需要考虑下一个输入符号，而另一个不需要。 ","date":"2024-04-10","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%865/:5:2","tags":["编译原理"],"title":"编译引论(第五章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%865/"},{"categories":["数据结构"],"content":"数组和广义表 ","date":"2024-04-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%845/:0:0","tags":["数据结构"],"title":"数据结构(第五章)","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%845/"},{"categories":["数据结构"],"content":"数组的定义 数组是我们很熟悉的一种数据结构，它可以看作线性表的推广。数组作为一种数据结构其特点是结构中的元素本身可以是具有某种结构的数据，但属于同一数据类型，比如：一维数组可以看作一个线性表，二维数组可以看作“数据元素是一维数组”的一维数组，三维数组可以看作“数据元素是二维数组”的一维数组，依此类推 ","date":"2024-04-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%845/:1:0","tags":["数据结构"],"title":"数据结构(第五章)","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%845/"},{"categories":["数据结构"],"content":"数组的顺序表示 由于数组中各元素具有统一的类型，并且数组元素的下标一般具有固定的上界和下界，因此，数组的处理比其它复杂的结构更为简单。多维数组是一维数组的推广 例如，二维数组A 二维数组A可以看成是由m个行向量组成的向量，也可以看成是n个列向量组成的向量 数组一旦被定义，它的维数和维界就不再改变。因此，除了结构的初始化和销毁之外，数组只有存取元素和修改元素值的操作 由于计算机的内存结构是一维的，因此用一维内存来表示多维数组，就必须按某种次序将数组元素排成一列序列，然后将这个线性序列存放在存储器中 数组一旦建立，结构中的元素个数和元素间的关系就不再发生变化。因此，一般采用顺序存储的方法来表示数组 行优先顺序或以行为主序存储方式：将数组元素按行排列，第i+1个行向量紧接在第i个行向量后面。以二维数组为例，按行优先顺序存储的线性序列为： $a_{11},a_{12},…,a_{1n},a_{21},a_{22},…a_{2n},……,a_{m1},a_{m2},…,a_{mn}$ 在PASCAL、C等语言中，数组就是按行优先顺序存储的。 **$LOC(a_{ij})=LOC(a_{11})+[(i-1)n+j-1]d$ 列优先顺序或以列为主序存储方式：将数组元素按列向量排列，第j+1个列向量紧接在第j个列向量之后，A的m*n个元素按列优先顺序存储的线性序列为 $a_{11},a_{21},…,a_{m1},a_{12},a_{22},…a_{m2},……,a_{n1},a_{n2},…,a_{nm}$ 在FORTRAN语言中，数组按列优先顺序存储 $LOC(a_{ij})=LOC(a_{11})+[(j-1)*m+i-1]*d$ 行优先顺序——先排最右的下标，从右到左，最后排最左下标 列优先顺序——先排最左下标，从左向右，最后排最右下标 例如：三维数组Amnp以行优先方式顺序存储，则 $LOC(a_{ijk})=LOC(a_{111})+[(i-1)mn+ (j-1)*n+(k-1)]*d$ ","date":"2024-04-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%845/:2:0","tags":["数据结构"],"title":"数据结构(第五章)","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%845/"},{"categories":["数据结构"],"content":"数组存储的特点 只要知道开始结点的存放地址（即基地址）、维数和每维的上、下界，以及每个数组元素所占用的单元数，就可以将数组元素的存放地址表示为其下标的线性函数。因此，数组中的任一元素可以在相同的时间内存取，即顺序存储的数组是一个随机存取结构 ","date":"2024-04-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%845/:2:1","tags":["数据结构"],"title":"数据结构(第五章)","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%845/"},{"categories":["数据结构"],"content":"矩阵的压缩存储 压缩存储：为多个值相同的非零元素只分配一个存储空间；对零元素不分配空间 ","date":"2024-04-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%845/:3:0","tags":["数据结构"],"title":"数据结构(第五章)","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%845/"},{"categories":["数据结构"],"content":"特殊矩阵的压缩存储 特殊矩阵：非零元素按照一定的规律分布 常见的特殊矩阵有对称矩阵、三角矩阵、对角矩阵等 对称矩阵：元素的值按照主对角线对称 例如：一个4*4的对称矩阵 推广至一般情况，n*n的对称矩阵 三角矩阵：上(下)三角矩阵是指矩阵的下（上）三角（不包括对角线）中的元素均为常数或零的n阶矩阵，即非零元素的分布在矩阵中呈现为三角形 例如：一个4*4的三角矩阵。 例如：一个4*4的三角矩阵 推广至一般情况，n*n的三角矩阵以行为主序压缩存储 对角矩阵是指所有的非零元素都集中在以主对角线为中心的带状区域中 上述各种特殊矩阵，其非零元素的分布都是有规律的，因此总能找到一种方法将它们压缩存储到一维数组中，并且一般都能找到矩阵中的元素与该一维数组元素的对应关系，通过这个关系，仍能对矩阵的元素进行随机存取 ","date":"2024-04-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%845/:3:1","tags":["数据结构"],"title":"数据结构(第五章)","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%845/"},{"categories":["数据结构"],"content":"稀疏矩阵 什么是稀疏矩阵？简单说，设矩阵A中有s个非零元素，若s远远小于矩阵元素的总数（即s«m×n），则称A为稀疏矩阵 设在矩阵A中，有s个非零元素。令 e=s/(m*n)，称e为矩阵的稀疏因子。通常认为e≤0.05时称之为稀疏矩阵 在存储稀疏矩阵时，由于非零元素的分布一般是没有规律的，因此在存储非零元素的同时，还必须同时记下它所在的行和列的位置（i,j)。反之，一个**三元组(i,j,aij)**惟一确定了矩阵A的一个非零元。因此，稀疏矩阵可由表示非零元的三元组及其行列数唯一确定 例如，一个6*7的稀疏矩阵 稀疏矩阵中的非零元素 ( (1,2,12), (1,3,9), (3,1,-3), (3,6,14), (4,3,24), (5,2,18), (6,1,15), (6,4,-7) ) 假设以顺序存储结构来表示三元组表，则可得到稀疏矩阵的一种压缩存储方法——三元组顺序表 #define maxsize 10000 typedef int datatype; typedef struct{ int i,j; datatype v; }triple; /* 三元组*/ typedef struct{ triple data[maxsize]; int m,n,t; }tripletable; 三元组顺序表上的转置 Void transmatrix(tripletable A, tripletable \u0026AT) { AT.m=A.n; AT.n=A.m; AT.t=A.t; if (AT.t\u003c=0) return; for(p=0;p\u003cA.t;++p) { AT.data[p].i = A.data[p].j; AT.data[p].j = A.data[p].i; AT.data[p].v = A.data[p].v; } //按照AT.data[p].i进行非递减排序 } 设置向量num,num[col]表示矩阵A中第col列中非零元的个数。(A的列数：A.n) for(col=1;col\u003c=A.n;++col) num[col] = 0; for(p=1;p\u003c=A.t;++p) //计算A中每列非零元的个数 num[A.data[p].j]++; //A.data[p].j为列号 设置向量cpot,cpot[col]指示A中第col列的第一个非零元在转置矩阵AT.data中的恰当位置 cpot[1]=1; for(col = 2; col\u003c=A.n; ++col) cpot[col]=cpot[col-1]+num[col-1]; for(col=1;col\u003c=A.n;++col) num[col] = 0; for(p=1;p\u003c=A.t;++p) //计算A中每列非零元的个数 num[A.data[p].j]++; cpot[1]=1; for(col = 2; col\u003c=A.n; ++col) //计算元素位置 cpot[col]=cpot[col-1]+num[col-1]; for(p = 1; p\u003c=A.t; ++p) {//转置 col = A.data[p].j; q = cpot[col]; AT.data[q].i = A.data[p].j; AT.data[q].j = A.data[p].i; AT.data[q].v = A.data[p].v; cpot[col]++; } ","date":"2024-04-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%845/:3:2","tags":["数据结构"],"title":"数据结构(第五章)","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%845/"},{"categories":["数据结构"],"content":"广义表的定义 广义表是线性表的推广 $L=(a_1,a_2,…,a_n ),n≥0,a_i$可以是单元素，也可以是一个表 例如 A = () B = (e) C = (a,(b,c,d)) D = (A,B,C) E = (a,E) 广义表的长度 广义表的深度 非空广义表 表头(Head)：第一个元素 表尾(Tail)：除第一个元素外其余元素构成的表 链表存储 C = (a,(b,c,d)) D = (A,B,C) E = (a,E) 链表结点结构 C = (a,(b,c,d)) Head(C) = a Tail(C)=((b,c,d)) B= (e) A= () D= (A,B,C) 结点结构 typedef enum {ATOM,LIST} ElemTag; typedef struct GLNode{ ElemTag tag; union { AtomType atom; struct GLNode *hp; }; struct GLNode *tp; }*Glist; m元多项式的表示 ","date":"2024-04-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%845/:4:0","tags":["数据结构"],"title":"数据结构(第五章)","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%845/"},{"categories":["数据结构"],"content":"本章小结 本章应掌握的内容 数组的按行存储和按列存储 特殊矩阵的压缩存储 广义表的定义、基本运算(求表头、表尾) 广义表的存储结构 ","date":"2024-04-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%845/:5:0","tags":["数据结构"],"title":"数据结构(第五章)","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%845/"},{"categories":["数据结构"],"content":"树和二叉树 ","date":"2024-04-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%846/:0:0","tags":["数据结构"],"title":"数据结构(第六章)","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%846/"},{"categories":["数据结构"],"content":"树 树：是n（n≥0）个结点的有限集。当n=0时，称为空树；在任意一棵非空树中满足如下条件： 有且仅有一个特定的称为根（root）的结点，它没有直接前驱，但有零个或多个直接后继。 其余n-1个结点可以划分成m（m\u003e0）个互不相交的有限集T1，T2，T3，…，Tm，其中Ti又是一棵树，称为根root的子树。 每棵子树的根结点有且仅有一个直接前驱，但有零个或多个直接后继 从逻辑结构看： 树中只有树根没有父结点； 除根外，其余结点都有且仅一个父结点 树中的结点，可以有零个或多个孩子结点； 没有孩子的结点称为叶子结点，或终端结点 除根外的其他结点，都存在唯一一条从根到该结点的路径 ","date":"2024-04-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%846/:1:0","tags":["数据结构"],"title":"数据结构(第六章)","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%846/"},{"categories":["数据结构"],"content":"树的基本术语 树的结点：包含一个数据元素及若干指向子树的分支； 孩子结点：结点的子树的根称为该 结点的孩子 父结点：B 是A的孩子，则A是B的父亲； 兄弟结点：同一双亲的孩子结点； 堂兄弟结点：其父结点在同一层上的结点； 祖先结点: 从根到该结点所经分支上的所有结点； 子孙结点：以某结点为根的子树中任一结点都称为该结点的子孙 结点的度: 结点的孩子数目 有序树和无序树：在树中，如果各子树Ti是按照一定的次序从左向右安排的，且相对次序是不能随意改变的，则称为有序树，否则称为无序树 森林： m（m≥0）棵互不相交的树的集合。将一棵非空树的根结点删去，树就变成一个森林；反之，给m棵独立的树增加一个根结点，并把这m棵树作为该结点的子树，森林就变成一棵树 ","date":"2024-04-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%846/:1:1","tags":["数据结构"],"title":"数据结构(第六章)","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%846/"},{"categories":["数据结构"],"content":"树的基本运算 树的运算主要分为三大类： 第一类，寻找满足某种特定关系的结点,如寻找当前结点的双亲结点等 第二类，插入或删除某个结点,如在树的当前结点上插入一个新结点或删除当前结点的第i个孩子结点等 第三类，遍历树中每个结点,这里着重介绍 ","date":"2024-04-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%846/:1:2","tags":["数据结构"],"title":"数据结构(第六章)","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%846/"},{"categories":["数据结构"],"content":"二叉树 二叉树的定义：二叉树 是由n(n\u003e=0)个结点的有限集合构成，此集合或者为空集，或者由一个根结点及两棵互不相交的左右子树组成，并且左右子树都是二叉树 二叉树可以是空集合，根可以有空的左子树或空的右子树。二叉树不是树的特殊情况 二叉树结点的子树要区分左子树和右子树，即使只有一棵子树也要进行区分，说明它是左子树，还是右子树。这是二叉树与树的最主要的差别 二叉树的5种基本形态 其中：(c)和（d）是不同的两棵二叉树 ","date":"2024-04-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%846/:2:0","tags":["数据结构"],"title":"数据结构(第六章)","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%846/"},{"categories":["数据结构"],"content":"二叉树的性质 性质1：在二叉树的第i层上至多有2i-1个结点 证明： 用数学归纳法。 当i=1时，整个二叉树只有一根结点，此时$2^{i-1}=2^0=1$，结论成立 设i=k时结论成立，即第k层上结点总数最多为$2^{k-1}$个 现证明当i=k+1时， 结论成立： 因为二叉树中每个结点的度最大为2，则第k+1层的结点总数最多为第k层上结点最大数的2倍，即$2×2^{k-1}=2 ^{(k+1)-1}$，故结论成立 度为m的树中第i层上至多有$m^{i-1}$个结点, (i≥1)。 性质2：深度为k的二叉树至多有2k-1个结点 证明：因为深度为k的二叉树，其结点总数的最大值是将二叉树每层上结点的最大值相加，所以深度为k的二叉树的结点总数至多为 深度为k的m叉树至多有 $\\frac{m^k-1}{m-1}$个结点 性质3：任何一棵二叉树中度为2的结点数目(n2)比度为0的结点数目($n_0$)少1，即$n_2＝ n_0-1$ 证明：设二叉树中结点总数为n，n1为二叉树中度为1的结点总数，设二叉树中分支数目为B $n=n_0+n_1+n_2$ 除根结点外，每个结点均对应一个进入它的分支 n=B+1 二叉树中的分支都是由度为1和度为2的结点发出 $B=n_1+2n_2$ 性质4：一个有n个结点的完全二叉树的高度为$[log_2n]+1或 [log_2(n+1)]$ 性质5完全二叉树中的某结点编号为i，则 若该结点有左孩子，则左孩编号为2i 若该结点有右孩子，则右孩子结点编号为2i+1 若该结点有双亲，则双亲结点编号为$[i/2]$ ","date":"2024-04-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%846/:2:1","tags":["数据结构"],"title":"数据结构(第六章)","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%846/"},{"categories":["数据结构"],"content":"满二叉树和完全二叉树 满二叉树 深度为k且有$2^k-1$个结点的二叉树。在满二叉树中，每层结点都是满的，即每层结点都具有最大结点数 满二叉树的顺序表示，即从二叉树的根开始， 层间从上到下， 层内从左到右，逐层进行编号（1， 2， …， n） 完全二叉树： 深度为k，结点数为n的二叉树，如果其结点1~n的位置序号分别与满二叉树的结点1~n的位置序号一一对应，则为完全二叉树， 满二叉树必为完全二叉树， 而完全二叉树不一定是满二叉树 ","date":"2024-04-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%846/:2:2","tags":["数据结构"],"title":"数据结构(第六章)","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%846/"},{"categories":["数据结构"],"content":"二叉树的顺序存储 二叉树的顺序存储指的是用元素在数组中的下标表示一个结点与其孩子和父结点的关系. 完全二叉树的顺序存储 #define MAX_TREE_SIZE 100 typedef TelemType SqBiTree[MAX_TREE_SIZE]; SqBiTree bt; 非完全二叉树的顺序存储 非完全二叉树不适合进行顺序存储 ","date":"2024-04-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%846/:2:3","tags":["数据结构"],"title":"数据结构(第六章)","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%846/"},{"categories":["数据结构"],"content":"二叉树的链式存储 一般用二叉链表存储二叉树(每个结点有两个指针域) typedef struct BiTNode{ TElemType data; struct BiTNode *Lchild,*Rchild; }BiTNode, *BiTree; 三叉链表存储二叉树(每个节点有三个指针域) ","date":"2024-04-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%846/:2:4","tags":["数据结构"],"title":"数据结构(第六章)","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%846/"},{"categories":["数据结构"],"content":"遍历二叉树和线索二叉树 任何一个非空的二叉树都由三部分构成 树的遍历是访问树中每个结点仅一次的过程。遍历可以被认为是把所有的结点放在一条线上，或者将一棵树进行线性化的处理 ","date":"2024-04-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%846/:3:0","tags":["数据结构"],"title":"数据结构(第六章)","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%846/"},{"categories":["数据结构"],"content":"二叉树的遍历 先左后右：DLR，LDR，LRD 先右后左：DRL，RDL，RLD 先序遍历 DLR：访问根结点、先序遍历左子树、先序遍历右子树 若二叉树为空，结束 ——基本项（也叫终止项） 若二叉树非空 访问根结点； 先序遍历左子树 先序遍历右子树 void preorder (BiTNode *root) {//先序遍历root指向根的二叉树 if (root!=NULL) { cout\u003c\u003c root-\u003edata；//访问根结点 preorder(root-\u003eLchild); //先序遍历根的左子树 preorder(root-\u003eRchild); //先序遍历根的右子树 }//if }//preorder 中序遍历 LDR：中序遍历左子树、访问根结点、中序遍历右子树 若二叉树为空，结束 ——基本项（也叫终止项 ) 若二叉树非空 ——递归项 中序遍历左子树 访问根结点 中序遍历右子树 void inorder (BiTNode *root) {//先序遍历root指向根的二叉树 if (root!=NULL) { inorder(root-\u003eLchild); //先序遍历根的左子树 cout\u003c\u003c root-\u003edata；//访问根结点 inorder(root-\u003eRchild); //先序遍历根的右子树 }//if }//inorder void InOrder (BiTNode *root) { InitStack(S); Push(S,root); //根指针进栈 while (!StackEmpty(S)) { while(GetTop(S,p)\u0026\u0026p) Push(S,p-\u003eLchild); //向左走到头 Pop(S,p); //空指针退栈 if (!StackEmpty(S)) { Pop(S,p); cout \u003c\u003c p-\u003edata; //访问结点 Push(S,p-\u003eRchild); //向右 } //if }//while }//InOrder 后序遍历 LRD：后序遍历左子树、后序遍历右子树、访问根结点 后序遍历序列:BDFGECA void postorder (BiTNode *root) { if (root!=NULL) { postorder(root-\u003eLchild); //后序遍历根的左子树 postorder(root-\u003eRchild); //后序遍历根的右子树 cout\u003c\u003c root-\u003edata；//访问根结点 }//if }//postorder 层序遍历 先根，后子树；先左子树，后右子树 层序遍历 ","date":"2024-04-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%846/:3:1","tags":["数据结构"],"title":"数据结构(第六章)","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%846/"},{"categories":["数据结构"],"content":"线索二叉树 typedef enum PointerTag {Link=0,Thread=1}; typedef struct BiThrNode{ ElemType data; struct BiThrNode *Lchild,*Rchild; PointerTag Ltag, Rtag; }*BiThrTree; 中序线索二叉树 在中序线索化二叉树上查找给定结点的前驱和后继结点 在中序线索二叉树上，查找p所指结点的后继分为两种情况： 若p-\u003eRtag=1，则p-\u003eRchild指向其后继结点 若p-\u003eRtag=0，则p所指结点的中序后继必为其右子树中序遍历得到的第一个结点，即从p所指结点的右子树根出发，沿左指针链向下找，直到找到一个没有左孩子的结点为止，这个结点称为p的右子树中“最左下”的结点。 中序线索二叉树上找指定结点的后继 typedef struct BiThrNode{ ElemType data; struct BiThrNode *Lchild,*Rchild; PointerTag Ltag,Rtag; }*BiThrTree; BiThrTree inordernext(BiThrTree p) { if （p-\u003ertag==1） return(p-\u003eRchild); else { q=p-\u003eRchild; while (q-\u003eltag==0) q=q-\u003eLchild; return(q); } } void InThreading(BiThrTree p) { if (p) { InThreading(p-\u003eLchild); //左子树线索化 if (!p-\u003eLchild) {//前驱线索 p-\u003eLtag = Thread; p-\u003eLchild = pre; } if (!pre-\u003eRchild) {//后继线索 pre-\u003eRtag = Thread; pre-\u003eRchild = p; } pre = p; InThreading(p-\u003eRchild); //右子树线索化 } }//InThreading void InOrderThreading(BiThrTree \u0026Thrt, BiThrTree root) { //Thrt指向中序线索化链表的头结点 if (!Thrt = (BiThrTree)malloc(sizeof(BiThrNode))) exit(OVERFLOW); Thrt-\u003eLtag = Link; Thrt-\u003eRtag = Thread; Thrt-\u003eRchild = Thrt; if (root == NULL) Thrt-\u003eLchild = Thrt; else { Thrt-\u003eLchild = root; pre = Thrt; InThreading(root); //中序遍历进行中序线索化 pre-\u003eRchild = Thrt; pre-\u003eRtag = Thread; Thrt-\u003eRchild = pre; } }//InOrderThreading 后序线索二叉树 在后序线索化二叉树上查找给定结点的前驱和后继结点 在后序线索二叉树上，查找p所指结点的后继分为两种情况： 若p所指结点是整棵二叉树的根结点，则无后继结点 若p-\u003eRtag=1，则p-\u003eRchild指向其后继结点； 若p-\u003eRtag=0：//P所指结点有右子树 若p所指结点是其父结点f的右孩子，则其父结点f是其后继； 若p所指结点是其父结点f的左孩子： 若p所指结点没有右兄弟，则其父结点f是其后继； 若P有右兄弟，则其后继结点是其父的右子树上后序遍历得到的第一个结点。 先序线索二叉树 在先序线索化二叉树上查找给定结点的前驱和后继结点 ","date":"2024-04-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%846/:3:2","tags":["数据结构"],"title":"数据结构(第六章)","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%846/"},{"categories":["数据结构"],"content":"树和森林 ","date":"2024-04-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%846/:4:0","tags":["数据结构"],"title":"数据结构(第六章)","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%846/"},{"categories":["数据结构"],"content":"树的存储结构 双亲表示法 采用一组地址连续的存储单元存储树的结点,通过保存每个结点的双亲结点的位置，表示树中结点之间的结构关系 //双亲表示类型定义 #define MAX 100 struct node{ char data; int parent; //双亲位置域 }; typedef struct node NODE; NODE tree[MAX]; 孩子表示法 通过保存每个结点的孩子结点的位置，表示树中结点之间的结构关系。 孩子兄弟表示法 用二叉链表作为树的存贮结构。链表的两个指针域分别指向该结点的第一个孩子结点和其右边的下一个兄弟结点 struct node { char data; struct node *son, * brother; }; ","date":"2024-04-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%846/:4:1","tags":["数据结构"],"title":"数据结构(第六章)","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%846/"},{"categories":["数据结构"],"content":"树与二叉树的转换 借助于“孩子兄弟表示法”实现树与二叉树之间的转化 将下面的二叉树转换为树 ","date":"2024-04-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%846/:5:0","tags":["数据结构"],"title":"数据结构(第六章)","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%846/"},{"categories":["数据结构"],"content":"树的遍历 树的结构特点：树根、树的子树森林 树的先根遍历：先访问根结点、然后依次先根遍历树的子树森林。 树的后根遍历：先依次后根遍历每棵子树，然后访问根结点 树的先根遍历等同于对转换所得的二叉树进行先序遍历 树的后根遍历等同于对转换所得的二叉树进行中序遍历 ","date":"2024-04-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%846/:6:0","tags":["数据结构"],"title":"数据结构(第六章)","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%846/"},{"categories":["数据结构"],"content":"森林的遍历 森林的先序遍历等于对转换所得的二叉树进行先序遍历 森林的中根遍历等于对转换所得的二叉树进行中序遍历 ","date":"2024-04-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%846/:7:0","tags":["数据结构"],"title":"数据结构(第六章)","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%846/"},{"categories":["数据结构"],"content":"森林的先序遍历 森林的结构特点：第一棵树、其余的树 森林的先序遍历： 访问森林中第一棵树的根结点； 先序遍历第一棵树中根结点的子树森林； 先序遍历除第一棵树后剩余的树构成的森林 ","date":"2024-04-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%846/:7:1","tags":["数据结构"],"title":"数据结构(第六章)","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%846/"},{"categories":["数据结构"],"content":"森林的中序遍历 森林的中序遍历： 中序遍历第一棵树中根结点的子树森林 访问森林中第一棵树的根结点； 中序遍历除第一棵树后剩余的树构成的森林 ","date":"2024-04-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%846/:7:2","tags":["数据结构"],"title":"数据结构(第六章)","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%846/"},{"categories":["数据结构"],"content":"最优二叉树 例：编写程序将百分制表示的成绩score转换为等级分grade，规则为： ","date":"2024-04-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%846/:8:0","tags":["数据结构"],"title":"数据结构(第六章)","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%846/"},{"categories":["数据结构"],"content":"赫夫曼树(最优二叉树) 最优二叉树是一类带权路径长度最短的树 路径和路径长度 从树中的一个结点到另一个结点之间的分支构成这两个结点之间的路径，路径上的分支数目称作路径长度。 结点的权 根据应用的需要可以给树的结点赋权值 结点的带权路径长度 从根到该结点的路径长度与该结点权的乘积称为结点的带权路径长度 树的带权路径长度 树中所有叶子的带权路径长度之和称为树的带权路径长度，记作 设有四个叶子a、b、c和d的二叉树中，对应的权值分别为7、5、2和4，计算WPL。 最优二叉树是一类带权路径长度最短的树 ","date":"2024-04-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%846/:9:0","tags":["数据结构"],"title":"数据结构(第六章)","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%846/"},{"categories":["数据结构"],"content":"赫夫曼算法 根据给定的n个权值{$w_1,w_2,…,w_n$}构造n棵二叉树的集合F={$T_1,T_2,…,T_n$}，其中每棵二叉树Ti中只有一个带权为$w_i$的根结点，其左右子树均空 在F中选取两棵根结点的权值最小的树作为左右子树构造一棵新的二叉树，且置新的二叉树的根结点的权值为其左、右子树上根结点的权值之和 在F中删除这两棵树，同时将新得到的二叉树加入F中。 重复2和3，直到F中只含一棵树为止。这棵树便是最优二叉树。 ","date":"2024-04-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%846/:9:1","tags":["数据结构"],"title":"数据结构(第六章)","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%846/"},{"categories":["数据结构"],"content":"编码－译码 在进行数据通讯时，涉及数据编码问题。所谓数据编码就是将信息原文转换为二进制字符串，译码则是将信息的编码形式转换为原文。 例如发电报： ","date":"2024-04-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%846/:9:2","tags":["数据结构"],"title":"数据结构(第六章)","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%846/"},{"categories":["数据结构"],"content":"等长编码方案 例如：要传送的信息原文为“ABACCDA” ","date":"2024-04-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%846/:9:3","tags":["数据结构"],"title":"数据结构(第六章)","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%846/"},{"categories":["数据结构"],"content":"不等长编码方案 例如：要传送的信息原文为“ABACCDA” ","date":"2024-04-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%846/:9:4","tags":["数据结构"],"title":"数据结构(第六章)","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%846/"},{"categories":["数据结构"],"content":"前缀编码 为一个字符集合中的字符进行编码时，若每个字符的编码不是其他字符编码的前缀，则称这种编码为前缀编码。 ","date":"2024-04-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%846/:9:5","tags":["数据结构"],"title":"数据结构(第六章)","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%846/"},{"categories":["数据结构"],"content":"赫夫曼编码 已知某系统在通信联络中只可能出现8种字符，其概率如下表所示: **为字符建立赫夫曼编码 ** 赫夫曼编码举例 typedef struct { char ch; unsigned int weight; unsigned int parent,lchild,rchild; }HTNode,*Huffmantree; Huffmantree HT; HT = new HTNode[2*n]; //赫夫曼树的存储结构 赫夫曼编码的求解算法 typedef struct { char ch; unsigned int weight; unsigned int parent,lchild,rchild; }HTNode,*Huffmantree; Huffmantree HT; HT = new HTNode[2*n];//赫夫曼树的存储结构 void HuffmanCoding(HuffmanTree \u0026HT, HuffmanCode \u0026HC,int *w,int n) {//w存放n个字符的权值，构造赫夫 曼树HT，并求出n个字符的编码 if (n\u003c=1) return; m = 2*n-1; HT = new HTNode[m+1]; for(i=1; i\u003c=n; i++) HT[i].weight = w[i-1]; for(i=1; i\u003c=m; ++i) { HT[i].parent = 0; HT[i].lchild =0; HT[i].rchild = 0; } for(i=n+1; i\u003c=m; i++) {//构造赫夫曼树 //从HT[1..i-1]中选择parent为0且weight最小的两个结点， //其序号为s1和s2 select(HT,i-1,s1,s2); HT[s1].parent = i; HT[s2].parent = i; HT[i].lchild = s1; HT[i].rchild = s2; HT[i].weight = HT[s1].weight + HT[s2].weight; } //从叶子到根逆向求每个字符的赫夫曼编码 HC = new char*[n+1]; cd = new char [n]; cd[n-1] = ‘\\0’; for(i=1; i\u003c=n; i++) { start = n-1; for(j=i,f=HT[i].parent; f!=0; j=f,f=HT[f].parent) if (HT[f].lchild == j) cd[--start]=‘0’; else cd[--start]=‘1’; HC[i] = new char [n-start]; strcpy(HC[i],\u0026cd[start]); } delete cd[]; }//HuffmanCoding ","date":"2024-04-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%846/:9:6","tags":["数据结构"],"title":"数据结构(第六章)","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%846/"},{"categories":["数据结构"],"content":"译码 译码算法 //将二进制编码翻译回信息原文，m是树根的编号 void Decoding(HuffmanTree HT,int m,char *buff){ int p=m; while (*buff!=‘\\0’ \u0026\u0026 p!=0) { if ((*buff)==‘0’) p=HT[p].lchild; //进入左分支 else p = HT[p].rchild; //进入右分支 buff++; if (!HT[p].lchild \u0026\u0026 !HT[p].rchild) { //进入叶子结点 cout \u003c\u003c HT[p].ch; p = m; //重新从树根出发进行译码 }//if }//while }//Decoding ","date":"2024-04-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%846/:9:7","tags":["数据结构"],"title":"数据结构(第六章)","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%846/"},{"categories":["数据结构"],"content":"串 ","date":"2024-04-05","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%844/:0:0","tags":["数据结构"],"title":"数据结构(第四章)","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%844/"},{"categories":["数据结构"],"content":"串的定义及基本运算 串的定义 串(String)是零个或多个字符组成的有限序列。一般记作：S=“a1a2a3…an”，其中： S：串名； “a1a2a3…an”：串值，双引号括起来的字符序列； ai(1≤i≤n)可以是字母、数字或其它字符； 串的长度 串中所包含的字符个数； 长度为零的串称为空串(Empty String)，它不包含任何字符 空白串 通常将仅由一个或多个空格组成的串称为空白串(Blank String)。 注意：空串和空白串的不同。 串的子串 串中任意个连续字符组成的子序列称为该串的子串(SubString)，包含子串的串相应地称为主串。通常将子串在主串中首次出现时的该子串的首字符对应的主串中的序号，定义为子串在主串中的序号（或位置）。 例如：设A和B分别为A=“This is a string” B=“is” 则B是A的子串，A为主串。B在A中出现了两次，其中首次出现所对应的主串位置是3。因此，称B在A中的位置为3。 特别地，空串是任意串的子串，任意串是其自身的子串。 串的基本运算 串赋值: StrAssign(\u0026S, char *t) 串比较: int StrCompare(S, T) 求串长: int StrLength(S) 串联接: char *strcat(char *to, char *from) 求子串: SubString(\u0026sub, S, pos, len) 串复制 : char *strcpy(char *to,char *from) 子串定位: int index(Sub,S) ","date":"2024-04-05","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%844/:1:0","tags":["数据结构"],"title":"数据结构(第四章)","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%844/"},{"categories":["数据结构"],"content":"串的表示和实现 串的定长顺序存储 #define maxstrlen 256 typedef char sstring[maxstrlen]; sstring s; //s可容纳255个字符 串作为高级语言支持的数据类型，对于串长度(或串的结尾表示)，会有不同的方式，对于超过串存储空间的部分会截断存储。 可以在串定义中加入串长表示 typedef struct{ char ch[MaxStrlen]; int length; }sstring; 顺序串的操作实现 串连接Concat(\u0026T,S1,S2) 求子串SubString(\u0026Sub,S,pos,len) Status SubString(Sstring \u0026Sub,Sstring S,int pos,int len){ //求串S从第pos个字符起长度为len的子串Sub if (pos\u003c1 || pos \u003e S.Length || len\u003c0 || len\u003eS.Length-pos+1) return ERROR; Sub.ch[0..len-1] = S.ch[pos-1..pos+len-2]; Sub.length = len; } 串的堆分配存储 在程序执行过程中从内存空闲区(堆)中动态申请满足串长的存储空间，串在其中仍是顺序存储的，称为堆结构。也称为动态存储分配的顺序表。 串的堆分配存储定义 ① typedef char *string; //c中的串库相当于此类型定义 ② //-----串的堆分配存储表示----- typedef struct{ char *ch; int length; }Hsring; 基本操作的实现 串赋值 Status strassign(Hstring \u0026T,char *chars){ //生成一个其值等于串常量chars的串T if(T.ch) free(T.ch); for(i = 0,c = chars;c; ++i,++c); //求chars长度 if(!i) { T.ch = null; T.length = 0; } else{ if (!(T.ch = (char *)malloc(i*sizeof(char)))) exit(OVERFLOW); T.ch[0..i-1] = chars[0..i-1]; T.length = i; } return OK; } 串联接 Status concat(Hstring \u0026t, Hstring s1, Hstring s2){ //将串s1和s2联接成新串t if (!(t.ch) = (char*)malloc(s1.length+ s2.length)*sizeof(char))) exit(overflow); t.ch[0..s1.length-1] = s1.ch[0..s1.length-1]; t.length = s1.length + s2.length; t.ch[s1.length..t.length-1] = s2.ch[0..s2.length-1]; return OK; } 求子串 Status substr(Hstring \u0026sub,Hstring s,int pos,int len){ if (pos\u003c1 || pos\u003es.length || len\u003c0 || len\u003es.length-pos+1) return error; if (sub.ch) free(sub.ch); if (!len) { sub.ch = null; sub.length = 0; } else{ sub.ch = (char *)malloc(len*sizeof(char)); sub.ch[0..len - 1] = s[pos-1..pos + len-2]; s.length = len; } } 串的链式存储 存储密度： $\\frac{串值所占的存储空间}{实际分配的存储空间}$ ","date":"2024-04-05","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%844/:2:0","tags":["数据结构"],"title":"数据结构(第四章)","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%844/"},{"categories":["数据结构"],"content":"串的模式匹配 子串定位运算又称为模式匹配(Pattern Matching)或串匹配(String Matching)。 在串匹配中，一般将主串称为目标串，子串称为模式串。 若子串在主串中出现，则称匹配成功，子串出现的位置称为有效位移,否则称匹配不成功。 模式匹配在文章的关键字查找中被广泛使用 模式匹配算法 朴素的串匹配算法 【数据结构】串（二）—— 朴素模式匹配算法-CSDN博客 int Index(sstring S,sstring T,int pos) { //返回子串T在主串S中从第pos个字符开始的位置 //要求T非空，1≤pos ≤Strlength(S) i = pos; j = 1; while (i \u003c= Strlength(S) \u0026\u0026 j \u003c= Strlength(T)) { if (S[i]==T[j]) {++i; ++j;} else {i = i-j+2; j = 1;} } if ( j\u003e Strlength(T) ) return (i–Strlength(T)); return 0; } // Index 算法时间复杂度 O(n*m)，其中n、m分别为主串和子串长度 改进的串匹配算法－－KMP算法 int Index_KMP(sstring S,sstring T,int pos) { //返回子串T在主串S中从第pos个字符开始的位置 //要求T非空，1≤pos ≤Strlength(S) i=pos; j=1; while(i\u003c=Strlength(S) \u0026\u0026 j\u003c=Strlength(T)) { if ( S[i]==T[j]) {++i; ++j;} else {i = i-j+2; j = 1;} } if (j\u003e Strlength(T)) return (i-Strlength(T)); return 0; } // Index 求next[j] 的算法： int Get_Index(sstring T, int next[]) { //求模式串T的next函数值并存入数组next i=1; next[1]=0; j=0; while(i\u003c=Strlength(T)) { if ( j==0 || T[i]==T[j]) {++i; ++j;next[i]=j;} else j=next[j]; } } // Get_Index ","date":"2024-04-05","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%844/:3:0","tags":["数据结构"],"title":"数据结构(第四章)","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%844/"},{"categories":["编译原理"],"content":"语法分析——自顶向下分析 按照语法分析树的建立方法，可将语法分析方法分成自顶向下和自底向上两大类。 自顶向下分析方法：语法分析从顶部（树根、语言的识别符号）到底部（叶子、语言的终结符号）为输入的单词符号串建立语法分析树。本章将介绍的递归下降分析方法和LL分析方法就属于自顶向下分析方法。 自底向上分析方法：语法分析从底部到顶部为输入的单词符号串建立语法分析树。最常见的自底向上分析方法有算符优先分析法和LR分析方法，该部分内容将在第5章介绍。 注：无论采用哪种分析方法，语法分析都是自左向右读入符号 ","date":"2024-04-03","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%864/:0:0","tags":["编译原理"],"title":"编译引论(第四章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%864/"},{"categories":["编译原理"],"content":"自顶向下分析面临的问题 所谓自顶向下分析方法就是从文法的开始符号出发，按最左推导方式向下推导，试图推出要分析的输入串。它的宗旨是，对任何输入串，试图用一切可能的办法，从文法开始符号出发，自上而下，从左到右地为输入串建立分析树。或者说，为输入串寻找最左推导。这种分析过程本质上是一种试探过程，是反复使用不同的产生式谋求匹配输入串的过程。 例： 若有文法 G[S]: S→aAb A→cf│c 为了自顶向下地为输入串ω=acb建立分析树，首先建立只有标记为S的单个结点树，输入指针指向ω第一个符号a，然后用S的第一个候选式来扩展该树，得到的树如图（a）所示。 最左边的叶子标记为a，匹配ω的第一个符号。于是，推进输入指针到ω的第二个符号c，并考虑分析树上的下一个叶子A，它是非终结符。 用A的第一个候选式来扩展A，得到图（b）的树。现在第二个输入符号c能匹配，再推进输入指针到b，把它和分析树上的下一个叶子f比较。因为b和f不匹配，回到A，看它是否还有别的候选式尚未尝试。 在回到A时，必须重置输入指针于第二个符号，即第一次进入A的位置。现在尝试A的第二个选择，得到图（c）的分析树。叶子c匹配ω的第二个符号，叶子b匹配ω的第三个符号。这样，得到了ω的分析树，从而宣告分析完全成功 ","date":"2024-04-03","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%864/:1:0","tags":["编译原理"],"title":"编译引论(第四章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%864/"},{"categories":["编译原理"],"content":"自顶向下分析面临的问题 自顶向下分析法存在困难和缺点： 首先，如果存在非终结符A，并且有A Aa这样的左递归，那么文法将使上述自顶向下分析过程陷入无限循环。因为当试图用A去匹配输入串时会发现，在没有吃进任何输入符号的情况下，又得要求用下一个A去进行新的匹配。因此，使用自上而下分析法时，文法应该没有左递归。 其次，当非终结符用某个选择匹配成功时，这种成功可能仅是暂时的。由于这种虚假现象，需要使用复杂的回溯技术。由于回溯，需要把已做的一些语义工作（如中间代码的生成等）推倒重来。这些事情既麻烦又费时间，所以最好设法消除回溯。同时，回溯使得分析器难以报告输入符号串出错的确切位置。 最后，试探与回溯是一种穷尽一切可能的办法，效率低，代价高，它只有理论意义，在实践中的价值不大。 ","date":"2024-04-03","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%864/:2:0","tags":["编译原理"],"title":"编译引论(第四章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%864/"},{"categories":["编译原理"],"content":"LL（1）文法 ","date":"2024-04-03","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%864/:3:0","tags":["编译原理"],"title":"编译引论(第四章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%864/"},{"categories":["编译原理"],"content":"FIRST集（首符号集） 定义：设 G[S] = (VT ,VN , S , P) 是上下文无关文法，则 $FIRST(x) = {a|x \\stackrel{}\\Rightarrow ay,a∈ VT,x,y ∈ V}$ 若$x \\stackrel{*} \\Rightarrow ε$，则规定ε∈FIRST(x) 实际上， FIRST(x)是指由符号串x出发能够推导出来的所有符号串中，处于串头的终结符号的集合。 **FIRST(X)可按以下算法求得： ** 设：X=X1X2…Xn，FIRST(X)=Φ，i=1则有： 若$X_i∈V_T$,则$X_i∈FIRST(X)$,进入第4步; 若$X_i∈V_N$, 若$X_i \\stackrel{*} \\nRightarrow ε$,则FIRST(Xi)∈FIRST(X),进入第4步; 若$Xi \\stackrel{*} \\Rightarrow ε,则FIRST(Xi)\\ ε∈FIRST(X)$,然后令i=i+1,若i≤n，进入第1步,否则进入第3步； 若 $X \\stackrel{*} \\Rightarrow ε$，则ε∈FIRST(X)； 退出 例： 已知文法G[E]： E→TE'\rE'→+TE'|ε\rT→FT'\rT'→*FT'|ε\rF→(E)|i\r求文法中的非终结符号以及符号串TE’、+TE’、ε、FT’的FIRST集 解：首先，求各非终结符号FIRST集： ","date":"2024-04-03","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%864/:3:1","tags":["编译原理"],"title":"编译引论(第四章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%864/"},{"categories":["编译原理"],"content":"FOLLOW集（后继符号集） 定义：设 $G[S] = (V_T ,V_N , S , P)$ 是上下文无关文法，$A∈V_N$ , 则 $FOLLOW(A)={a|S \\stackrel{*} \\Rightarrow …Aa… ,a∈V_T}$ 若$S \\stackrel{*} \\Rightarrow …A$，则规定 #∈FOLLOW(A) 实际上， FOLLOW(A)是指文法G[S] 的所有句型中，紧跟在非终结符A后的终结符号的集合。 #作为输入串的结束符，或称为句子括号，如：abc# FOLLOW(A)可采用以下算法求得： 对于文法G[S]的开始符号S，有#∈FOLLOW(S)； 若文法G[S]中有形如U→xA的规则,其中x∈V﹡,则 FOLLOW(U)∈FOLLOW(A) 若文法G[S]中有形如U→xAy的规则,其中x∈V﹡,y∈V﹡, 当$y \\stackrel{*} \\nRightarrow ε$时, FIRST(y)∈FOLLOW(A) 当$y \\stackrel{*} \\Rightarrow ε$时, FIRST(y)\\ ε∈FOLLOW(A) FOLLOW(U)∈FOLLOW(A) 例： 已知文法G[E]： E→TE'\rE'→+TE'|ε\rT→FT'\rT'→*FT'|ε\rF→(E)|i\r求各非终结符号的FOLLOW集。 ","date":"2024-04-03","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%864/:3:2","tags":["编译原理"],"title":"编译引论(第四章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%864/"},{"categories":["编译原理"],"content":"SELECT集（可选集） 定义:给定上下文无关文法的产生式A→x,A∈VN, x∈V*,则 若$x \\stackrel{*} \\nRightarrow ε$，则SELECT(A→x)=FIRST(x) 若$x \\stackrel{*} \\Rightarrow ε$，则SELECT(A→x)=FIRST(x)\\ε∪FOLLOW(A) 实际上SELECT(A→x)是指，在推导过程中，如果采用了A→x进行推导，下一个可能推导出的终结符号。 例： 已知文法G[S]： S→AB|bC A→b|ε B→aD|ε C→AD|b D→aS|c 求出符号串AB、bC、ε、AD的FIRST集，非终结符号的FOLLOW，以及所有产生式的SELECT集。 ","date":"2024-04-03","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%864/:3:3","tags":["编译原理"],"title":"编译引论(第四章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%864/"},{"categories":["编译原理"],"content":"LL（1）文法 一个上下文无关文法是LL（1）文法，当且仅当对于每个非终结符A的任何两个候选式A→α|β满足： SELECT（A→α）∩SELECT（A→β）=∅ 其中$A∈V_N，α、β∈V^*$，且不能同时推导出ε。 例： 判断下面的文法是否是LL（1）文法： ","date":"2024-04-03","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%864/:3:4","tags":["编译原理"],"title":"编译引论(第四章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%864/"},{"categories":["编译原理"],"content":"递归下降分析法 递归子程序法也称为递归下降分析法，是一种简单直观易于构造的自顶向下分析方法，其核心思想是：对文法的每一个非终结符号编制一个处理子程序，而处理子程序的代码结构则由相应的非终结符号的规则右部所决定。 也就是说递归下降分析法为文法中的每一个非终结符编写一个递归过程，识别由该非终结符推出的符号串，当某非终结符有多个候选式时，能够按照LL（1）形式确定地选择某个产生式进行推导。用这种方法进行语法分析时，从读入第一个单词开始，由开始符号出发进行分析。若遇到非终结符，则调用相应的处理过程；若遇到终结符，则判断当前读入的单词是否与该终结符相匹配，如果匹配，则读取下一个单词继续分析。 设LL（1）文法$G（V_N，V_T，P,S），V_N={X_1,X_2,…,X_n}$。对文法的每个非终结符号Xi，可以按照以下方法来设计递归下降分析子程序Xi（）： 对于形如$X_i→γ_1|γ_2|…|γ_m$的产生式，在相应子程序$X_i（）$中，应该能够判断当前输入符号a属于哪个候选式$γ_j$的SELECT集，并转入该候选式相应的代码段，继续识别，对候选式的选择可用if语句或case语句实现。 对于形如$X_i→Y_1Y_2…Y_k（Y_j∈V_N∪V_T）$的产生式，相应子程序$X_i（）$是一个依次识别其右部各符号$Y_j（j=1,2,…,k）$的过程；如果$Y_j∈V_T$，则判断当前输入符号是否与Yj匹配；若$Y_j∈V_N$，则应调用相应于$Y_j$的子程序的代码。 对于形如$X_i→ε$的产生式，在相应的子程序$X_i（）$中，应该能够判断当前输入符号a是否属于集合FOLLOW(Xi),从而决定是从$X_i（）$返回还是报错。 在各个子程序$X_i（）$中，均应含有进行语法检查的代码。 例 下面LL（1）文法产生pascal类型的子集，用dotdot表示“..”，以强调这个字符序列作为一个词法单元。 规则 type→ simple |↑id |array [simple] of type 该该非终结符对应的递归分析子程序伪代码如下： procedure type; begin if lookahead in {integer,char,num} then simple( ) else if lookahead=‘↑’ then begin match(‘↑’); match(id) end else if lookahead=array then begin match(array); match(‘[’); simple( ); match(‘['); match(of); type( ) end else error( ) end; 变量lookahead来存放向前查看的单词符号。如果lookahead∈SELECT（simple）={integer,char, num}，则转入simple子程序；如果当前单词符号为↑，则调用匹配函数match( )，检查是否匹配，若匹配则读入下一个单词符号，存放到变量looahead 中，然后继续调用match( )，检查当前符号是否与match函数的参数id匹配，若匹配则意味着可以选取产生式type→↑id；如果当前单词为array，则依次执行以下操作：匹配array，匹配“[”，调用simple()，匹配\"[\"，匹配of，调用type( )；如果lookahead中的单词符号不是上述符号，则调用出错处理函数error( )。 规则 simple→integer | char |num dotdot num 该该非终结符对应的递归分析子程序伪代码如下： procedure simple； begin if lookahead=integer then match(integer) else if lookahead=char then match(char) else if lookahead=num then begin match(num)； match(dotdot)； match(num) end else error( ) end； ","date":"2024-04-03","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%864/:4:0","tags":["编译原理"],"title":"编译引论(第四章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%864/"},{"categories":["编译原理"],"content":"预测分析法 定义：所谓预测分析法也称为LL(1)分析，是指从左到右扫描输入源程序，同时采用最左推导，且对每次直接推导只需向前查看一个输入符号，便可以确定当前所应选择的规则。 理解： 第一个L表示：自顶向下分析是从左向右扫描输入串。 第二个L表示：分析过程中将用最左推导。 1表示：只需向右看一个符号便可决定如何推导（即选择哪个产生式进行推导） ","date":"2024-04-03","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%864/:5:0","tags":["编译原理"],"title":"编译引论(第四章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%864/"},{"categories":["编译原理"],"content":"预测分析器的结构 预测分析器（即实现预测分析法的程序）的结构如图所示 输入缓冲区：用于存放待分析的符号串ω，ω后紧跟边界符#； 分析栈：存放一系列文法符号，边界符#存于栈底。分析开始时，先将#入栈，然后再置入文法开始符号。 预测分析表M：它与文法有关，它是一个二维数组M[A,a]，其中，A是非终结符号，a是终结符号或#，存放非终结符号A对应输入符号a时应该选择的产生式，是预测分析时的主要依据。 输出流：分析过程中所采用的产生式序列。 预测分析总控程序：它是预测分析器的核心，它总是根据栈顶符号X和当前输入符号a来决定分析程序应该采取的动作，有四种可能： 若X=a≠#，则分析程序从STACK的栈顶弹出终结符号X，输入指针前移一个位置，指向下一个输入符号（即a的后继符号）； 若X=a=#，则分析程序宣告分析成功，停止分析； 若$X∈V_T$（即X是终结符号），但X≠a，则分析程序调用出错处理程序，以报告错误。 若$X∈V_N$（即X是非终结符号），则分析程序访问分析表M[X，a]： 若M[X，a]的值是X的产生式$X→Y_1Y_2…Y_K$，则先X弹出分析栈，然后把产生式的右部符号串按反序（即$Y_K，…Y_2，Y_1$的顺序）一一压入分析栈。特别的是，若X的产生式的右部是ε(即X→ε)时，则分析程序只需要将X弹出分析栈即可。 若M[X，a]的值是出错标记error，则分析程序调用出错处理程序，以报告错误。 ","date":"2024-04-03","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%864/:5:1","tags":["编译原理"],"title":"编译引论(第四章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%864/"},{"categories":["编译原理"],"content":"预测分析器的工作过程 ","date":"2024-04-03","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%864/:5:2","tags":["编译原理"],"title":"编译引论(第四章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%864/"},{"categories":["编译原理"],"content":"LL(1)分析表的构造 LL(1)分析表M[A,a]实际上是要表明要由A推导出终结符a所应采用的产生式。我们可以利用SELECT集来构造LL(1)分析表，具体构造算法如下： 设有文法$G[S]=(V_N,N_T,P,S), V_N={A_1,A_2,…,A_m}$,令i=1 若关于$A_i$的规则有： $A_i →x_1|x_2|…|x_n$ 则求的各规则的SELECT集。 若$a∈ SELECT(A_i→x_j)$,则 M[Ai ,a]= Ai→xj i=i+1,重复1、2，直到i\u003em,即对文法的所有的非终结符号求完为止。 ","date":"2024-04-03","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%864/:5:3","tags":["编译原理"],"title":"编译引论(第四章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%864/"},{"categories":["面向对象程序设计"],"content":"C++程序的结构 ","date":"2024-03-31","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A15/:0:0","tags":["面向对象程序设计"],"title":"c++(five)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A15/"},{"categories":["面向对象程序设计"],"content":"作用域与可见性 作用域 作用域讨论的是标识符的有效范围； 可见性 可见性是标识符是否可以引用的问题 ","date":"2024-03-31","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A15/:1:0","tags":["面向对象程序设计"],"title":"c++(five)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A15/"},{"categories":["面向对象程序设计"],"content":"作用域 作用域是一个标识符在程序正文中有效的区域。 C++的作用域 函数原型作用域 块作用域(局部作用域) 类作用域 命名空间作用域 文件作用域 函数原形作用域 函数原型中的参数，其作用域始于“(”,结束于\")\"。 例如，设有下列原型声明： double Area(double width, double length); length = 50.0; //错误 // width,length的作用域仅在于此，不能用于程序正文其它地方，因而可有可无 等价于以下函数原型声明： double Area(double , double ); 块作用域 标识符的声明出现在一对花括号括起来的一段程序块内，其作用域从声明处开始，一直到到块结束处为止。例如： void fun(int a) { int b(a); cin\u003e\u003eb; //b的作用域 if (b\u003e0) { int c; //c的作用域 ...... } cout \u003c\u003c c; //错误 cout \u003c\u003c b; //正确 } 类作用域 类的作用域是指类定义和相应的成员函数的定义范围。一个类的所有成员位于这个类的作用域内。在该范围内，一个类的成员函数对数据成员具有无限制的访问权 在类的作用域外对数据成员的访问是受限制的，这就是类的封装作用 把类看成是一组有名成员的集合，除了个别例外情况外，类的作用域作用于特定的成员名 类X的一个成员m 在下列情况下局部于类X,或者说具有类作用域 m出现在类X的成员函数内,该成员函数中没有声明同名的局部作用域的标识符，那么在函数内可以直接访问成员m。 在x.M这样的表达式中,其中x为X类的对象。 在prt-\u003em这样的表达式中,其中prt为指向X类的一个对象的指针 在X::m这样的表达式中用于访问类的静态成员 class Myclass { public: void f1 ( ) { m = 5 ; } void f2 ( ) { int m; m = 2; //Myclass::m被屏蔽 } int getm() { return m; } private: int m; }; void main() { Myclass c; c.m = 10 ; //错误 c.f1 ( ); cout \u003c\u003c c.getm ( ) \u003c\u003c endl; c.f2 ( ); cout \u003c\u003c c.getm ( ) \u003c\u003c endl; } //运行结果 // 5 // 5 命名空间作用域 一个大型的程序通常由不同模块构成，不同的模块甚至有可能是由不同人员开发的。不同模块中的类和函数之间有可能发生重名，这样可能引发错误，要解决这类歧义问题就必须使用到命名空间 namespace ns1 //指定命名中间nsl { int a； double b; } 一个命名空间确定了一个命名空间作用域，凡是在该命名空间之内声明的变量，函数都属于该命名空间作用域。如果要引用，则用命名空间：：标识符名 namespace ns1 //指定命名空间nsl { int a； double b; } ns1::a 还有以下两种都是将标识符暴露在当前的作用域。 using 命名空间：：标识符名。 using 命名空间 命名空间可以嵌套。 #include \u003ciostream\u003e using namespace std; namespace first { int x = 5; int y = 10; } namespace second { double x = 3.1416; double y = 2.7183; } int main () { using first::x; using second::y; cout \u003c\u003c x \u003c\u003c endl; cout \u003c\u003c y \u003c\u003c endl; cout \u003c\u003c first::y \u003c\u003c endl; cout \u003c\u003c second::x \u003c\u003c endl; return 0; } #include \u003ciostream\u003e namespace first { int a=10; int b=20; namespace second { double a=1.02; double b=5.002; void hello(); } void second::hello() { std::cout \u003c\u003c\"hello world\"\u003c\u003cstd::endl; }} int main() { using namespace first; std::cout\u003c\u003csecond::a\u003c\u003cstd::endl; second::hello(); } 全局命名空间和匿名命名空间 注：在匿名命名空间中声明的名称也将被编译器转换，与编译器为这个匿名命名空间生成的唯一内部名称绑定在一起 例： namespace __UNIQUE_NAME_ { char c; int i; double d; } using namespace __UNIQUE_NAME_; #include \u003ciostream\u003e using namespace std; int i; //在全局命名空间中的全局变量 namespace Ns { int j; //在Ns命名空间中的全局变量} int main() { i = 5; //为全局变量i赋值 Ns::j = 6; //为全局变量j赋值 {using namespace Ns; //使得在当前块中可以直接引用Ns命名空间的标识符 int i; //局部变量，局部作用域 i = 7; cout \u003c\u003c \"i = \" \u003c\u003c i \u003c\u003c endl;//输出7 cout \u003c\u003c \"j = \" \u003c\u003c j \u003c\u003c endl;//输出6 } cout \u003c\u003c \"i = \" \u003c\u003c i \u003c\u003c endl; //输出5 return 0;} 文件作用域 不在前述各个作用域中出现的声明，具有文件作用域（全局作用域），这样声明的标识符的作用域开始于声明点，结束于源文件尾。 程序编译的单位是源文件，包含多个函数。全局变量为本文件中所有函数所共用 具有文件作用域的变量称为全局变量 例： int p=1, q=5; /*全局变量*/ //范围：从int p=1, q=5; 到结尾 float f1 (int a) { int b, c; … } char c1, c2; /*全局变量*/ //范围：从char c1, c2; 到结尾 char f2 (int x, int y) { int i, j; … } main() { int m, n; … } #include \u003ciostream.h\u003e int i = 2, j=3; //文件作用域 void main（ ） { int i = 5; //块作用域 { int i; //块作用域 i = 7; cout\u003c\u003c“i, j=“ \u003c\u003ci \u003c\u003c j \u003c\u003cendl; } cout\u003c\u003c“i, j = ”\u003c\u003ci \u003c\u003c j; } void func ( ) { . . . cout \u003c\u003c “i, j =” \u003c\u003c i \u003c\u003c j; } ","date":"2024-03-31","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A15/:1:1","tags":["面向对象程序设计"],"title":"c++(five)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A15/"},{"categories":["面向对象程序设计"],"content":"可见性 可见性是从对标识符的引用的角度来谈有效性 可见性表示从内层作用域向外层作用域“看”时能看见什么 在某一点能够引用到的标识符，就是该处可见的标识符 作用域可见性的一般规则 标识符应声明在先，引用在后。 在同一作用域中，不能声明同名的标识符 如果某个标识符在外层中声明，且在内层中没有同一标识符的声明，则该标识符在内层可见 对于两个嵌套的作用域，如果在内层作用域内声明了与外层作用域中同名的标识符，则外层作用域的标识符在内层不可见，即内层屏蔽 在没有互相包含关系的不同的作用域中声明的同名标识符互不影响 int id = 3; //文件作用域 void main（ ） { id = 5; { int id; id = 7; cout\u003c\u003c“id=“ \u003c\u003cid \u003c\u003c endl; //输出7 } cout\u003c\u003c“id = \"\u003c\u003c id \u003c\u003c j; //输出5 } ","date":"2024-03-31","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A15/:1:2","tags":["面向对象程序设计"],"title":"c++(five)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A15/"},{"categories":["面向对象程序设计"],"content":"对象的生存期 对象从诞生到结束的这段时间就是它的生存期。在对象生存期内，对象将保持它的状态(State, 即数据成员的值)，直到被更新为止 对象的生存期可以分为静态生存期和动态生存期两种。 ","date":"2024-03-31","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A15/:2:0","tags":["面向对象程序设计"],"title":"c++(five)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A15/"},{"categories":["面向对象程序设计"],"content":"静态生存期 如果对象的生存期与程序的运行期相同，我们称它具有静态生存期。 这种生存期与程序的运行期相同 在文件作用域中声明的对象具有这种生存期 在函数内部声明静态生存期对象，要冠以关键字static ，称为静态变量 例： static int i ; 例： #include \u003ciostream.h\u003e int i = 5; //文件作用域 int main( ) { cout\u003c\u003c\"i=\"\u003c\u003c i \u003c\u003cendl; return 0; } //i 具有静态生存期 ","date":"2024-03-31","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A15/:2:1","tags":["面向对象程序设计"],"title":"c++(five)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A15/"},{"categories":["面向对象程序设计"],"content":"动态生存期 块作用域中声明的对象是动态生存期的对象(习惯称局部生存期对象) 动态生存期程序诞生于声明点，结束于该标识符的作用域结束处 void fun（ ）; void main（ ） { fun（ ）; fun（ ）; } void fun（ ） { static int a = 1; int i=5; a++; i++; cout\u003c\u003c\"i=\"\u003c\u003ci\u003c\u003c\",a=\"\u003c\u003ca\u003c\u003cendl; } //运行结果： //i=6, a=2 //i=6, a=3 //i是动态生存期 //a是静态生存期 例：具有静态、动态生存期对象的时钟程序 #include\u003ciostream.h\u003e class Clock //时钟类声明 { public: //外部接口 Clock( ); void SetTime(int NewH, int NewM, int NewS); //三个形参均具有函数原型作用域 void ShowTime( ); ~ Clock( ){} private: //私有数据成员 int Hour,Minute,Second; }; //时钟类成员函数实现 Clock::Clock( )//构造函数 { Hour=0; Minute=0; Second=0; } void Clock::SetTime(int NewH, int NewM, int NewS) { Hour=NewH; Minute=NewM; Second=NewS; } void Clock::ShowTime( ) { cout\u003c\u003cHour\u003c\u003c\":\"\u003c\u003cMinute\u003c\u003c\":\"\u003c\u003cSecond\u003c\u003cendl; } Clock globClock; //声明对象globClock，具有静态生存期， //文件作用域 void main( ) //主函数 { cout\u003c\u003c\"First time output:\"\u003c\u003cendl; //引用具有文件作用域的对象globClock： globClock.ShowTime( ); //对象的成员函数//具有类作用域 globClock.SetTime(8,30,30); Clock myClock (globClock); //声明具有块作 //用域的对象myClock cout\u003c\u003c\"Second time output:\"\u003c\u003cendl; myClock.ShowTime（ ）; //引用具有块作用//域的对象myClock } //程序的运行结果为： //First time output: //0:0:0 //Second time output: //8:30:30 ","date":"2024-03-31","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A15/:2:2","tags":["面向对象程序设计"],"title":"c++(five)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A15/"},{"categories":["面向对象程序设计"],"content":"数据与函数 **“数据结构+算法=程序设计”，它是结构化程序设计的基础。数据的组织就是数据结构，函数是来实现算法的。 ** 数据存储在局部对象中，通过参数传递实现共享——函数间的参数传递。 数据存储在全局对象中。可以被整个程序中所有函数共享 在面向对象程序设计中，数据描述的是对象的属性、状态 函数是算法的实现，是用来处理数据、改变对象状态的 将数据和使用数据的函数封装在类中。类的数据成员被类的成员函数共享 #include\u003ciostream.h\u003e int global; void f( ) { global=5;} void g( ) { cout\u003c\u003cglobal\u003c\u003cendl;} int main( ) { f( ); g( ); //输出“5” return 0; } #include\u003ciostream.h\u003e class Application { public: void f（ ）; void g（ ）; private: int global; }; void Application::f（ ） { global=5;} void Application::g（ ） { cout\u003c\u003cglobal\u003c\u003cendl;} int main（ ） { Application MyApp; MyApp.f（ ）; MyApp.g（ ）; return 0; } ","date":"2024-03-31","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A15/:2:3","tags":["面向对象程序设计"],"title":"c++(five)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A15/"},{"categories":["面向对象程序设计"],"content":"局部变量 局部变量：就是具有块作用域的变量 如果把数据存储在局部变量中，函数在不同的块之间只能通过参数传递来共享数据 ","date":"2024-03-31","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A15/:2:4","tags":["面向对象程序设计"],"title":"c++(five)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A15/"},{"categories":["面向对象程序设计"],"content":"全局变量 全局变量：具有文件作用域 在整个程序中，除了在定义有同名局部变量的块中之外，都有可以进行直接访问。将数据存放在全局变量中，不同的函数在不同的地方对同一全局变量进行访问，就实现了函数之间的数据共享 #include\u003ciostream.h\u003e int global; void f( ) { global=5;} void g( ) { cout\u003c\u003cglobal\u003c\u003cendl;} int main( ) { f( ); g( ); //输出“5” return 0; } ","date":"2024-03-31","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A15/:2:5","tags":["面向对象程序设计"],"title":"c++(five)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A15/"},{"categories":["面向对象程序设计"],"content":"数据成员 类的成员 数据成员 函数成员 类中的数据成员可以被同一类中任何一个函 数访问 在类内部的函数之间实现了数据的共享，另一方面这种共享是受限制的，可以设置适当的访问控制属性，把共享只限制在类的范围之内，这样对类外来说，类的数据成员仍然是隐藏的，达到了共享与隐藏两全 #include\u003ciostream.h\u003e class Application { public: void f（ ）; void g（ ）; private: int global; }; void Application::f（ ） { global=5; } void Application::g（ ） { cout\u003c\u003cglobal\u003c\u003cendl; } int main（ ） { Application MyApp; MyApp.f（ ）; MyApp.g（ ）; return 0; } #include\u003ciostream.h\u003e class Clock //时钟类声明 { public: //外部接口 void SetTime(int NewH, int NewM, int NewS); //三个形参均具有函数原型作用域 void ShowTime( ); private: //私有数据成员 int Hour,Minute,Second; }; //在类的成员函数之间共享 ","date":"2024-03-31","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A15/:2:6","tags":["面向对象程序设计"],"title":"c++(five)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A15/"},{"categories":["面向对象程序设计"],"content":"类的静态成员 静态成员的引用 例:抽象出某公司全体雇员的共性,设计如下雇员类: class employee { private: int EmpNo; int ID; char *name; //以字符指针指向字符串首地址 … // 其他数据成员与函数成员略 } ","date":"2024-03-31","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A15/:3:0","tags":["面向对象程序设计"],"title":"c++(five)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A15/"},{"categories":["面向对象程序设计"],"content":"静态数据成员 实例属性 类属性 描述类的所有对象的共同特性的一个数据项，对于任何对象实例，它的属性值是相同的。在C++语言中是通过静态数据成员来实现“类属性”的 用关键字static声明:在类的定义中仅仅对静态数据成员进行引用性声明，必须在文件作用域的某个地方使用类名限定定义性声明，这时也可以进行初始化。 该类的所有对象维护该成员的同一个拷贝 必须在类外定义和可以进行初始化，用(::)来指明所属的类 一般通过类名进行访问, 类名::标识符。也可以通过对象名.标识符访问。（这两种方式都必须是公开权限） include \u003ciostream\u003e using namespace std; class A { public: static int x; }; int A::x; void main() { cout\u003c\u003cA::x\u003c\u003cendl; A a; cout\u003c\u003ca.x\u003c\u003cendl; } 例5-4 具有静态数据成员的 Point类 #include \u003c iostream.h\u003e class Point { public: Point(int xx=0, int yy=0) { X = xx; Y = yy; countP++; } Point(Point \u0026p); int GetX（ ） {return X;} int GetY（ ） {return Y;} void GetC（ ） { cout\u003c\u003c\" Object id=\"\u003c\u003ccountP\u003c\u003cendl; } private: int X,Y; static int countP; }; Point::Point(Point \u0026p) { X=p.X; Y=p.Y; countP++; } int Point::countP=0; /*静态数据成员定义性声明和初始化,使用类名限定*/ void main（ ） { Point :: GetC ( ); //错误 Point A(4,5); cout\u003c\u003c\"Point A,\"\u003c\u003cA.GetX（ ） \u003c\u003c\",\"\u003c\u003cA.GetY（ ）; A.GetC（ ）; Point B(A); cout\u003c\u003c\"Point B,\"\u003c\u003cB.GetX（ ）\u003c\u003c\",\"\u003c\u003cB.GetY（ ）; B.GetC（ ）; } ","date":"2024-03-31","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A15/:3:1","tags":["面向对象程序设计"],"title":"c++(five)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A15/"},{"categories":["面向对象程序设计"],"content":"静态成员函数 可以使用类名或对象名来调用公有的静态成员函数。 对普通成员函数只能通过对象名来调用 静态成员函数 使用static关键字声明的函数成员 静态成员函数可以直接访问该类的静态（数据和函数）成员；而访问非静态（数据和函数）成员，要访问非静态成员必须通过参数传递方式得到对象名，然后通过对象名来访问 静态成员函数举例 #include\u003ciostream.h\u003e class Application { public: static void f（ ）; static void g（ ）; private: static int global; }; int Application::global=0; void Application::f（ ） { global=5;} void Application::g（ ） { cout\u003c\u003cglobal\u003c\u003cendl;} void main（ ） { Application::f（ ）; Application::g（ ）; } 静态成员属于类，非静态成员属于对象 静态成员函数只能引用属于该类的静态数据成员或静态成员函数。 由于静态成员不是对象成员，所以在静态成员函数 f（ ） 的实现中不能直接引用类中声明的非静态成员 在 f（ ） 的实现中，可以通过对象 a 来访问 x —— a.x class A { public: static void f(A a); private: int x; }; void A::f(A a) { cout\u003c\u003cx; //对x的引用是错误的 cout\u003c\u003ca.x; //正确 } 例:具有静态数据、函数成员的 Point类 class Point //Point类声明 { public: //外部接口 Point(int xx=0, int yy=0) { X=xx; Y=yy; countP++;} Point(Point \u0026p); //拷贝构造函数 int GetX( ) {return X;} int GetY( ) {return Y;} static void GetC( ) {cout\u003c\u003c\" Object id=\"\u003c\u003ccountP\u003c\u003cendl;} private: //私有数据成员 int X,Y; static int countP; } Point::Point(Point \u0026p) { X=p.X; Y=p.Y; countP++; } int Point::countP=0; void main( ) //主函数实现 { Point A(4,5); //声明对象A cout\u003c\u003c\"Point A,\"\u003c\u003cA.GetX( ) \u003c\u003c\",\"\u003c\u003cA.GetY( ); A.GetC( ); //输出对象号，对象名引用 Point B(A); //声明对象B cout\u003c\u003c\"Point B,\"\u003c\u003cB.GetX( ) \u003c\u003c\",\"\u003c\u003cB.GetY( ); Point::GetC( ); //输出对象号，类名引用 } ","date":"2024-03-31","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A15/:3:2","tags":["面向对象程序设计"],"title":"c++(five)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A15/"},{"categories":["面向对象程序设计"],"content":"友元 友元是C++提供的一种破坏数据封装和数据隐藏的机制 通过将一个模块声明为另一个模块的友元，一个模块能够引用到另一个模块中本是被隐藏的信息 可以使用友元函数和友元类。 为了确保数据的完整性，及数据封装与隐藏的原则，建议尽量不使用或少使用友元。 ","date":"2024-03-31","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A15/:4:0","tags":["面向对象程序设计"],"title":"c++(five)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A15/"},{"categories":["面向对象程序设计"],"content":"友元函数 友元函数是在类声明中由关键字friend修饰说明的非成员函数，在它的函数体中能够通过对象名访问private 和 protected 成员。 可以是一个普通函数，或其他类的成员函数，不是本类的成员函数。 作用：增加灵活性，使程序员可以在封装和快速性方面做合理选择。 访问对象中的成员必须通过对象名。 例:使用友元函数计算两点距离 #include \u003ciostream.h\u003e #include \u003cmath.h\u003e class Point //Point类声明 { public: //外部接口 Point(float xx=0, float yy=0) {X=xx;Y=yy;} int GetX( ) {return X;} int GetY( ) {return Y;} // 友元函数声明 friend float fDist(Point \u0026a, Point \u0026b); private: //私有数据成员 int X,Y; }; float fDist( Point\u0026 a, Point\u0026 b) { // 友元函数定义 double dx=a.X-b.X; double dy=a.Y-b.Y; return sqrt(dx*dx+dy*dy); } void main（ ） { Point p1(3.0, 5.0), p2(4.0, 6.0); float d=fDist (p1, p2); cout\u003c\u003c\"The distance is \"\u003c\u003cd\u003c\u003cendl; } ","date":"2024-03-31","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A15/:4:1","tags":["面向对象程序设计"],"title":"c++(five)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A15/"},{"categories":["面向对象程序设计"],"content":"友元类 若A类为B类的友元类，则A类的所有成员函数都能访问B类的私有成员和保护成员。 声明语法：将友元类名在另一个类中使用friend修饰说明。 一般的语法形式： class B { ……　//Ｂ类的成员声明 friend class A ; //声明A为B 的友元类 …… } 通过友元类声明，友元类的成员函数可以通过对象名直接访问到隐藏的数据，达到高效协调工作的目的 友元类举例: class A { public: void Display（ ） {cout\u003c\u003cx\u003c\u003cendl;} friend class B; private: int x; } class B { public: void Set(int i); void Display（ ）; private: A a; }; void B::Set(int i) { a.x = i; } void B::Display（ ） { a.Display（ ）; } ","date":"2024-03-31","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A15/:4:2","tags":["面向对象程序设计"],"title":"c++(five)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A15/"},{"categories":["面向对象程序设计"],"content":"共享数据的保护 常量及格式： const \u003c类型说明符\u003e \u003c变量名\u003e = \u003c常量或常量表达式\u003e; \u003c类型说明符\u003e const \u003c变量名\u003e = \u003c常量或常量表达式\u003e； 当一个变量被const修饰后，具有以下几个特点： 该变量只能读取不能修改。（编译器进行检查） 定义时必须初始化。 C++中喜欢用const来定义常量，取代原来C风格的预编译指令define。 const int var; // Error:常量 变量\"var\"需要初始化设定项 const int var1 = 42; var1 = 43; // Error：表达式必须是可以修改的左值 常量 注意，在使用const变量作为数组的下标时，变量的值一定要是一个常量表达式(在编译阶段就能计算得到结果)。 const int sz = 42; int iAr[sz]; const int sz1 = size(); // size()必须是一个返回常量的函数 int iAr1[sz1]; int var = 42; const int sz2 = var; int iAr2[sz2]; // error：sz2只有运行时才知道值 ","date":"2024-03-31","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A15/:5:0","tags":["面向对象程序设计"],"title":"c++(five)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A15/"},{"categories":["面向对象程序设计"],"content":"常引用 声明或定义的格式如下： const \u003c类型说明符\u003e \u0026\u003c变量名\u003e = …… [1] \u003c类型说明符\u003e const \u0026\u003c变量名\u003e = …… [2] const引用就是指向const对象或常变量的引用。 普通引用不能绑定到const对象或常变量，但const引用可以绑定到非const 对象或常变量。 const int ii = 456; int \u0026rii = ii; // error int jj = 123; const int \u0026rjj = jj; // ok 非const引用只能绑定到与该引用同类型的对象或变量。 const 用则可以绑定到不同但相关的类型的对象或绑定到右值。 例如： const int \u0026r = 100;//绑定到字面值常量 int i = 50; const int \u0026r2 = r + i; // 引用 r 绑定到右值 double dVal = 3.1415; const int \u0026ri = dVal; // 整型引用绑定到 double 类型编译器会把以上代码转换成如下形式的编码： int temp = dVal; // create temporary int from double const int \u0026ri = temp; // bind ri to that temporary ","date":"2024-03-31","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A15/:5:1","tags":["面向对象程序设计"],"title":"c++(five)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A15/"},{"categories":["面向对象程序设计"],"content":"常对象 数据成员的值在整个生存期内不能被改变。 常对象必须进行初始化,不能被更新。 定义常对象的一般形式为: 类名 const 对象名(实参列表); const 类名 对象名(实参列表); Time const t1(12,34,36); //定义t1为常对象 在所有的场合中，对象t1中的所有数据成员的值都不能被修改。凡希望保证数据成员不被改变的对象，可以声明为常对象。 如果一个对象被声明为常对象，则不能调用该对象的非const型的成员函数（除了由系统自动调用的隐式构造函数和析构函数）。 例: 常引用做形参 void display ( const double\u0026 r ); void main（ ） { double d ( 9.5 ); display(d); } void display(const double\u0026 r) /*常引用做形参，在函数中不能更新 r所 引用的对象。 */ { r = 15.5; //错误 cout\u003c\u003cr\u003c\u003cendl; } 常对象举例 class A { public: A( int i, int j ) { x=i; y=j; } ... private: int x, y; }; A const a(3,4); /*a是常对象,只能初始化, 不能被更新*/ 在C++的语法中，对基本数据类型的常量提供了可靠的保护。 int const n = 10 ; n = 20 ; //错误 ","date":"2024-03-31","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A15/:5:2","tags":["面向对象程序设计"],"title":"c++(five)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A15/"},{"categories":["面向对象程序设计"],"content":"用const修饰的对象成员 用const修饰的声明数据成员称为常数据成员 有两种声明形式： const int cctwl; int const cctwl; 不能省略数据类型，可以添加 public private等访问控制符。 说明： 任何函数都不能对常数据成员赋值。（除构造函数） 构造函数对常数据成员进行初始化时也只能通过初始化列表进行。 常数据成员在初始化时必须赋值或称其必须初始化. 如果类有多个构造函数必须都初始化常数据成员。 #include \u003ciostream\u003e using namespace std; class A { int w,h; const int cctw=5;//错误一 }; void main() { A a; //错误二 cout\u003c\u003c\"sss\"; } 错误一：不能对常数据成员在类中初始化、要通过类的构造函数。 错误二：没有合适的默认构造函数可用。因为有常量cctwl没有初始化必须初始化所有常数据成员。 #include \u003ciostream\u003e using namespace std; class A { int w,h; const int cctw; public: const int cctwl; A():cctw(5),cctwl(8){}; }; 多个构造函数下的常数据成员 #include \u003ciostream\u003e using namespace std; class A { int w,h; const int cctw; public: const int cctwl; A():cctw(5),cctwl(8){}; A(int x,int y){w=x,h=y;}};//错误一 错误一：每个构造函数都要初始化常数据成员，应改为： A()(int x,int y): cctw(5),cctwl(8) {w=x,h=y;}}; 常成员函数 常成员函数不能更新对象的数据成员,也不能调用该类中没有用const修饰的成员函数。 常成员函数说明格式 类型说明符 函数名（参数表）const; const是函数类型的一个组成部分，因此在实现部分也要带const关键字。 const关键字可以被用于参与对重载函数的区分,例： void print( ); void print( ) const; 通过常对象只能调用它的常成员函数 常数据成员 使用const说明的数据成员。 构造函数对常数据成员进行初始化，只能通过初始化列表。 用const修饰的声明成员函数称为常成员函数： const是函数类型的一部分，在实现部分也要带该关键字 const关键字可以用于对重载函数的区分 常成员函数不能更新任何数据成员，也不能调用该类中没有用const修饰的成员函数，只能调用常成员函数。 const是函数类型的一部分，在实现部分也要带该关键字： #include \u003ciostream\u003e using namespace std; class A { int w,h; public: int getValue() const; int getValue(); A(int x,int y) {w=x,h=y; } }; int A::getValue() const {return w*h;} int A::getValue() {return h;} void main() { A const a(3,4); A c(2,6); cout\u003c\u003ca.getValue()\u003c\u003c\" \"\u003c\u003cc.getValue(); } 常成员函数举例: #include\u003ciostream.h\u003e class R { public: R(int r1, int r2) { R1=r1; R2=r2;} void print( ); void print( ) const; private: int R1, R2; }; void R::print( ) { cout\u003c\u003cR1\u003c\u003c\":\"\u003c\u003cR2\u003c\u003cendl; } void R::print( ) const { cout\u003c\u003cR1\u003c\u003c\";\"\u003c\u003cR2\u003c\u003cendl; } void main( ) { R a(5,4); a.print( ); //调用void print( ) const R b(20, 52); //b是常对象 b.print( ); //调用void print（ ） const } //运行结果 //5:4 //20:52 #include \u003ciostream\u003e using namespace std; class A { public: A(int i); void print(); const int\u0026 r; private: const int a; static const int b; //静态常数据成员 const int A::b=10; //静态常数据成员在类外声明和初始化 A::A(int i):a(i),r(a) {} void A::print() { cout\u003c\u003ca\u003c\u003c\":\"\u003c\u003cb\u003c\u003c\":\"\u003c\u003cr\u003c\u003cendl; } void main() {/*建立对象a1和a2，并以100和0作为初值，分别调用构造函数，通过构造函数的初始化列表给对象的常数据成员赋初值*/ A a1(100), a2(0); a1.print(); a2.print(); } //运行结果： //100:10:100 //0:10:0 注意 : 常成员函数可以被其他成员函数调用 但是不能调用其他非常成员函数 可以调用其他常成员函数 ","date":"2024-03-31","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A15/:5:3","tags":["面向对象程序设计"],"title":"c++(five)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A15/"},{"categories":["面向对象程序设计"],"content":"多文件结构编译预处理命令 ","date":"2024-03-31","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A15/:6:0","tags":["面向对象程序设计"],"title":"c++(five)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A15/"},{"categories":["面向对象程序设计"],"content":"C++程序的一般组织结构(多文件结构) 一个源程序一般至少分为三个源文件： 类声明文件(.h文件) 类实现文件(.cpp文件) 类的使用文件(main( )所在的.cpp文件) 利用工程来组合各个文件。 例:具有静态数据、函数成员的Point类，多文件组织 //文件1，类的声明，point.h # include \u003c iostream.h\u003e class Point //Point类声明 { public: //外部接口 Point(int xx=0, int yy=0) { X=xx; Y=yy; countP++;} Point(Point \u0026p); //拷贝构造函数 int GetX( ) {return X;} int GetY( ) {return Y;} static void GetC( ) {cout\u003c\u003c\" Object id=\"\u003c\u003ccountP\u003c\u003cendl;} private: //私有数据成员 int X,Y; static int countP;　//静态数据成员 }; //文件2，类实现，point.cpp # include “point.h” Point::Point(Point \u0026p) { X=p.X; Y=p.Y; countP++; } //文件3，主函数，fmain.cpp # include “point.h” int Point::countP=0; void main( ) //主函数实现 { Point A(4,5); //声明对象A cout\u003c\u003c\"Point A,\"\u003c\u003cA.GetX( ) \u003c\u003c\",\"\u003c\u003cA.GetY( ); A.GetC( ); //输出对象号，对象名引用 Point B(A); //声明对象B cout\u003c\u003c\"Point B,\"\u003c\u003cB.GetX( ) \u003c\u003c\",\"\u003c\u003cB.GetY( ); Point::GetC( ); //输出对象号，类名引用 分析： ","date":"2024-03-31","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A15/:6:1","tags":["面向对象程序设计"],"title":"c++(five)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A15/"},{"categories":["面向对象程序设计"],"content":"编译预处理命令 #include 指令（文件包含指令） 将另一个源文件嵌入到当前源文件中该点处 #include \u003c文件名\u003e 按标准方式搜索，文件位于C++系统目录的include子目录下 #include “文件名” 首先在当前目录中搜索，若没有，再按标准方式搜索。 #include指令可以嵌套使用 有一头文件myhead.h，在中又可嵌套文件包含指令： #include “file1.h” #include “file2.h” #define宏定义指令 定义符号常量，已被const定义语句取代。 例： #define PI 3.14159 定义带参数宏，已被内联函数取代。 #undef 删除由#define定义的宏,使之不再起作用 #define定义空符号 # define LETTER 条件编译指令 #if 和 #endif #if 常量表达式 //当“ 常量表达式”非零时编译本程序段 程序正文 #endif　条件编译指令—— #else #if 常量表达式 //当“ 常量表达式”非零时编译 程序正文1 #else //当“ 常量表达式”为零时编译 程序正文2 #endif # define LETTER 1 main( ) { char str[20] =“Clanguage”,c; int i; i = 0; While((c = str[i])!=‘\\0’) { i++; # if LETTER if (c\u003e=‘a’\u0026\u0026c\u003c=‘z’) c = c-32; # else if (c\u003e=‘A’\u0026\u0026c\u003c=‘Z’) c = c+32; # endif 条件编译指令 #elif #if 常量表达式1 程序正文1 //当“ 常量表达式1”非零时编译 #elif 常量表达式2 程序正文2 //当“ 常量表达式2”非零时编译 #else 程序正文3 //其它情况下编译 #endif 条件编译指令 #ifdef #ifdef 标识符 程序正文1 #else 程序正文2 #endif #ifdef 标识符 程序正文1 #endif 如果“标识符”经**#defined**定义过，且未经undef删除，则编译程序正文1，否则编译程序正文2。如果没有则编译程序正文2，如果没有程序正文2，则#else可以省略： 例： # ifdef COMPUTER_A # define INTEGER_SIZE 16 # else # define INTEGER_SIZE 32 # endif 即如果COMPUTER_A在前面已被定义过，则编译命令行: # define INTEGER_SIZE 16 //否则，编译 # define INTEGER_SIZE 32 条件编译指令 #ifndef #ifndef 标识符 程序正文1 #else 程序正文2 #endif 如果“标识符”未被定义过，则编译程序正文1，否则编译程序正文2。如果没有程序正文2，则#else可以省略： #ifdef 标识符 程序正文1 #endif defined(标识符) define是一个预处理操作符，而不是指令，因此不要以#开头。 **格式： ** define(标识符) 功能： 若“标识符”在此前经**#defined**定义过,且未经undef删除,则上述表达式为非0,否则上述表达式的值为0。 例：下面两种写法完全等效 #ifndef MYHEAD_H #define MYHEAD_H\r...\r＃endif #if ! Define(MYHEAD_H)\r#define MYHEAD_H\r...\r＃endif 注意：由于文件包含指令可以嵌套使用，在设计程序时要避免多次重复包含同一个头文件，否则会引起变量及类的重复定义 // main.cpp #include “file1.h” #include “file2.h” void main( ) { …… } //file1.h #include “head.h” …… //file2.h #include “head.h” …… //head.h …… class Point { …… } …… //head.h #ifndef HEAD_H #define HEAD_H …… class Point { …… } …… #endif ","date":"2024-03-31","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A15/:6:2","tags":["面向对象程序设计"],"title":"c++(five)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A15/"},{"categories":["数据结构"],"content":"栈和队列 ","date":"2024-03-31","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%843/:0:0","tags":["数据结构"],"title":"数据结构(第三章)","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%843/"},{"categories":["数据结构"],"content":"栈 ","date":"2024-03-31","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%843/:1:0","tags":["数据结构"],"title":"数据结构(第三章)","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%843/"},{"categories":["数据结构"],"content":"栈的定义及基本运算 栈(Stack)的定义 栈(Stack)是限制在表的一端进行插入和删除运算的线性表，通常称插入、删除的这一端为栈顶(top),另一端为栈底(bottom)。当表中没有元素时称为空栈。 栈的特点 栈的修改是按后进先出的原则进行的。因此，栈称为后进先出表（LIFO）。 栈的运算演示 A、B、C、D四个元素依次进入一个栈，再依次出栈，得到一个输出序列DCBA。 栈的基本运算 InitStack(\u0026S): 初始化栈S StackEmpty(): 判断栈是否为空 Push(e): 将元素e放入栈顶 Pop(e): 移走栈顶的元素，同时由e带回该元素的值 Gettop(): 获取栈顶的元素，但不从栈中移走 ","date":"2024-03-31","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%843/:1:1","tags":["数据结构"],"title":"数据结构(第三章)","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%843/"},{"categories":["数据结构"],"content":"栈的存储结构和实现 栈的表示和实现 假设栈$S=(a_1，a_2，a_3，…，a_n)$，则**$a_1$称为栈底元素，$a_n$为栈顶元素**。栈中元素按$a_1，a_2，a_3，…,a_n$的次序进栈，退栈的第一个元素应为栈顶元素。换句话说，栈的修改是按后进先出的原则进行的。因此，**栈称为后进先出表(Last In First Out，LIFO) ** 顺序栈 由于栈是运算受限的线性表，因此线性表的存储结构对栈也适应。栈的顺序存储结构简称为顺序栈，它是运算受限的线性表。因此，可用数组来实现顺序栈。 顺序栈的类型定义 // -----栈的顺序存储表示----- # define STACK_INIT_SIZE 100; # define STACKINCREMENT 10; typedef struct { SElemType *base; //栈底指针，栈构造前和销毁后为空 SElemType *top; //栈顶指针，指向栈顶元素的下一位置 int stacksize; //当前分配的栈的存储空间数 }SqStack; 顺序栈运算 设S是SqStack类型的指针变量。base是栈底指针。Top是栈顶指针。 栈不存在条件S.base=NULL 栈空条件S.top=S.base 插入栈顶元素，栈顶指针S.top=S.top+1 删除栈顶元素，栈顶指针S.top=S.top-1 栈满条件S.top-S.base\u003e=S.stacksize 顺序栈的C语言实现 //初始化 Status InitStack(SqStack \u0026S){ //构造一个空栈 S.base = (ElemType *) malloc(STACK_INIT_SIZE *sizeof(SElemType)) ; if(!S.base) exit (OVERFLOW); S.top = S.base; S.stacksize = STACK_INIT_SIZE ; return OK; }//InitStack //判断栈空 int StackEmpty(SqStack \u0026S) { return(S.base==S.top); } //判断栈满 int StackFull(SqStack \u0026S) { return(S.top-S.base\u003e=S.stacksize); } //元素入栈 Status Push(SqStack \u0026S, SElemType e){ //插入元素e为新的栈顶元素 if (S.top – S.base \u003e= S.stacksize) return OVERFLOW; //栈满 *S.top = e; S.top++; return OK; }//Push //出栈 void Pop(SqStack \u0026S, SElemType \u0026e) { if(S.top==s.base) return UNDERFLOW; // 栈空 S.top--; e=*S.top; return; } 链栈 栈的链式存储结构称为链栈，它是运算是受限的单链表，插入和删除操作仅限制在表头位置上进行。由于只能在链表头部进行操作，故链表没有必要像单链表那样附加头结点。栈顶指针就是链表的头指针。 //链栈的类型说明如下： typedef struct stacknode { SElemType data; struct stacknode *next; } stacknode,*linkstack; 链栈的基本操作 //置空栈 void InitStack(linkStack \u0026p) { p=NULL; } //判断栈空 int StackEmpty(linkstack p) { return p==NULL; } //进栈 void Push(linkstack \u0026p, SElemType e) { stacknode *q; q=(stacknode*)malloc(sizeof(stacknode)); q–\u003edata=e; q–\u003enext=p; p=q; //设置栈顶指针 } //退栈 SElemType Pop(linkstack \u0026p) { SElemType x; //临时变量，保存栈顶元素 linkstack q=p; if(p==NULL) error(“stack underflow.”); p=p–\u003enext; //调整栈顶指针 x=q–\u003edata; free(q); //删除栈顶元素 return x; } //取栈顶元素 SElemType GetTop(linkstack p) { if(p==NULL) error(“stack is empty.”); return p–\u003edata; } ","date":"2024-03-31","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%843/:1:2","tags":["数据结构"],"title":"数据结构(第三章)","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%843/"},{"categories":["数据结构"],"content":"栈的应用举例 根据栈的FILO特性，用作某些处理问题的工具。 ","date":"2024-03-31","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%843/:2:0","tags":["数据结构"],"title":"数据结构(第三章)","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%843/"},{"categories":["数据结构"],"content":"数制转换 void conversion( ) { InitStack(S); //构造空栈 scanf (“%d”,\u0026n); while(n){ Push(S,n%2); n=n/2; } while(! StackEmpty(S)){ Pop(S,e); printf(“%d”,e); } } ","date":"2024-03-31","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%843/:2:1","tags":["数据结构"],"title":"数据结构(第三章)","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%843/"},{"categories":["数据结构"],"content":"括号匹配 设一个表达式中可以包含三种括号：“(”和“)”、“[”和“]”、“{”和“}”，并且这三种括号可以按照任意的次序嵌套使用，考查表达式中的括号是否匹配。例如： …[…{…[…}…]…]…[…]…(…)…)… 例： a=b+(c-d)*(e-f)); while (m\u003c(a[8]+t) { m=m+1; t=t-1; } 实现方法－－利用栈进行表达式中的括号匹配 自左至右扫描表达式，若遇左括号，则将左括号入栈，若遇右括号，则将其与栈顶的左括号进行匹配，若配对，则栈顶的左括号出栈，否则出现括号不匹配错误。 ","date":"2024-03-31","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%843/:2:2","tags":["数据结构"],"title":"数据结构(第三章)","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%843/"},{"categories":["数据结构"],"content":"迷宫问题 寻找一条从入口到出口的通路 迷宫的表示 const int N=8; struct PosType{ int x, y; }; char maze[N][N]; //位置上的标识，是否可通过 迷宫初始化 用二层嵌套循环对迷宫赋值 迷宫求解 #define _CRT_SECURE_NO_WARNINGS 1 #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #define STACK_INIT_SIZE 100 //存储空间初始分配量 #define STACKINCREMENT 10 //存储空间分配增量 #define MAXLENGTH 25 //迷宫最大行列值 #define OK 1 #define ERROR 0 #define TRUE 1 #define FALSE 0 typedef struct { int x; int y; }PosType; //坐标 typedef struct { int ord; //通道块在路径上的序号 PosType seat; //通道块在迷宫中的坐标 int di; //从此通道块走行下一通道块的方向 }SElemType; //栈元素类型 typedef struct Stack{ SElemType* base; //栈底指针 SElemType* top; //栈顶指针 int stacksize; //当前已分配的存储空间 }SqStack; typedef int Status; typedef int MazeType[MAXLENGTH][MAXLENGTH]; //声明全局变量 int x, y; //迷宫的行列数 int curstep = 1; //足迹路线，开始在入口处，每找到一个足迹递增1 PosType begin; //迷宫入口坐标 PosType end; //迷宫出口坐标 PosType direc[4] = { {0,1},{1,0},{0,-1},{-1,0} }; //移动方向依次位东南西北 MazeType maze; //迷宫数组（等价于maze[MAXLENGTH][MAXLENGTH]）,此时未初始化值全为0 Status InitStack(SqStack* S); Status StackEmpty(SqStack S); Status Push(SqStack* S, SElemType e); Status Pop(SqStack* S, SElemType* e); Status ClearStack(SqStack* S); Status DestroyStack(SqStack* S); void Init(); void Print(); void MarkPrint(PosType e); Status Pass(PosType b); void FootPrint(PosType b); PosType NextPos(PosType b, int di); Status MazePath(PosType start, PosType end); int main() { Init(); //初始化迷宫 if (MazePath(begin, end)) { printf(\"此迷宫的一条路径如下\\n\"); Print(); } else { Print(); printf(\"没有通道\\n\"); } return 0; } //栈的基本操作部分 Status InitStack(SqStack* S) { //申请一个动态数组,为栈创建存储空间 S-\u003ebase = (SElemType*)malloc(STACK_INIT_SIZE*sizeof(SElemType)); if (!S-\u003ebase) exit(EXIT_FAILURE); S-\u003etop = S-\u003ebase; //此时栈顶指针和栈底指针相同 S-\u003estacksize = STACK_INIT_SIZE; return OK; } Status StackEmpty(SqStack S) { if (S.base == S.top) return TRUE; else return FALSE; } Status Push(SqStack* S, SElemType e) { if (S-\u003etop - S-\u003ebase \u003e= S-\u003estacksize) { S-\u003ebase = (SElemType*)realloc(S-\u003ebase, (S-\u003estacksize + STACKINCREMENT) * sizeof(SElemType)); if (!S-\u003ebase) exit(EXIT_FAILURE); S-\u003etop = S-\u003ebase + S-\u003estacksize; S-\u003estacksize += STACKINCREMENT; } *S-\u003etop++ = e; //等同*S-\u003etop == e; S-\u003etop++; return OK; } Status Pop(SqStack* S, SElemType* e) { if (!S-\u003ebase) return ERROR; else if (S-\u003ebase == S-\u003etop) return ERROR; --(S-\u003etop); *e = *(S-\u003etop); return OK; } Status ClearStack(SqStack* S) { S-\u003ebase = S-\u003etop; return OK; } Status DestroyStack(SqStack* S) { S-\u003etop = NULL; S-\u003estacksize = 0; free(S-\u003ebase); return OK; } //迷宫实现部分 void Init() { int i, j; int x1, y1; printf(\"请输入迷宫的行列数：\\n\"); scanf(\"%d %d\", \u0026x, \u0026y); //赋值时将最外面一圈设置为墙，所以x-1 y-1 for (i = 1; i \u003c x - 1; i++) for (j = 1; j \u003c y - 1; j++) maze[i][j] = 1; printf(\"请设置迷宫内有几个墙：\\n\"); scanf(\"%d\", \u0026j); printf(\"请输入迷宫内每个墙的位置:\\n\"); for (i = 0; i \u003c j; i++) { scanf(\"%d %d\", \u0026x1, \u0026y1); maze[x1][y1] = 0; } printf(\"迷宫结构如图\\n\"); Print(); printf(\"请输入入口的行列数\\n\"); scanf(\"%d %d\", \u0026begin.x, \u0026begin.y); printf(\"请输入出口的行列数\\n\"); scanf(\"%d %d\", \u0026end.x, \u0026end.y); } void Print() { int i, j; for (i = 0; i \u003c x; i++) { for (j = 0; j \u003c y; j++) printf(\"%3d\", maze[i][j]); puts(\"\"); } } void MarkPrint(PosType e) { maze[e.x][e.y] = -1; } Status Pass(PosType b) { if (maze[b.x][b.y] == 1) return OK; else return ERROR; } void FootPrint(PosType b) { maze[b.x][b.y] = curstep; } PosType NextPos(PosType b, int di) { b.x += direc[di].x; b.y += direc[di].y; return b; } //书上有参数MazeType maze，我们声明了全局变量所以不需要此参数 Status MazePath(PosType start, PosType end) { SqStack S; PosType curpos; SElemType e; InitStack(\u0026S); curpos = start; //入口位置 //书上有curpos = 1，我们声明了全局变量所以不用此代码 do { if (Pass(curpos))//当前位置可以通过，未曾走到过的通道快 { FootPrint(curpos); //在此位置留下足迹 e.ord = curstep; e.seat = curpos; //位置 e.di = 0; //direc[0]是东所以先让e.di =0 Push(\u0026S, e); if (curpos.x == end.x \u0026\u0026 curpos.y == end.y) return TRUE; curpos = NextPos(curpos, e.di); //下一位置是当前元素的东邻 curstep++; //探索下一步 } else { if (!StackEmpty(S)) { Pop(\u0026S, \u0026e); //退栈到前一位置，改变前一位置中的方向 curstep--; while (e.di == 3 \u0026\u0026 !StackEmpty(S)) //前一位置处于最后一个方向 { //此循环将栈中元素退回到还有被方向没有使用的坐标处 MarkPrint(e.seat); //留下不能通过的标记 Pop(\u0026S, \u0026e); //退回1步 curstep--; //足","date":"2024-03-31","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%843/:2:3","tags":["数据结构"],"title":"数据结构(第三章)","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%843/"},{"categories":["数据结构"],"content":"表达式求值—算符优先法 4+2×3-10/5 – 先乘除,后加减; – 从左算到右 – 先括号内,后括号外 – 4+2×3-10/5=4+6-10/5=10-10/5=10-2=8 表达式由操作数(operand)、运算符(operator)和界限符(delimiter)组成的。 将运算符和界限符统称为算符。它们构成的集合命名为OP 表达式求值 算符优先算法:用两个工作栈。一个称作OPTR,用于存放运算符;另一个称作OPND,用以存放操作数或运算结果。 首先置操作数栈为空栈，表达式起始符“#”为运算符的栈底元素； 依次读入表达式中每个字符，若是操作数则进OPND栈，若是运算符，则和OPTR栈的栈顶运算符比较优先权后作相应操作，直到整个表达式求值完毕(OPTR栈的栈顶元素和当前读入的字符均为“#”) OperandType EvaluateExpression() { InitStack(OPTR); Push(OPTR,’#’); InitStack(OPND); c = getchar(); while(c != ‘#’||GetTop(OPTR)!=‘#’){ if(!In(c,OP)) {Push(OPND,c); c=getchar();} else //不是运算符则进栈 switch(Precede(GetTop(OPTR),c)){ case ‘\u003c’: //栈顶元素优先权低 Push(OPTR,c); c=getchar(); break; case ‘=’: //脱括号并接收下一字符 Pop(OPTR,x); c=getchar(); break; case ‘\u003e’: //退栈并将运算结果入栈 Pop(OPTR,theta); Pop(OPND,b); Pop(OPND,a); Push(OPND,Operate(a,theta,b)); break; } //switch }//while return GetTop(OPND); }//EvaluateExpression 栈与递归的实现 用栈结构实现程序设计语言中函数的嵌套调用和递归调用 例： long f(int n) { if (n\u003e1) return n*f(n-1); else return 1; } void main( ) { int n=4; printf(“%ld”,f(n)); } n阶Hanoi塔 问题 假设有三个分别命名为X、Y和Z的塔座，在塔座X上插有n个直径大小各不相同、依小到大编号为1，2，…,n的圆盘。现要求将X轴上的n个圆盘移至塔座Z上并仍按同样顺序叠排。 每次只能移动一个圆盘； 圆盘可以插在X、Y和Z中的任一塔座上 任何时刻都不能将一个较大的圆盘压在较小的圆盘之上。 队列(Queue)的定义 队列是仅限定在表尾进行插入和表头进行删除操作的线性表 术语 队头(front)－－队列的表头，即只允许删除的一端。 队尾(rear) －－队列的表尾，即只允许插入的一端。 入队(EnQueue) －－向队尾插入元素 出队(DeQueue) －－从队头删除元素 队列的特点 队列的修改是按先进先出的原则进行的。因此，队列称为先进先出表（FIFO）。 队列的基本运算 InitQueue(\u0026Q): 初始化队列Q QueueEmpty(): 判断队列是否为空 EnQueue(e): 将元素e放入队尾 DeQueue(e): 移走队头元素，由e带回该元素的值 GetFront(): 获取队头元素的值，但不从队列中移走该元素 Length(): 计算并返回队列中元素的个数 链队列－－队列的链式存储结构 链队列的C语言实现 //-----单链队列的存储结构----- typedef struct QNode{ //链表结点类型 QElemType data; struct QNode *next; }QNode,*QueuePtr; typedef struct { //队列类型 QueuePtr front; //队头指针 QueuePtr rear; //队尾指针 }LinkQueue; 链队列基本操作的实现 初始化 Status InitQueue(LinkQueue \u0026Q) { //构造一个空队列Q Q.front= Q.rear = (QueuePtr)malloc(sizeof(QNode)); if(!Q.front) exit(OVERFLOW); Q.front-\u003enext = NULL; return OK; } 入队 Status EnQueue(LinkQueue \u0026Q, QElemType e){ //将元素e插入到队列Q中 p = (QueuePtr)malloc(sizeof(QNode)); if (!p) exit(OVERFLOW); p-\u003edata = e; p-\u003enext=NULL; Q.rear-\u003enext = p; Q.rear = p; return OK; } 出队列 Status DeQueue(LinkQueue \u0026Q, QElemType \u0026e){ //若队列不空，则队头元素出队列，用e返回其值， //返回OK，否则返回ERROR if (Q.rear == Q.front) return ERROR; p = Q.front -\u003e next; e = p -\u003e data; Q.front-\u003enext = p -\u003e next; if (Q.rear == p) Q.rear = Q.front; free(p); return OK; } 循环队列－－队列的顺序存储结构 循环队列的C语言实现 //----循环队列的存储结构---- #define MAXSIZE 100 typedef struct { QElemType *base; int front; int rear; }SqQueue; 循环队列基本操作的实现 初始化 Status InitQueue(SqQueue \u0026Q){ Q.base=(QElemType *) malloc(MAXSIZE*sizeof(QElemType)); if (!Q.base) exit (OVERFLOW); Q.front = Q.rear = 0; return OK; } 入队 Status EnQueue(SqQueue \u0026Q,QElemType e) { //将元素e插入队列Q的队尾 if ((Q.rear+1) % MAXSIZE == Q.front) return ERROR; Q.base[Q.rear] = e; Q.rear = (Q.rear+1) % MAXSIZE; return OK; } 出队 Status DeQueue(SqQueue \u0026Q,QElemType \u0026e) { //删除队列Q的队头元素并用e带回 if (Q.front == Q.rear) return ERROR; e = Q.base[Q.front]; Q.front = (Q.front+1) % MAXSIZE; return OK; } ","date":"2024-03-31","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%843/:2:4","tags":["数据结构"],"title":"数据结构(第三章)","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%843/"},{"categories":["数据结构"],"content":"双端队列 双端队列 输出受限的双端队列 输入受限的双端队列 ","date":"2024-03-31","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%843/:2:5","tags":["数据结构"],"title":"数据结构(第三章)","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%843/"},{"categories":["数据结构"],"content":"优先队列 在许多情况下，简单的队列结构是不够的，需要使用某些优先规则来完善先入先出机制 优先队列的问题是如何找到一种实现优先的方法，使得入队和出队列操作得以相对容易实现。 优先队列可以通过两种修正的链表结构来实现。 一种结构是元素仍然依次进入（即加入元素时，时间复杂度为O(1)），而取出元素时则需遍历队列（即出队时的时间复杂度为O(n)）， 另一种是根据元素的优先级决定其插入的位置（即入队时的时间复杂度为O(n)，出队时的时间复杂度为O(1)） ","date":"2024-03-31","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%843/:2:6","tags":["数据结构"],"title":"数据结构(第三章)","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%843/"},{"categories":["数据结构"],"content":"队列的应用 同栈一样，队列也是一种应用广泛的线性表，在日常生活和计算机科学中很常见： 离散事件模拟 排队问题 作业控制 广度优先搜索 … ","date":"2024-03-31","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%843/:2:7","tags":["数据结构"],"title":"数据结构(第三章)","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%843/"},{"categories":["计算机组成原理"],"content":"存储系统 ","date":"2024-03-31","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%863/:0:0","tags":["计算机组成原理"],"title":"计算机组成(第三章)","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%863/"},{"categories":["计算机组成原理"],"content":"存储器概述 存储器的两大功能： 存储（写入Write） 取出（读出Read） 三项基本要求： 大容量 高速度 低成本 概念 基本存储单元：存储一位（bit）二进制代码的存储元件称为基本存储单元（或存储元） 存储单元：主存中最小可编址的单位，是CPU对主存可访问操作的最小单位。 存储器：多个存储单元按一定规则组成一个整体 ","date":"2024-03-31","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%863/:1:0","tags":["计算机组成原理"],"title":"计算机组成(第三章)","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%863/"},{"categories":["计算机组成原理"],"content":"存储器的分类 按存储介质分 半导体存储器：用半导体器件组成的存储器 磁表面存储器：用磁性材料做成的存储器 按存储方式分 随机存储器：任何存储单元的内容都能被随机存取，且存取时间和存储单元的物理位置无关 顺序存储器：只能按某种顺序来存取，存取时间和存储单元的物理位置有关 按存储器的读写功能分：ROM，RAM 只读存储器(ROM)：存储的内容是固定不变的，只能读出而不能写入的半导体存储器。　随机读写存储器(RAM)：既能读出又能写入的半导体存储器。 按信息的可保存性分：非永久记忆，永久记忆 非永久记忆的存储器：断电后信息即消失的存储器。 永久记忆性存储器：断电后仍能保存信息的存储器 按在计算机系统中的作用分： 主存、辅存、高速缓存、控制存储器等 ","date":"2024-03-31","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%863/:1:1","tags":["计算机组成原理"],"title":"计算机组成(第三章)","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%863/"},{"categories":["计算机组成原理"],"content":"存储器的分级结构 寄存器 微处理器内部的存储单元 高速缓存（Cache） 完全用硬件实现主存储器的速度提高 主存储器 存放当前运行程序和数据，采用半导体存储器构成 辅助存储器 磁记录或光记录方式 磁盘或光盘形式存放可读可写或只读内容 以外设方式连接和访问 ","date":"2024-03-31","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%863/:1:2","tags":["计算机组成原理"],"title":"计算机组成(第三章)","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%863/"},{"categories":["计算机组成原理"],"content":"主存储器的技术指标 存储容量 主存存储容量：以字节B（Byte）为基本单位 半导体存储器芯片：以位b （Bit）为基本单位 存储容量以$2_{10}＝1024$规律表达KB，MB，GB和TB 厂商常以$10_3＝1000$规律表达KB，MB，GB和TB 存取时间（访问时间） 发出读/写命令到数据传输操作完成所经历的时间 存取周期 两次存储器访问所允许的最小时间间隔 存取周期大于等于存取时间 存储器带宽（数据传输速率） 单位时间里存储器所存取的信息量 按边界对齐的方式存储数据 int i, short k, double x, char c, short j int (4字节） short (2字节） double (8字节） char (1字节) short按16位对齐， int按32位对齐，double按64位对齐 对齐可提升访问数据的速度，不对齐可节约空间 ","date":"2024-03-31","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%863/:1:3","tags":["计算机组成原理"],"title":"计算机组成(第三章)","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%863/"},{"categories":["计算机组成原理"],"content":"随机读写存储器 SRAM（静态RAM：Static RAM） 以触发器为基本存储单元 不需要额外的刷新电路 速度快，但集成度低，功耗和价格较高 DRAM（动态RAM：Dynamic RAM） 以单个MOS管为基本存储单元 要不断进行刷新（Refresh）操作 集成度高、价格低、功耗小，但速度较SRAM慢 ","date":"2024-03-31","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%863/:2:0","tags":["计算机组成原理"],"title":"计算机组成(第三章)","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%863/"},{"categories":["计算机组成原理"],"content":"SRAM存储器 6个开关管组成一个存储元，存储一位信息 **N(=1/4/8/16/32)**个存储元组成一个存储单元 存储器芯片的大量存储单元构成存储体 存储器芯片结构 存储单元数×每个存储单元的数据位数＝2M×N＝芯片的存储容量 M＝芯片地址线的个数 N＝数据线的个数 ","date":"2024-03-31","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%863/:2:1","tags":["计算机组成原理"],"title":"计算机组成(第三章)","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%863/"},{"categories":["计算机组成原理"],"content":"SRAM的控制信号 片选（CS或CE） 片选有效，才可以对芯片进行读/写操作 无效时，数据引脚呈现高阻状态，并可降低功耗 读控制（OE*） 芯片被选中有效，数据输出到数据引脚 对应存储器读MEMR* 写控制（WE*） 芯片被选中的前提下，若有效，将数据写入 对应存储器写MEMW* ","date":"2024-03-31","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%863/:2:2","tags":["计算机组成原理"],"title":"计算机组成(第三章)","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%863/"},{"categories":["计算机组成原理"],"content":"六管SRAM存储器 (SRAM Cell) SRAM存储器的组成介绍 存储体：存储单元的集合，通常用X选择线（行线）和Y选择线（列线）的交叉来选择所需要的单元。 地址译码器：将用二进制代码表示的地址转换成输出端的高电位，用来驱动相应的读写电路，以便选择所要访问的存储单元。有两种方式： 单译码：一个地址译码器，适用于小容量存储器 双译码：X向和Y向两个译码器，适用于大容量存储器 RAM结构与地址译码—字结构或单译码方式 结构： 存储容量Ｍ=Ｗ行×b列； 阵列的每一行对应一个字，有一根公用的字选择线Ｗ； 每一列对应字线中的一位，有两根公用的位线BS0 与BS1 。 存储器的地址不分组，只用一组地址译码器。 字结构是2度存储器：只需使用具有两个功能端的基本存储电路：字线和位线 优点：结构简单，速度快：适用于小容量M 缺点：外围电路多、成本昂贵，结构不合理。 RAM结构与地址译码—位结构或双译码方式 结构： 容量：**N（字）×b（位）的RAM，把每个字的同一位组织在一个存储片上，每片是N×1；再把b 片并列连接，组成一个N×b的存储体，就构成一个位结构的存储器。 ** 在每一个N×1存储片中，字数Ｎ被当作基本存储电路的个数。若把N＝２n 个基本存储电路排列成$N_x$行与$N_y$列的存储阵列，把CPU送来的n位选择地址按行和列两个方向划分成$n_x$ 和$n_y$ 两组，经行和列方向译码器，分别选择驱动行线Ｘ与列线Ｙ。 采用双译码结构，可以减少选择线的数目。 优点：驱动电路节省，结构合理，适用于大容量存储器。 ","date":"2024-03-31","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%863/:2:3","tags":["计算机组成原理"],"title":"计算机组成(第三章)","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%863/"},{"categories":["计算机组成原理"],"content":"译码方式 ","date":"2024-03-31","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%863/:2:4","tags":["计算机组成原理"],"title":"计算机组成(第三章)","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%863/"},{"categories":["计算机组成原理"],"content":"存储器的读、写周期 计算机是一个有严格时序控制要求的机器。与CPU连接时,CPU的控制信号与存储器的读、写周期之间的配合问题是非常重要的。 注意: 读出时间与读周期是两个不同的概念。 读出时间：是指从CPU给出有效地址开始，到外部数据总线上稳定地出现所读出的数据信息所经历的时间 读周期时间：则是指对存储片进行两次连续读操作时所必须间隔的时间。 显然总有：读周期 ≥ 读出时间 ","date":"2024-03-31","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%863/:2:5","tags":["计算机组成原理"],"title":"计算机组成(第三章)","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%863/"},{"categories":["计算机组成原理"],"content":"静态 RAM (2114) 读 时序 ","date":"2024-03-31","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%863/:2:6","tags":["计算机组成原理"],"title":"计算机组成(第三章)","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%863/"},{"categories":["计算机组成原理"],"content":"静态 RAM (2114) 写 时序 ","date":"2024-03-31","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%863/:2:7","tags":["计算机组成原理"],"title":"计算机组成(第三章)","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%863/"},{"categories":["计算机组成原理"],"content":"动态MOS存储器 4管动态M0S存储元电路 在6管静态存储元电路中，信息是存于T0，T1管的栅极电容上，由负载管T4 ，T5 经外电源给T0 ，T1 管栅极电容不断地进行充电以补充电容电荷。维持原有信息所需要的电荷量。 由于MOS的栅极电阻很高，栅极电容经栅漏（或栅源）极间的泄漏电流很小，在一定的时间内（如2ms），存储的信息电荷可以维持住。为了减少管子以提高集成度。可以去掉补充电荷的负载管和电源，变成4管动态存储元： 刷新过程：在字选择线上加一个脉冲就能实现自动刷新。显然，只要定时给全部存储元电路执行一遍读操作，而信息不向外输出，那么就可以实现动态存储器的再生或刷新。 单管动态MOS存储元电路 根据动态平衡的电荷数多少来判断原存信息是０或１，因此，每次读出后，存储内容就被破坏。是破坏性读出，必须采取措施，以便再生原存信息。 四管DRAM存储器 ","date":"2024-03-31","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%863/:2:8","tags":["计算机组成原理"],"title":"计算机组成(第三章)","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%863/"},{"categories":["计算机组成原理"],"content":"单管DRAM存储 预充操作 (Precharge) 访问操作 (Access) 行选通，$T_1$管导通 存储电容和位线寄生电容电荷重分配 引起两位线上电压微弱差异 信号检测 (Sense) 电压略高的一侧拉升到逻辑1，另一侧为0 数据恢复 (Restore) 如数据为1，位线上的逻辑1给存储电容进行充电 数据输出(Output) 给出列选通信号，数据输出到外部。 行列选通信号分时给出，行列地址复用减少引脚 撤除行选通信号，关闭读出放大检测电路 ","date":"2024-03-31","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%863/:2:9","tags":["计算机组成原理"],"title":"计算机组成(第三章)","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%863/"},{"categories":["计算机组成原理"],"content":"DRAM 刷新 刷新：定期补充电荷以避免电荷泄露引起的信息丢失 电容存在泄露电流 刷新周期: 存储器两次完整刷新之间的时间间隔，一般为2ms，4ms或8ms 信息存储到泄漏之间必须完成刷新，称为最大刷新周期 按行刷新 存储体采用双译码结构，刷新地址计数器给出刷新行地址 刷新方式 CPU与刷新控制器对DRAM的争用问题 集中式、分散式、异步式 ","date":"2024-03-31","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%863/:2:10","tags":["计算机组成原理"],"title":"计算机组成(第三章)","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%863/"},{"categories":["计算机组成原理"],"content":"集中刷新方式 最大刷新周期：2ms 在数据丢失之前集中刷新所有行 存在死区，用在实时要求不高的场合 ","date":"2024-03-31","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%863/:2:11","tags":["计算机组成原理"],"title":"计算机组成(第三章)","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%863/"},{"categories":["计算机组成原理"],"content":"分散刷新方式 最大刷新周期：2ms 存储周期：读写+刷新 各刷新周期分散安排在存取周期中 刷新次数 2ms/100ns=20000次 较浪费，用在低速系统中 ","date":"2024-03-31","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%863/:2:12","tags":["计算机组成原理"],"title":"计算机组成(第三章)","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%863/"},{"categories":["计算机组成原理"],"content":"异步刷新方式 刷新周期：2ms，各刷新周期分散安排在2ms内 每隔2ms/128=15.5微秒刷新一行,将128次刷新分散 最常用 说明1M×1位(＝512×2048) DRAM芯片的刷新方法，刷新周期定为8ms 逐行进行刷新 512行，每行2048个存储元同时进行刷新，整个芯片在8ms内进行512次刷新操作 集中刷新 在8ms中某个时间段，连续进行512次刷新操作 “死时间”：t0=512 T (T为存储器读写周期） 异步刷新 8ms分成512个时间段，每隔8ms÷512＝15.625µs 对芯片刷新一次(一行)，消除长时间的“死时间” 无论是由刷新控制逻辑产生地址循环码逐行循环刷新，还是芯片内部自动刷新，都不依赖于外部访问，对CPU透明。 刷新通常为按行刷新，仅需要行地址 所有芯片同时被刷新，故考虑刷新问题时，应当从单个芯片存储容量着手。 ","date":"2024-03-31","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%863/:2:13","tags":["计算机组成原理"],"title":"计算机组成(第三章)","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%863/"},{"categories":["计算机组成原理"],"content":"存储器控制电路 DRAM存储器的刷新需要有硬件电路的支持，包括刷新计数器、刷新/访存裁决、刷新控制逻辑等。这些控制线路形成DRAM控制器。 ","date":"2024-03-31","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%863/:2:14","tags":["计算机组成原理"],"title":"计算机组成(第三章)","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%863/"},{"categories":["计算机组成原理"],"content":"高性能的主存储器 EDRAM芯片 EDRAM芯片又称增强型DRAM芯片，它在DRAM芯片上集成了一个SRAM实现的小容量高速缓冲存储器，从而使DRAM芯片的性能得到显著改进 EDRAM内存条 一片EDRAM的容量为1M×4位，8片这样的芯片(位扩展）可组成1M×32位的存储模块。 当某模块被选中，此模块的8个EDRAM芯片同时动作，8个4位数据端口D3—D0同时与32位数据总线交换数据，完成一次32位字的存取 FPM-DRAM 快速页模式动态存储器 程序访问局部性原理：根据计算机中对大量典型程序运行情况的分析结果，当前要立即执行的程序和数据往往局限在一个小的范围内，也即是说，在一个较短的时间间隔内，CPU对局部范围的存储器进行频繁访问，而对此外的地址很少访问。这种现象称为程序访问的局部性 分页技术：保持行地址不变，只改变列地址，对同一行的所有内存单元进行访问。 CDRAM 带高速缓冲存储器 SDRAM 同步性动态存储器 猝发式访问：在对同一行的连续单元进行访问时，减少额外的延迟和等待周期 SDRAM支持与系统同步的连续单元猝发式访问 ","date":"2024-03-31","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%863/:2:15","tags":["计算机组成原理"],"title":"计算机组成(第三章)","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%863/"},{"categories":["计算机组成原理"],"content":"存储器与CPU连接 CPU对存储器进行读/写操作，首先由地址总线给出地址信号，然后要对存储器发出读操作或写操作的控制信号，最后在数据总线上进行信息交流。所以，存储器与CPU之间，要完成: 地址线的连接； 数据线的连接； 控制线的连接。 存储器芯片的容量是有限的,为了满足实际存储器的容量要求，需要对存储器进行扩展。 ","date":"2024-03-31","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%863/:2:16","tags":["计算机组成原理"],"title":"计算机组成(第三章)","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%863/"},{"categories":["计算机组成原理"],"content":"用静态MOS存储片组成RAM 位扩展法：(数据总线扩展) 每一芯片的数据线分别接到数据总线的相应位。各芯片并行工作。例如：用8Ｋ×１的RAM存储芯片，组成8K×8位的存储器，按8位＝m×1的关系来确定位扩展所需要的芯片数。共需8片 字扩展法：(地址总线扩展) 字扩展：字向扩展而位数不变，将芯片的地址线、数据线、读写控制线并联，而由片选信号来区分各片地址。同一时刻仅一芯片工作。 例如：用16k×8位的芯片采用字扩展法组成64k×8位的存储器：4个芯片。 地址分配：地址总线低位地址A0－A13与各芯片的14位地址端相连，而高两位的地址A14、A15经2：4译码器和4个芯片的片选端CE相连 字位同时扩展法： 一个存储器的容量假定为M×N位，若使用l×k位的芯片（l＜M, k＜N）需要在字向和位向同时进行扩展。此时共需要（M／l）×（N／k）个存储器芯片。 其中，M／l表示把M×N的空间分成（M／l）个部分（称为页或区），每页（N／k）个芯片。 地址分配： 用$log_2^ l$位表示低位地址：用来选择访问页内的l个字 用$log_2^{（M／l）}$位表示高位地址：用来经片选译码器产生片选信号。 ","date":"2024-03-31","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%863/:2:17","tags":["计算机组成原理"],"title":"计算机组成(第三章)","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%863/"},{"categories":["计算机组成原理"],"content":"ROM 的分类 只读存储器简称ROM，它只能读出，不能写入。它的最大优点是具有不易失性。根据编程方式的不同，ROM通常分为三类： ","date":"2024-03-31","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%863/:3:0","tags":["计算机组成原理"],"title":"计算机组成(第三章)","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%863/"},{"categories":["计算机组成原理"],"content":"ROM芯片的类型 MROM（掩膜ROM） 掩膜工艺直接制作 PROM（一次性编程ROM） 允许用户进行一次性编程 EPROM（可擦除可编程ROM） 紫外光擦除、并可重复编程的ROM EEPROM（电擦除可编程ROM） 擦除和编程（擦写）通过加电进行 Flash Memory（闪速存储器） 新型的电擦除可编程ROM 快速擦除整片或数据块 ","date":"2024-03-31","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%863/:4:0","tags":["计算机组成原理"],"title":"计算机组成(第三章)","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%863/"},{"categories":["计算机组成原理"],"content":"半导体存储器对比 ","date":"2024-03-31","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%863/:5:0","tags":["计算机组成原理"],"title":"计算机组成(第三章)","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%863/"},{"categories":["计算机组成原理"],"content":"闪速存储器 什么是闪速存储器 闪速存储器是一种高密度、非易失性的读/写半导体存储器，它突破了传统的存储器体系，改善了现有存储器的特性。 在不加电时仍可长期保持信息 本质上属于EEPROM，存储速度快 易于擦除和重写，功耗很小 存放BIOS，升级方便，CIH病毒 NOR \u0026 NAND FLASH 闪速存储器是在EPROM功能基础上增加了芯片的电擦除和重新编程能力 编程操作：编程操作就是对闪存的写操作。 读取操作：从闪存读出数据。 擦除操作：将闪存全部变为1。 速度不配怎么办？ 由于CPU和主存储器在速度上不匹配，而且在一个CPU周期中可能需要用几个存储器字，这便限制了高速计算，为了使CPU不至因为等待存储器读写操作的完成而无事可做，可以采取一些加速CPU和存储器之间有效传输的特殊措施。 ","date":"2024-03-31","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%863/:6:0","tags":["计算机组成原理"],"title":"计算机组成(第三章)","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%863/"},{"categories":["计算机组成原理"],"content":"双端口存储器 同一个存储器具有两组相互独立的读写控制线路,提供了两个相互独立的端口，都可以对存储器中任何位置上的数据进行独立的存取操作 具有两组相互独立的读写控制线路 两组读写控制线路可以并行操作 端口地址不相同，无冲突，并行存取 端口地址相同，读写冲突，无法并行存取 ","date":"2024-03-31","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%863/:6:1","tags":["计算机组成原理"],"title":"计算机组成(第三章)","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%863/"},{"categories":["计算机组成原理"],"content":"多模块交叉存储器 每个模块各自以等同的方式与CPU传送信息。 连续地址分布在相邻的模块，对连续字的成块传送可以重叠进行实现流水线并行存取 存储器的模块化组织 一个由若干个模块组成的主存储器是线性编址的。 这些地址在各模块有两种安排方式：一种是顺序方式，一种是交叉方式。 顺序方式:某个模块进行存取时，其他模块不工作，某一模块出现故障时，其他模块可以照常工作，通过增添模块来扩充存储器容量比较方便。但各模块串行工作，存储器的带宽受到了限制。 交叉方式:地址码的低位字段经过译码选择不同的模块，而高位字段指向相应模块内的存储字。连续地址分布在相邻的不同模块内，同一个模块内的地址都是不连续的。对连续字的成块传送可实现多模块流水式并行存取，大大提高存储器的带宽。 **方案一：顺序方式 ** 主存地址被分成高n位和低m位，高位（n）表示模块号，低位（m位）表示块内地址； 在一个模块内，程序是从低位地址连续存放； 对连续单元存取，一般仅对一个模块操作 特点： 多模块串行工作 易扩充容量 故障局部性。 多模块顺序存储器（地址总线扩展，容量扩展） 一个地址寄存器 高位片选，多模块串行 扩充容量方便 性能无提升 方便故障隔离 **方案二：交叉方式 ** 主存地址被分成高n位和低m位，低位（m位）表示模块号，高位（n）表示块内地址； 各模块间采用多模块交叉编址； 对连续单元存取，则多个模块并行工作 特点： 多模块并行工作，速度快 不易扩展 故障全局性。 多模块交叉存储器 模块并行工作 CPU比存储器要快 能同时取出多条指令或者数据 可大大提高机器的运行速度及存储带宽 定量分析： 模块字长等于数据总线宽度； 设：模块存取一个字的存储周期为T，总线传送周期为τ，存储器交叉模块数为m，则 $T=m \\tau$（$m=T/ \\tau$称为交叉存取度） 表示每经过τ时间延迟后启动下一模块 交叉存储器连续读取m个字所需时间为$t1=T+(m-1) \\tau $ 而顺序存储器所需时间为t2=mT 显然t1\u003ct2，故交叉存储器带宽提高。 交叉编址顺序访问时可按流水方式存取 $nT = m\\tau$ m = T/ 交叉存取度连续读取n个字的时间 $t_1=T+(n-1) \\tau $,$t_1\u003ct_2$ $t_2=nT$ ","date":"2024-03-31","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%863/:6:2","tags":["计算机组成原理"],"title":"计算机组成(第三章)","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%863/"},{"categories":["计算机组成原理"],"content":"相联存储器 按内容寻址的存储器 把存储单元所存内容的某一部分作为检索项，去检索该存储器，并对存储器中与该检索项符合的存储单元内容进行读出或写入 ","date":"2024-03-31","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%863/:6:3","tags":["计算机组成原理"],"title":"计算机组成(第三章)","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%863/"},{"categories":["计算机组成原理"],"content":"Cache存储器 在相对容量较大而速度较慢的主存与高速处理器之间设置的少量但快速的存储器 主要目的：提高存储器速度 为追求高速，包括管理在内的全部功能由硬件实现 cache 术语 命中 hit: CPU访问数据在cache中（上层存储器） 缺失 miss: CPU访问数据不在cache中 块 block: cache与主存交换最小单位 行/槽 Line/Slot 标记、标志位、数据块容器 有效位、查找标记、脏标志位、置换标志、数据块副本 Cold Cache、Warm Cache 命中率 （ hit rate ） 主存访问中cache命中比例 缺失率 （miss rate） 1 – 命中率 命中访问时间: （hit time） 数据查找时间、cache访问时间、总线传输时间 缺失损失 （miss penalty） 主存块调入cache，数据传输到处理器的时间 远大于命中时间，所以一些相对较小的时间可忽略 cache关键技术 数据查找 Data Identification 地址映射 Address Mapping 替换策略 Placement Policy 写入策略 Write Policy ","date":"2024-03-31","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%863/:7:0","tags":["计算机组成原理"],"title":"计算机组成(第三章)","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%863/"},{"categories":["计算机组成原理"],"content":"Cache基本原理 CPU与cache之间的数据交换以字(字节)为单位 Cache与主存间的数据传送以数据块为单位 一个块(Block)由若干字组成 Cache的读操作 高速命中(Hit)：微处理器读取主存的内容已包含在Cache中，可以直接读取Cache，不用访问主存 高速失效(Miss)、缺失、未命中：微处理器读取主存的内容不在Cache中，需要访问主存读取一个数据块 Cache的工作原理 Cache以块为单位进行操作 当CPU发出访内操作请求后，首先由Cache控制器判断当前请求的字是否在Cache中，若在，叫命中，否则，不命中 若命中： 若是“读”请求，则直接对Cache读，与主存无关 若是“写”请求： Cache单元与主存单元同时写（Write through写） 只更新Cache单元并加标记，移出时修改主存（写回Copy back） 只写入主存，并在Cache中加标记，下次从MM读出，保证正确。 未命中时： 若是“读”请求，则从主存读出所需字送CPU，且把含该字的一块送Cache，称“装入通过”，若Cache已满，置换算法； 若是“写”请求，直接写入主存 Cache的命中率 命中率（Hit Rate）：高速命中的概率 cache/主存系统的平均访问时间$t_a$： $t_a=ht_c+(1-h)t_m$ $t_c$＝命中时的cache访问时间 $t_m$＝未命中时的主存访问时间 Cache的访问效率e 设$r=t_m/t_c$表示主存慢于cache的倍率 例： CPU执行一段程序时，cache完成存取的次数为1900次，主存完成存取的次数为100次，已知cache存取周期为50ns，主存存取周期为250ns，求cache/主存系统的效率和平均访问时间。 解： $h=N_c/(N_c+N_m)=1900/(1900+100)=0.95$ $r=t_m/t_c=250ns/50ns=5$ $e=1/(r+(1-r)h)=1/(5+(1-5)×0.95)=83.3%$ $t_a=t_c/e=50ns/0.833=60ns$ 或者，$t_a=h·t_c+(1-h)·t_m=60ns$ Cache结构 Cache的数据块称为行（线Line，槽Slot） 用$L_i$表示，其中i=0,1,…,m-1，共有m=$2^r$行 主存的数据块称为块（Block） 用$B_j$表示，其中j=0,1,…,n-1，共有n=$2^s$块 行与块是等长的，包含$k=2^w$个主存字 字是CPU每次访问存储器时可存取的最小单位 Cache由数据存储器和标签存储器组成 数据存储器：高速缓存主存数据 标签存储器：保存数据所在主存的地址信息 ","date":"2024-03-31","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%863/:7:1","tags":["计算机组成原理"],"title":"计算机组成(第三章)","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%863/"},{"categories":["计算机组成原理"],"content":"主存与Cache的地址映射 Cache通过地址映射(mapping)的方法确定主存块与Cache行之间的对应关系，确定一个主存块应该存放到哪个Cache行中 全相联映射(fully associative mapping) 可以将一个主存块存储到任意一个Cache行 直接映射(direct mapping) 将一个主存块存储到唯一的一个Cache行 组相联映射(set associative mapping) 可以将一个主存块存储到唯一的一个Cache组中任意一个行 注：直接映射、2/4/8路组相联映射使用较多 全相联映射 全相联应用场合 块映射灵活，一对多映射 cache全部装满后才会出现块冲突 块冲突的概率低，cache利用率高 淘汰算法复杂 命中率高 直接相联映射 cache容量 = 行大小 × 行数 =（标志位+标记位+数据块+置换标记） × 行数 标记位=区地址 标志位（有效标志位，脏数据位） 无相联存储器，一个比较器 直接相联应用场合 块映射速度快，一对一映射，无须查表 利用索引字段直接对比相应标记位即可 查找表可以和副本一起存放，无需相联存储器 cache容易冲突，cache利用率低 淘汰算法简单 命中率低，适合大容量cache 组相联映射 组相联应用场合 容量小的cache可采用全相联映射或组相联映射 Pentium CPU L1 L2 cache 容量大的可采用直接映射方式 查找速度快，命中率相对低 但cache容量大可提高命中率 块设备缓存 不同映射方式主存地址划分 ","date":"2024-03-31","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%863/:7:2","tags":["计算机组成原理"],"title":"计算机组成(第三章)","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%863/"},{"categories":["计算机组成原理"],"content":"替换策略 替换问题 新主存块要进入Cache，决定替换哪个原主存块 直接映射，只能替换唯一的一个Cache行 全相联和组相联，需要选择替换策略（算法） 最不常用(LFU: least-frequently used) 替换使用次数最少的块 最近最少使用法(LRU: least-recently used) 本指替换近期最少使用的块，实际实现的是替换最久没有被使用的块 随机法(random) 随意选择被替换的块，不依赖以前的使用情况 LRU替换算法 LRU能较好地反映程序的局部性，因而其命中率较高，但实现的硬件较复杂 2路组相联：使用一个U位。某个Cache块被访问，该块U位置1；对应块U位置0。替换U位为0的块 4/8路组相联：运用堆栈型算法。最近访问的块放上面，最下面存放最久没有访问的块。替换最下面的块 ","date":"2024-03-31","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%863/:7:3","tags":["计算机组成原理"],"title":"计算机组成(第三章)","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%863/"},{"categories":["计算机组成原理"],"content":"写入策略 处理器对Cache读占大多数，也容易提高速度 写入Cache有些问题： 确认命中，才可以对Cache块写入 写入的数据字数不定 写入后可能导致与主存内容不一致 写入策略解决主存内容的更新问题，保持正确 直写法(write through)＝全写法 写入Cache的同时也写入主存（下一级存储器） 回写法(write back)＝写回法 只写入Cache，在被替换时才写回主存 直写和回写的比较 直写策略 优点：简单可靠 缺点：总线操作频繁、影响工作速度 解决方法：在Cache与主存间设置一级/多级缓冲器，形成实用的“缓冲直写”方式，提高速度 回写策略 优点：可以减少写入主存次数、提高速度 缺点：硬件结构比较复杂 实现方法：为了表明Cache是否被修改，需要设置一个更新位（update，污染位dirty bit）。替换时只需将被修改的Cache块内容写入主存 写未命中的处理方法 写访问并不需要Cache块中所有数据。写未命中时，写入的数据是否还要将其读回Cache呢？ 写分配法( write allocate，WTWA ) 先把数据所在的块调入Cache，然后再进行写入。类似读失效的方式，也称fetch on write 不写分配法( no-write allocate，WTNWA ) 直接把数据写入下一级存储器，不将相应的块调入Cache，也称write around 直写策略通常配合不写分配法，回写策略一般采用写分配法 Cache一致性 有了Cache，同一个数据会在主存也会在Cache 有了多级Cache，在主存、一级、二级或三级Cache中可能存在同一个数据的多个拷贝 多处理器系统存在有多个Cache，同一个数据的拷贝份数会更多 如何保证它们都相同，或者说如何保证程序获得最新的正确的数据，就是Cache数据的一致性问题 实现Cache一致性的基本方案 软件方法：由编译程序和操作系统在编译时分析代码，避免共享变量进入Cache 硬件方法：程序运行时动态处理，对程序员和编译员透明，称为Cache一致性协议(Cache coherence protocol) 目录(directory)：物理主存中共享数据的状态及相关信息保存在目录中，通常由中央控制器集中维护 监听(snoopy)：各个Cache除保存数据拷贝外，也保存数据的共享状态信息，通过监听总线操作判断 ","date":"2024-03-31","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%863/:7:4","tags":["计算机组成原理"],"title":"计算机组成(第三章)","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%863/"},{"categories":["计算机组成原理"],"content":"虚拟存储器 虚拟存储器： 在主存-外存层次间 借助于磁盘辅助存储器实现 由系统软件和辅助硬件管理 以透明方式提供给用户 一个比实际主存空间大得多的程序地址空间 作用：扩大主存容量，提高辅存访问速度，有效管理存储系统 虚拟：利用其他部件实现的本来不存在的事物或属性 透明：本来存在的事物或属性，从某种角度看似乎不存在 ","date":"2024-03-31","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%863/:8:0","tags":["计算机组成原理"],"title":"计算机组成(第三章)","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%863/"},{"categories":["计算机组成原理"],"content":"虚拟存储器的基本概念 物理地址（实地址）：（对应主存物理空间）由CPU地址引脚送出，用于访问主存的地址 虚拟地址（虚地址）：（对应主存逻辑空间）由编译程序生成的，是程序的逻辑地址 CPU理解虚拟地址，并将其转换成物理地址 Cache与虚存的异同（P101） 主存-外存层次的基本信息传送单位 段：按程序逻辑划分为可变长的块，称为段 页：机械地划分为大小相同的块，称为页面 段页：程序按模块分段，段内分页 ","date":"2024-03-31","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%863/:8:1","tags":["计算机组成原理"],"title":"计算机组成(第三章)","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%863/"},{"categories":["计算机组成原理"],"content":"虚拟存储器的管理 段式管理：把主存按段分配的存储管理方式 优点：段的界线分明，段易于编译、管理、修改和保护，便于多道程序共享 缺点：段的长度各不相同，主存空间分配麻烦 页式管理：以定长页面进行存储管理的方式 优点：页的起点和终点地址固定,方便造页表,新页调入主存也很容易掌握，比段式空间浪费小 缺点：处理、保护和共享都不及段式来得方便 段页式管理：分段和分页相结合的存储管理方式 优点：综合段式和页式管理方式的特点 缺点：需要多次查表过程 ","date":"2024-03-31","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%863/:8:2","tags":["计算机组成原理"],"title":"计算机组成(第三章)","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%863/"},{"categories":["计算机组成原理"],"content":"页式虚拟存储器 逻辑页：页式虚拟存储系统中，虚拟空间分成页 物理页：主存空间也分成同样大小的页 虚存地址分为两个字段：高字段为逻辑页号，低字段为页内行地址。 实存地址也分两个字段：高字段为物理页号，低字段为页内行地址. 页式管理的地址变换：用页表 快表与慢表 ","date":"2024-03-31","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%863/:8:3","tags":["计算机组成原理"],"title":"计算机组成(第三章)","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%863/"},{"categories":["计算机组成原理"],"content":"段式虚拟存储器 段式管理的地址变换：用段表 ","date":"2024-03-31","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%863/:8:4","tags":["计算机组成原理"],"title":"计算机组成(第三章)","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%863/"},{"categories":["计算机组成原理"],"content":"段页式虚拟存储器 ","date":"2024-03-31","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%863/:8:5","tags":["计算机组成原理"],"title":"计算机组成(第三章)","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%863/"},{"categories":["计算机组成原理"],"content":"替换算法 虚拟存储器的页面替换策略和cache的行替换策略有很多相似之处，但有三点显著不同： 缺页至少要涉及一次磁盘存取，使系统蒙受的损失要比cache未命中大得多 页面替换由操作系统软件实现 页面替换的选择余地很大，属于一个进程的页面都可替换 虚拟存储器的替换策略 多采用近期最少使用(LRU)算法 还有最不经常使用(LFU)算法 先进先出(FIFO)算法 奔腾处理器的存储器地址转换 ","date":"2024-03-31","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%863/:8:6","tags":["计算机组成原理"],"title":"计算机组成(第三章)","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%863/"},{"categories":["计算机组成原理"],"content":"存储保护 多个程序同时存在于存储器中，需要保护 **存储区域保护： ** 界限保护 页表和段表保护 键式保护 环状保护 访问方式保护： 设置访问权限：读R、写W、执行E的组合 特权保护 奔腾处理器的段描述符 段界限(segment limit)：用于存储空间保护 基地址(base address)：用于形成物理地址 访问权字节(access rights byte)：段访问权限：该段当前是否驻留主存、该段所具有特权层和段类型，用于特权保护 奔腾处理器的页目录项和页表项 P存在位：该页表或页面是否在物理存储器中 A访问位：页面进行读或写操作时置位 D写操作位（dirty脏位）：页面进行写操作时被置位 U/S用户/管理员位：页面仅能由管理员层的程序使用，还是用户层和管理员层的程序均能使用 R/W读/写位：指明页面是只读的，还是可读可写 ","date":"2024-03-31","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%863/:9:0","tags":["计算机组成原理"],"title":"计算机组成(第三章)","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%863/"},{"categories":["操作系统"],"content":"处理机调度与死锁 调度算法和银行家算法 ","date":"2024-03-26","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F3/:0:0","tags":["操作系统"],"title":"操作系统(第三章)","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F3/"},{"categories":["操作系统"],"content":"处理机调度的层次和调度算法的目标 ","date":"2024-03-26","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F3/:1:0","tags":["操作系统"],"title":"操作系统(第三章)","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F3/"},{"categories":["操作系统"],"content":"处理机调度的层次 高级调度(又称：作业，长程，接纳调度) 高级调度又称长程调度。调度对象是作业 低级调度 低级调度又称为进程调度或短程调度 中级调度 中级调度又称为内存调度，主要目的是：提高内存利用率和系统吞吐量。为此，应把那些暂时不能运行的进程，调值外存等待，此时进程的状态称为就绪驻外存状态(或挂起状态) ","date":"2024-03-26","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F3/:1:1","tags":["操作系统"],"title":"操作系统(第三章)","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F3/"},{"categories":["操作系统"],"content":"进程调度 执行完，1个时间片以后的进程 新创建的进程 阻塞被唤醒进程 分类：非抢占和抢占 ","date":"2024-03-26","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F3/:1:2","tags":["操作系统"],"title":"操作系统(第三章)","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F3/"},{"categories":["操作系统"],"content":"处理机调度算法的目标 $T_i=完成时间-到达时间$ $T= \\frac{1}{n} \\underset{i=1}{\\stackrel{n} \\sum }T_i$ $W_i= \\frac{T_i}{T_s}$ $W= \\frac{1}{n} \\underset{i=1}{\\stackrel{n} \\sum }W_i$ 注：T为平均周转时间，$T_i$为周转时间，$T_s$为执行时间，W为平均带权周转时间，$W_i$为带权周转时间 ","date":"2024-03-26","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F3/:1:3","tags":["操作系统"],"title":"操作系统(第三章)","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F3/"},{"categories":["操作系统"],"content":"作业与作业调度 ","date":"2024-03-26","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F3/:2:0","tags":["操作系统"],"title":"操作系统(第三章)","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F3/"},{"categories":["操作系统"],"content":"先来先服务(FCFS) 优点：简单，有利于长进程(作业)调度 缺点：不利于短进程(作业)调度 ","date":"2024-03-26","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F3/:2:1","tags":["操作系统"],"title":"操作系统(第三章)","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F3/"},{"categories":["操作系统"],"content":"SJ(P)F短作业优先调度算法 策略 根据进程(作业)执行时间越短越先调度执行 到达时间 分类 非抢占式 抢占式 优点：有利于短进程(作业)的调度 缺点：不利于长进程(作业)的调度 ","date":"2024-03-26","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F3/:2:2","tags":["操作系统"],"title":"操作系统(第三章)","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F3/"},{"categories":["操作系统"],"content":"优先权调度 策略 ：根据进程优先数的大小来调度执行 分类 中断：非抢占式和抢占式 变化 静态：不变 V 动态：响应比，$R_p = \\frac{t_w+t_s}{t_s}$ $t_w$为等待时间 ","date":"2024-03-26","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F3/:2:3","tags":["操作系统"],"title":"操作系统(第三章)","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F3/"},{"categories":["操作系统"],"content":"时间片轮转(RR) 基本时间片(抢占式) 时间片(系统)：时钟信号，10~100ms 太大：退化成先来先服务(FCFS)调度 太小：系统开销过大 时间片大小 为1 \u003e1 同一时刻：2-1-3 先写就绪队列，R=1(写到最后一个进程加入) 再画图 例题： 考虑5个进程P1,P2,P3,P4,P5,见表1.规定进程的优先度越小,优先级越高.试描述在采用下述几种调度算法时各个进程的运行过程.并计算采用每种算法时的进程平均周转时间.假设忽略进程的调度时间. 先来先服务调度算法 时间片轮转调度算法(时间片为1ms) 时间片轮转调度算法(时间片为2ms) 非剥夺式SJF调度算法 剥夺式优先级调度算法 解： ","date":"2024-03-26","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F3/:2:4","tags":["操作系统"],"title":"操作系统(第三章)","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F3/"},{"categories":["操作系统"],"content":"最早截至时间优先(EDF) 策略： 根据截止时间的早晚确定调度顺序 越早就越先执行 到达时间 已知： 到达顺序：$p_1 \\rightarrow p_2 \\rightarrow p_3 \\rightarrow p_4$ 截止时间：$p_1 \\rightarrow p_3 \\rightarrow p_4 \\rightarrow p_2$ 则调度顺序：$p_1 \\rightarrow p_3 \\rightarrow p_4 \\rightarrow p_2$ 注：抢占与非抢占的执行顺序一样 ","date":"2024-03-26","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F3/:2:5","tags":["操作系统"],"title":"操作系统(第三章)","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F3/"},{"categories":["操作系统"],"content":"最低松弛度优先(LLF) 若A进程需在200ms时完成，其本身运行需要100ms，当前时刻是10ms，则A的松弛度为：200－100－10＝90 主要用于可抢占的调度方式中 ","date":"2024-03-26","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F3/:2:6","tags":["操作系统"],"title":"操作系统(第三章)","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F3/"},{"categories":["操作系统"],"content":"死锁 定义 因为某些原因使进程不能执行，系统进入一种僵局定义为死锁 产生的原因 竞争资源 可剥夺性：共享(不会发生) 非剥夺性：互斥(可能会) 临时性：(可能会) 进程推进的顺序不当 例：两个进程：$p_1/p_2$；资源两个$R_1/R_2$ 两个操作：Req()[申请资源]，Rel()[释放资源] 则：1，2，3不会发生死锁；4会产生死锁 ","date":"2024-03-26","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F3/:3:0","tags":["操作系统"],"title":"操作系统(第三章)","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F3/"},{"categories":["操作系统"],"content":"避免死锁 方法： 判断系统的状态 安全(不会发生死锁) 不安全(有可能会发生死锁) 再资源分配(银行家算法) ","date":"2024-03-26","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F3/:3:1","tags":["操作系统"],"title":"操作系统(第三章)","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F3/"},{"categories":["操作系统"],"content":"补充(银行家算法) 引入4个资源分配相关的变量 Max:最大资源数 Allocation:已分配的资源数 Needi:还需要的资源数 Available:当前系统的可用资源数 **关系：**Max=Allocation+Needi Needi与Available比较： $\\leq$ 可执行 $\u003e$:阻塞等待 安全状态 找出进程推进顺序$\\Rightarrow$安全序列(不是唯一的)$\\Rightarrow$系统安全$\\Rightarrow$不会发生死锁 例： Available=12-(5+2+2)=3 Needi: p1=10-5=5 p2=4-2=2 p3=9-2=7 则安全序列：$p2 \\rightarrow p1 \\rightarrow p3$ 以p2为例： 3(执行之前的Available)+2(Allocation)=5(执行之后的) 不安全状态 一个安全序列都没有(可能进入死锁) 申请资源： 发出请求向量Request:$\\Rightarrow$银行家算法 增加了3个变量： 请求向量Request(已知) 可用资源数:work\u003c-\u003eAvailable 布尔变量:Finish 算法步骤 两次比较 预分配(修改3个变量) 安全性检测 安全：可以分配 不安全：不分配，恢复变量 ","date":"2024-03-26","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F3/:3:2","tags":["操作系统"],"title":"操作系统(第三章)","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F3/"},{"categories":["计算机算法设计与分析"],"content":"动态规划 ","date":"2024-03-25","objectID":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A13/:0:0","tags":["计算机算法设计与分析"],"title":"算法与程序(第三章)","uri":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A13/"},{"categories":["计算机算法设计与分析"],"content":"算法总体思想 如果能够保存已解决的子问题答案，而在需要时再找出以求得的答案，就可以避免大量重复计算，从而得到多项式时间算法 ","date":"2024-03-25","objectID":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A13/:1:0","tags":["计算机算法设计与分析"],"title":"算法与程序(第三章)","uri":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A13/"},{"categories":["计算机算法设计与分析"],"content":"矩阵连乘问题 单个矩阵是完全加括号的 矩阵连乘A是完全加括号的，则A可以表示为两个完全加括号的矩阵连乘积B和C的乘积并加括号，即A=(BC) 首先考虑计算两个矩阵乘积所需的计算量。计算两个矩阵乘积的标准算法如下，其中，ra、ca 和 rb、cb 分别表示矩阵 A 和 B 的行数和列数。 void matrixMultiply(int **a, int **b, int **c, int ra, int ca, int rb, int cb) { if (ca != rb) error(\"矩阵不可乘\"); for (int i=0; i \u003c ra; i++) { for (int j=0; j \u003c cb; j++) { int sum = a[i][0]*b[0][j]; for (int k=1; k \u003c ca; k++) sum += a[i][k]*b[k][j]; c[i][j] = sum; } } } 对于n个矩阵的连乘积，设有不同的计算次序P(n)。因每种加括号方式都可以分解为两个子矩阵的加括号问题:($A_1 \\cdots A_k$)($A_k+1 \\cdots A_0$ )，故P(n)的逆推式如下 ","date":"2024-03-25","objectID":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A13/:2:0","tags":["计算机算法设计与分析"],"title":"算法与程序(第三章)","uri":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A13/"},{"categories":["计算机算法设计与分析"],"content":"分析最优解的结构 将矩阵连乘积 AiAi+1…Aj简记为 A[i:j] ($i\\leq j$)。考察计算 A[1:n]的最优计算次序。设这个计算次序在矩阵 Ak（1≤k\u003cn）和 Ak+1 之间将矩阵链断开($i \\leq k \\leq j$)，则其相应的完全加括号方式为((A1…Ak)(Ak+1…An))。 特征 计算 A[1:n]的最优次序包含的计算矩阵子链 A[k+1:n]的次序也是最优的。矩阵连乘积计算次序问题的最优解包含着其子问题的最优解。这种性质称为最优 子结构性质。问题的最优子结构性质是该问题可用动态规划算法求解的显著特征。 m[i,j]表示A[i:j]的计算量为m[k+1,j]因此：m[i,j]=m[i,k]+m[k+1,j]+$p_{i-1}p_kp_j$ 用反证法可证明，m[i,j]是最优值，则m[i,k]，m[k+1,j]一定也是最优值 这里$A_i$的维数为P_{i-1}根$p_i$ ","date":"2024-03-25","objectID":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A13/:2:1","tags":["计算机算法设计与分析"],"title":"算法与程序(第三章)","uri":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A13/"},{"categories":["计算机算法设计与分析"],"content":"建立递归关系 设计算 A[i:j]（1≤i≤j≤n），所需的最少数乘次数为 m[i][j]，则原问题的最优值为 m[1][n] 当 i=j 时，A[i:j]=$A_i$为单一矩阵，无须计算，因此 m[i][i]=0（i=1, 2, …, n）。 当 i\u003cj 时，可利用最优子结构性质来计算 m[i][j]。事实上，若计算 A[i:j]的最优次序在 $A_k$（i≤k\u003cj）和 $A_{k+1}$ 之间断开，则 m[i][j]=m[i][k]+m[k+1][j]+$p_{i−1}p_kp_j$(注：这里A的维数为$p_{i-1} \\times p$) 从而，m[i][j]可以递归地定义为: ","date":"2024-03-25","objectID":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A13/:2:2","tags":["计算机算法设计与分析"],"title":"算法与程序(第三章)","uri":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A13/"},{"categories":["计算机算法设计与分析"],"content":"计算最优值 用动态规划算法解此问题，可依据其递归式以自底向上的方式进行计算。在计算过程中， 保存已解决的子问题答案。每个子问题只计算一次，而在后面需要时只要简单查一下，从而 避免大量的重复计算，最终得到多项式时间的算法。 void MatrixChain(int *p, int n, int **m, int **s) { for (int i=1; i \u003c= n; i++) m[i][i]=0; for (int r=2; r \u003c= n; r++) { for (int i=1; i \u003c= n−r+1; i++) { int j = i+r−1; m[i][j] = m[i+1][j] + p[i−1]*p[i]*p[j]; s[i][j] = i; for (int k=i+1; k \u003c j; k++) { int t = m[i][k]+m[k+1][j] + p[i−1]*p[k]*p[j]; if (t\u003cm[i][j]) { m[i][j] = t; s[i][j] = k; } } } } } ","date":"2024-03-25","objectID":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A13/:2:3","tags":["计算机算法设计与分析"],"title":"算法与程序(第三章)","uri":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A13/"},{"categories":["计算机算法设计与分析"],"content":"构造最优解 动态规划算法的第 4 步是构造问题的最优解。算法 MatrixChain 只是计算出了最优值， 并未给出最优解。也就是说，通过 MatrixChain 的计算，只知道最少数乘次数，还不知道具 体应按什么次序来做矩阵乘法才能达到最少的数乘次数。 事实上，MatrixChain 已记录了构造最优解所需的全部信息。 下面的算法 Traceback 按算法 MatrixChain 计算出的断点矩阵 s 指示的加括号方式输出计 算 A[i:j]的最优计算次序。 void Traceback(int i, int j, int **s) { if (i == j) return; Traceback(i, s[i][j], s); Traceback(s[i][j]+1, j,s); cout\u003c\u003c\"Multiply A \"\u003c\u003ci\u003c\u003c\", \" \u003c\u003cs[i][j]; cout\u003c\u003c\" and A \"\u003c\u003c(s[i][j]+1)\u003c\u003c\", \"\u003c\u003cj\u003c\u003cendl; } ","date":"2024-03-25","objectID":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A13/:2:4","tags":["计算机算法设计与分析"],"title":"算法与程序(第三章)","uri":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A13/"},{"categories":["计算机算法设计与分析"],"content":"动态规划的基本要素 适用条件 最优化原理 无后效性(无后向性) 子问题的重叠性 ","date":"2024-03-25","objectID":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A13/:3:0","tags":["计算机算法设计与分析"],"title":"算法与程序(第三章)","uri":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A13/"},{"categories":["计算机算法设计与分析"],"content":"最优子结构 设计动态规划算法的第一步通常是要刻画最优解的结构。当问题的最优解包含了其子问 题的最优解时，称该问题具有最优子结构性质。 在动态规划算法中，利用问题的最优子结构性质，以自底向上的方式递归地从子问题的 最优解逐步构造出整个问题的最优解。 ","date":"2024-03-25","objectID":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A13/:3:1","tags":["计算机算法设计与分析"],"title":"算法与程序(第三章)","uri":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A13/"},{"categories":["计算机算法设计与分析"],"content":"重叠子问题 可用动态规划算法求解的问题应具备的另一基本要素是子问题的重叠性质。 动态规划算法正是利用了这种子问题的重叠性质，对每个子问题只解一次，然后将其解保存在一个表格中，当再次需要解此子问题时，只是简单地用常数时间查看一下结果。 为了说明这一点，考虑计算矩阵连乘积最优计算次序时，利用递归式直接计算 A[i:j]的 递归算法 RecurMatrixChain int RecurMatrixChain(int i, int j) { if (i == j) return 0; int u = RecurMatrixChain(i, i) + RecurMatrixChain(i+1, j) + p[i−1]*p[i]*p[j]; s[i][j] = i; for (int k=i+1; k\u003cj; k++) { int t = RecurMatrixChain(i, k) + RecurMatrixChain(k+1, j) + p[i−1]*p[k]*p[j]; if (t \u003c u) { u = t; s[i][j] = k; } } return u; } ","date":"2024-03-25","objectID":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A13/:3:2","tags":["计算机算法设计与分析"],"title":"算法与程序(第三章)","uri":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A13/"},{"categories":["计算机算法设计与分析"],"content":"备忘录方法 备忘录方法的控制结构与直接递归方法的控制结构相同 备忘录方法为每个解过的子问题建立了备忘录 求解一个子问题时先检查是否已有答案，避免重复求解 下面的算法 MemoizedMatrixChain 是解矩阵连乘积最优计算次序问题的备忘录方法。 int MemoizedMatrixChain(int n, int **m, int **s) { for (int i=1; i \u003c= n; i++) { for (int j=i; j \u003c= n; j++) m[i][j] = 0; return LookupChain(1, n); } } int LookupChain(int i, int j) { if (m[i][j] \u003e 0) return m[i][j]; if (i == j) return 0; int u = LookupChain(i, i) + LookupChain(i+1, j) + p[i−1]*p[i]*p[j]; s[i][j] = i; for (int k=i+1; k \u003c j; k++) { int t = LookupChain(i, k) + LookupChain(k+1, j) + p[i−1]*p[k]*p[j]; if (t \u003c u) { u = t; s[i][j] = k; } } m[i][j]=u; return u; } ","date":"2024-03-25","objectID":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A13/:3:3","tags":["计算机算法设计与分析"],"title":"算法与程序(第三章)","uri":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A13/"},{"categories":["计算机算法设计与分析"],"content":"数字塔问题 数塔问题原型 问题描述 7 3 8 8 1 0 2 7 4 4 4 5 2 6 5 有一个r行的数塔，数塔上有若干数字。问从数塔的最高点到底部，在所有的路径中，经过的数字的和最大为多少？ 如上图，是一个5行的数塔，其中7—3—8—7—5的路径经过数字和最大，为30。 解法思路 面对数塔问题，使用贪心算法显然是行不通的，比如给的样例，如果使用贪心算法，那选择的路径应当是7—8—1—7—5，其经过数字和只有28，并不是最大。而用深搜DFS很容易算出时间复杂度为 $O(2^n)$ (因为每个数字都有向左下和右下两种选择)，行数一多必定超时。 我们可以从上往下遍历。 可以发现，要想经过一个数字，只能从左上角或右上角的数字往下到达。 所以显然，经过任一数字A时，路径所经过的数字最大和——是这个数字A左上方的数字B以及右上方的数字C两个数字中，所能达到的数字最大和中较大的那一个，再加上该数字A。 故状态转移方程为： $dp[i][j] = max(dp[i-1][j],dp[i-1][j-1]+num[i][j])$ 其中i，j表示行数和列数，dp表示储存的最大和，num表示位置上的数字。 $dp[i-1][j]$表示左上角， $dp[i-1][j-1]$表示右上角。 以样例来说明：在经过第三行的数字1时，我们先看它左上角的数字3和右上角的数字8其能达到的最大和。3显然只有7—3一条路径，故最大和是10；8显然也只有7—8一条路径，其最大和是15；两者中较大的是15，故经过1所能达到的最大和是15+1=16。 这样一步步向下遍历，最后经过每一个位置所能达到的最大和都求出来了，只要从最底下的一行里寻找最大值并输出即可。 我们也可以从下往上遍历 一条路径不管是从上往下走还是从下往上走，其经过的数字和都是一样的，所以这题完全可以变成求——从最底层到最高点所经过的最大数字和。 其写法与顺序遍历是一样的，只是状态转移时，变成从该数字的左下角和右下角来取max了。逆序遍历的写法相比于顺序遍历优点在于：少了最后一步求最后一行max的过程，可以直接输出最高点所储存的值。 代码实现 #include \u003cstdio.h\u003e #include \u003calgorithm\u003e using namespace std;//这里以顺序遍历为例 int num[1005][1005];//用于储存数塔每个位置的数字 int dp[1005][1005];//用于储存经过数塔每个位置所能达到的最大和 int main() { int r; scanf(\"%d\",\u0026r);//输入数塔行数 for(int i=1;i\u003c=r;i++) for(int j=1;j\u003c=i;j++) scanf(\"%d\",\u0026num[i][j]); //输入数塔数据，注意i和j要从1开始，防止数组越界 for(int i=1;i\u003c=r;i++)//共计r行 for(int j=1;j\u003c=i;j++)//每行有j个数字 dp[i][j]=max(dp[i-1][j],dp[i-1][j-1])+num[i][j]; //经过该数字的最大和，为左上角和右上角中的max，再加上该数字 int ans=0; for(int i=1;i\u003c=r;i++) ans=max(ans,dp[r][i]);//从最后一行中找到最大数 printf(\"%d\\n\",ans);//就是答案 return 0; } ","date":"2024-03-25","objectID":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A13/:3:4","tags":["计算机算法设计与分析"],"title":"算法与程序(第三章)","uri":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A13/"},{"categories":["计算机算法设计与分析"],"content":"最长公共子序列 最长公共子序列的结构 设序列 $X={x_1, x_2, …, x_m}$和 $Y={y_1, y_2, …, y_n}$的最长公共子序列为 $Z={z_1, z_2, …, z_k}$，则 ① 若 $x_m=y_n$，则$ z_k=x_m=y_n$，且 $Z_{k−1} 是 X_{m−1}和 Y_{n−1}$的最长公共子序列。 ② 若$ x_m≠y_n$ 且 $z_k≠x_m$，则 Z 是 $X_{m−1}$和 Y 的最长公共子序列。 ③ 若 $x_m≠y_n $且 $z_k≠y_n$，则 Z 是 X 和$ Y_{n−1}$的最长公共子序列。 其中，$X_{m−1}={x_1, x_2, …, x_{m−1}}，Y_{n−1}={y_1, y_2, …, y{n−1}}，Z_{k−1}={z_1, z_2, …, z_{k−1}}$ 由此可见，两个序列的最长公共子序列包含了这两个序列的前缀的最长公共子序列。因 此，最长公共子序列问题具有最优子结构性质。 子问题的递归结构 用 c[i][j]记录序列 $X_i和 Y_j$的最长公共子序列的长度。 其中，$X_i={x_1, x_2, …, x_i}；Y_j={y_1, y_2, …, y_j}$。当 i=0 或 j=0 时，空序列是$ X_i和 Y_j$的最长公共子 序列。所以，此时 c[i][j]=0。其他情况下，由最优子结构性质可建立递归关系如下 计算最优值 在所考虑的子问题空间中，共有 θ(mn)个不同的子问题，因此，用动态规划算法自 底向上计算最优值能提高算法的效率。 void LCSLength(int m,int n,char *x,char *y, int **c, int **b) { int i, j; for(i=1; i \u003c= m; i++) c[i][0] = 0; for(i=1; i \u003c= n; i++) c[0][i] = 0; for(i=1; i \u003c= m; i++) { for(j=1; j \u003c= n; j++) { if (x[i] == y[j]) { c[i][j] = c[i−1][j−1]+1; b[i][j] = 1; } else if (c[i−1][j] \u003e= c[i][j−1]) { c[i][j] = c[i−1][j]; b[i][j] = 2; } else { c[i][j] = c[i][j−1]; b[i][j] = 3; } } } } 由于每个数组单元的计算耗费 O(1)时间，因此算法 LCSLength 耗时 O(mn)。 构造最长公共子序列 由算法 LCSLength 计算得到的数组 b 可用于快速构造序列 X={x1, x2, …, xm}和 Y={y1, y2, …, yn}的最长公共子序列。 void LCS(int i, int j, char *x, int**b) { if (i ==0 || j==0) return; if (b[i][j]== 1) { LCS(i−1, j−1, x, b); cout\u003c\u003cx[i]; } else if (b[i][j] == 2) LCS(i−1, j, x, b); else LCS(i, j−1, x, b); } 在算法 LCS 中，每次递归调用使 i 或 j 减 1，因此算法的计算时间为 O(m+n)。 ","date":"2024-03-25","objectID":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A13/:3:5","tags":["计算机算法设计与分析"],"title":"算法与程序(第三章)","uri":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A13/"},{"categories":["计算机算法设计与分析"],"content":"凸多边形最优三角剖分 3.5动态规划–凸多边形的最优三角剖分_凸多边形最优三角剖分动态规划-CSDN博客 ","date":"2024-03-25","objectID":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A13/:3:6","tags":["计算机算法设计与分析"],"title":"算法与程序(第三章)","uri":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A13/"},{"categories":["计算机算法设计与分析"],"content":"0-1 背包问题 递归关系 设所给 0-1 背包问题的子问题 的最优值为 m(i, j)，即 m(i, j)是背包容量为 j，可选择物品为 i, i+1, …, n 时 0-1 背包问题的最 优值。由 0-1 背包问题的最优子结构性质，可以建立计算 m(i, j)的递归式如下： 算法描述 基于以上讨论，当 wi（1≤i≤n）为正整数时，用二维数组 m[][]来存储 m(i, j)的相应值， 可设计解 0-1 背包问题的动态规划算法 Knapsack 如下： template＜class Type＞ void Knapsack(Type v, int w, int c, int n, Type** m) { int jMax = min(w[n]−1,c); for (int j=0; j \u003c= jMax; j++) m[n][j] = 0; for (int j=w[n]; j \u003c= c; j++) m[n][j] = v[n]; for (int i=n−1; i \u003e 1; i−−){ jMax=min(w[i]−1,c); for (int j=0; j \u003c= jMax; j++) m[i][j] = m[i+1][j]; for (int j=w[i] ; j \u003c= c; j++) m[i][j] = max(m[i+1][j], m[i+1][j−w[i]]+v[i]); } m[1][c]=m[2][c]; if (c \u003e= w[1]) m[1][c]=max(m[1][c], m[2][c−w[1]]+v[1]); } template＜class Type＞ void Traceback(Type **m, int w, int c, int n, int x) { for (int i=1; i \u003c n; i++) { if (m[i][c] == m[i+1][c]) x[i]=0; else { x[i] = 1; c −= w[i]; } x[n] = (m[n][c]) ? 1 : 0; } 计算复杂性分析 算法 Knapsack 需要 O(nc)计算时间，而 Traceback 需要 O(n)计算时间。 当背包容量 c 很大时，算法需要的计算时间较多。 ","date":"2024-03-25","objectID":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A13/:3:7","tags":["计算机算法设计与分析"],"title":"算法与程序(第三章)","uri":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A13/"},{"categories":["计算机算法设计与分析"],"content":"四柱汉诺塔问题 3-7四柱汉诺塔问题（动态规划）-CSDN博客 ","date":"2024-03-25","objectID":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A13/:3:8","tags":["计算机算法设计与分析"],"title":"算法与程序(第三章)","uri":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A13/"},{"categories":["面向对象程序设计"],"content":"类和对象 ","date":"2024-03-22","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A14/:0:0","tags":["面向对象程序设计"],"title":"c++(four)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A14/"},{"categories":["面向对象程序设计"],"content":"面向对象程序设计的基本特点 ","date":"2024-03-22","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A14/:1:0","tags":["面向对象程序设计"],"title":"c++(four)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A14/"},{"categories":["面向对象程序设计"],"content":"抽象 抽象是对具体对象（问题）进行概括，抽出这一类对象的公共性质并加以描述的过程。 先注意问题的本质及描述，其次是实现过程或细节 数据抽象：描述某类的属性或状态(对象相互区别的物理量) 代码抽象：描述某类对象的共有的行为特征或具有的功能 抽象的实现：通过类的声明 实例(钟表) 数据抽象 需要三个整数来存储时间，分别表示时、分和秒，这就是对时钟所具有的数据进行抽象。 int Hour,int Minute,int Second 代码抽象 时钟要具有显示时间、设置时间等简单的功能,这就是对它的行为的抽象。 SetTime(),ShowTime() 抽象实例 class Clock{ public: void SetTime(int NewH,int NewM,int NewS); void ShowTime(); private: int Hour,Minute,Second; }; 抽象实例(人) 数据抽象： char *name,char *sex,int age,int id(或：string name,string sex,int age,int id) 代码抽象 生物属性角度： GetCloth(),Eat(),Step(),.. 社会属性角度： Work(),Promote(),... ","date":"2024-03-22","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A14/:1:1","tags":["面向对象程序设计"],"title":"c++(four)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A14/"},{"categories":["面向对象程序设计"],"content":"封装 封装就是将抽象得到的数据和行为（或功能）相结合，形成一个有机的整体。也就是将数据与操作数据的函数代码进行有机地结合，形成“类”，其中的数据和函数都是类的成员。 目的是增强安全性和简化编程，使用者不必了解具体的实现细节，而只需要通过外部接口，以特定的访问权限，来使用类的成员。 实现封装：类声明中的{} 实例： class Clock{ public: void SetTime(int NewH,int NewM,int NewS); void ShowTime(); //SetTime()，ShowTime()为外部接口 private: int Hour,Minute,Second; //public,private为特定访问权限 }; //{}：边界 ","date":"2024-03-22","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A14/:1:2","tags":["面向对象程序设计"],"title":"c++(four)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A14/"},{"categories":["面向对象程序设计"],"content":"继承 C++语言中提供了类的继承机制，允许程序员在保持原有类特性的基础上，进行更具体、更详细的说明 是C++中支持层次分类的一种机制，允许程序员在保持原有类特性的基础上，进行更具体的说明。 实现：声明派生类——第七章 ","date":"2024-03-22","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A14/:1:3","tags":["面向对象程序设计"],"title":"c++(four)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A14/"},{"categories":["面向对象程序设计"],"content":"多态性 多态：同一名称，不同的功能实现方式 多态性是指一段程序能够处理多种类型对象的能力。 目的：达到行为标识统一，减少程序中标识符的个数 实现：在C++中语言中，这种多态性可以通过强制多态、重载多态、类型参数化多态（模板）、包含多态(虚函数）4种形式来实现。 ","date":"2024-03-22","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A14/:1:4","tags":["面向对象程序设计"],"title":"c++(four)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A14/"},{"categories":["面向对象程序设计"],"content":"类和对象(c++中的类) 类是具有相同属性和行为的一组对象的集合，它为属于该类的全部对象提供了统一的抽象描述，其内部包括属性和行为两个主要部分。 利用类可以实现数据的封装、隐藏、继承与派生 利用类易于编写大型复杂程序，其模块化程度比C中采用函数更高。 类实际上相当于一种用户自定义的类型，它和前面学习过的基本类型，如整型、实型，有类似的特征。同样，也可以声明某个类类型的变量，这个变量就称为类的对象（或实例），这个声明的过程也称为类的实例化。类和基本类型的不同之处在于，类这个特殊类型中同时包含了对数据进行操作的函数。 ","date":"2024-03-22","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A14/:2:0","tags":["面向对象程序设计"],"title":"c++(four)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A14/"},{"categories":["面向对象程序设计"],"content":"类的定义 以时钟为例：时钟类的定义如下： 类的声明形式 类是一种用户自定义类型，声明形式： class 类名称 { public: 公有成员（外部接口） private: 私有成员 protected: 保护型成员 }; 公有类型成员 在关键字public后面声明，它们是类与外部的接口（interface），任何外部函数都可以访问公有类型数据和函数。 私有类型成员 在关键字private后面声明，只允许本类中的函数访问，而类外部的任何函数都不能访问。 保护类型 与private类似，其差别表现在继承与派生时对派生类的影响不同，第七章讲。 void Clock::SetTime(int NewH,int NewM,int NewS) { Hour = NewH; Minute = NewM; Second = NewS; } void Clock::ShowTime() { cout\u003c\u003cHour\u003c\u003c “:”\u003c\u003cMinute\u003c\u003c“:”\u003c\u003c Second\u003c\u003cendl; } ","date":"2024-03-22","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A14/:2:1","tags":["面向对象程序设计"],"title":"c++(four)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A14/"},{"categories":["面向对象程序设计"],"content":"类成员的访问控制 定义访问控制属性的基本原则 将需要隐藏的成员设为私有类型；将提供给外界的接口设为公有类型。 设计一个类时，一定要设计必要的外部接口 一般情况下，一个类的数据成员都应该声明为私有成员，内部数据结构就不会对类外造成影响，程序模块之间的耦合性降低到最小。 类的成员 class Clock{ public: void SetTime(int NewH,int NewM,int NewS); void ShowTime(); //成员函数 (member function)或 函数成员 private: int Hour,Minute,Second; //数据成员 （data member）或 成员数据 }; void Clock :: SetTime(int NewH, int NewM,int NewS) { Hour=NewH; Minute=NewM; Second=NewS; } void Clock :: ShowTime（ ） { cout\u003c\u003cHour\u003c\u003c\":\"\u003c\u003cMinute\u003c\u003c\":\"\u003c\u003cSecond; } 概念设计中的类的表示 数据成员 与一般的变量声明相同，但需要将它放在类的声明体中。 ","date":"2024-03-22","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A14/:2:2","tags":["面向对象程序设计"],"title":"c++(four)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A14/"},{"categories":["面向对象程序设计"],"content":"类的成员函数 一般在类中声明成员函数的原型，在类外定义函数体的实现，并在函数名前使用类名加以限定。也可以直接在类中给出函数体，形成内联成员函数。 ","date":"2024-03-22","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A14/:2:3","tags":["面向对象程序设计"],"title":"c++(four)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A14/"},{"categories":["面向对象程序设计"],"content":"类的成员函数 成员函数调用中的目的对象 在类中调用成员函数与普通函数是不同，需要使用“对象.成员”，成员函数调用本类中成员不需要使用“.”，成员函数通过其它类的对象调用其它类中成员需要使用“.”。 成员函数可以调用本类中公开，私有、保护成员 允许声明重载函数和带缺省形参值的函数 成员函数重载 class Clock{ public:setTime(int newH,int newM,int newS); setTime(int newH,int newM); ...... } 带缺省形参值的成员函数 class Clock{ public:setTime(int newH=0,int newM=0,int newS=0); ...... } 内联成员函数(1) class Clock{ public:setTime(int newH=0,int newM=0,int newS=0); void showTime() { cout\u003c\u003chour\u003c\u003c”:”\u003c\u003cminute\u003c\u003c”:”\u003c\u003csecond; } ...... } 内联成员函数(2) class Clock{ public:setTime(int newH=0,int newM=0,int newS=0); ...... } inline void Clock::showTime() { cout\u003c\u003chour\u003c\u003c”:”\u003c\u003cminute\u003c\u003c”:”\u003c\u003csecond; } //注意：上面两种方式内联的效果是一样的 成员函数 成员函数的声明和实现 成员函数的实现 具体是现在类声明之外 与普通函数不同的是，实现函数时要指明类的名称。 成员函数声明的格式 返回值类型 类名 :: 成员函数名 （参数列表） { 函数体 } 内联成员函数举例(一) class Clock { public: void SetTime(int NewH, int NewM,int NewS); void ShowTime（ ） {cout\u003c\u003cHour\u003c\u003c\":\"\u003c\u003cMinute\u003c\u003c\":\"\u003c\u003cSecond;} private: int Hour, Minute, Second; }; 内联成员函数举例(二) class Point { public: void Init ( int initX,int initY); int GetX（ ）； int GetY（ ）； void Move ( int xOffset, int yOffset); private: int X,Y; }; inline void Point :: Init(int initX,int initY) { X=initX; Y=initY; } inline int Point :: GetX（ ） { return X; } inline int Point :: GetY（ ） { return Y; } inline void Point :: Move（ int xOffset,\u000bint yOffset） { X + = xOffset; Y + = yOffset; } ","date":"2024-03-22","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A14/:2:4","tags":["面向对象程序设计"],"title":"c++(four)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A14/"},{"categories":["面向对象程序设计"],"content":"类的声明和内部实现 将类的声明和其成员函数的定义分开，是目前程序开发的通常做法。 将类的声明放在头文件中，将类的成员函数的定义放在另外的源程序中 把类的声明看作是类的外部接口,成员函数的定义是类的内部实现(implementation) 将类拿来编写应用程序时，只需要类的外部接口（头文件）。和使用标准库函数一样，只需要包含函数声明的头文件。因为在类定义中，全部包含了类中成员函数的声明。 //date.h 类的声明 class Date { public : void Set ( int, int,int ); void Print ( ); private: int month, day, year; }； //date.cpp 成员函数定义 // 类的内部实现 #include \u003ciostream.h\u003e #include “date.h” void Date:: Set(int m, int d,int y) { month=m; day=d; year=y; } void Date:: Print( ) { cout\u003c\u003cmonth\u003c\u003c“/”\u003c\u003cday\u003c\u003c“/”\u003c\u003cyear\u003c\u003cendl; } ","date":"2024-03-22","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A14/:2:5","tags":["面向对象程序设计"],"title":"c++(four)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A14/"},{"categories":["面向对象程序设计"],"content":"对象 类和对象的关系 对象的类型称为类。类代表了一类对象的共性和特征。 类是对象的抽象，类的对象是具有该类类型的具体的实例（instance）。 每一种数据类型都是对一类对象的抽象，声明的每一个变量都是所属数据类型的一个实例。 类是用来定义对象的抽象数据类型，对象是类类型的变量 声明一个对象和声明一个一般变量相同 例： Clock myClock; //myClock是对象的名字， Clock 是myClock的类型 声明类类型的变量，这个变量就称为类的对象（或实例），这个声明的过程也称为类的实例化（instantiation）。 面向对象的问题求解过程 面向对象语言中的对象用来模拟现实世界中的对象。面向对象强调的是程序的类型化。 ","date":"2024-03-22","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A14/:2:6","tags":["面向对象程序设计"],"title":"c++(four)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A14/"},{"categories":["面向对象程序设计"],"content":"类和对象 类和对象的区别 类是在程序源代码中存在的实体，声明类的目的是为了建立对象。 对象是在程序运行过程中创建的运行时的实体。 程序执行时，一个对象被创建（这一过程称为实例化），即为程序中声明的一个对象分配存储单元。这时对象的生命周期开始。当对象生命期结束时，对象被删除，所占用的存储单元被释放 一个类的所有实例具有相同的结构和共享共同的行为，所没有共享的是它们各自的状态值（或属性值，即数据成员的值）。 对象的状态值分别保存在每个对象中。 class Point { public: void Init ( int initX,int initY); int GetX（ ）； int GetY（ ）； void Move ( int xOffset, int yOffset); private: int X,Y; }; 在运行时，我们只看到对象，程序的任务是由对象承担的。在程序中，我们只看到类。类定义了它的所有对象共享的代码，它还提供了结构样板，用于创建不同的对象。 每个对象的成员函数的代码并不存储于每个对象中，代码存储于某个公用的存储空间中。只有每个对象的状态值存储于每个对象之中 ","date":"2024-03-22","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A14/:2:7","tags":["面向对象程序设计"],"title":"c++(four)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A14/"},{"categories":["面向对象程序设计"],"content":"类的成员的访问方式 类中成员互访 类的内部，所有成员之间可以通过成员名(公开、私有、保护）直接访问。 类外访问 类的外部只能访问类的公有成员 使用**“对象名.成员名”**方式访问 类的应用举例 #include\u003ciostream.h\u003e class Clock { ......//类的声明略 } //......类的实现略 void main(void) { Clock myClock; myClock.SetTime(8,30,30); myClock.ShowTime（ ）; } ","date":"2024-03-22","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A14/:2:8","tags":["面向对象程序设计"],"title":"c++(four)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A14/"},{"categories":["面向对象程序设计"],"content":"类与结构体 在C++中的结构体比C中的结构体具有更强大的功能，它是另外一种形式的类。C++中的结构体也能像类一样包括数据和成员函数。 结构体成员 在于缺省情况下，结构体的成员是公有的。除此之外，类与结构体有完全相同的功能。所以结构体又称为全部成员都是公有成员的类。 例如：考虑实现“点”类的定义 //C++中的结构体 Struct SMyPoint { int x,y; void Draw( ) { cout\u003c\u003c“在坐标(”\u003c\u003cx\u003c\u003c“,”\u003c\u003cy\u003c\u003c“)处画一个点”\u003c\u003cendl; } }; 类的成员 缺省情况下，类中包括的数据成员和成员函数都是私有的。如果要在类中定义公有成员，必须显示声明public关键字。 例如：我们希望函数Draw是公有的，所以在类CMyPoint的定义中，显示地给出关键字public。 //定义一个“点”类 class CMyPoint { int x,y; public: void Draw( ) { cout\u003c\u003c“在坐标(”\u003c\u003cx\u003c\u003c“,”\u003c\u003cy\u003c\u003c“)\u000b处画一个点”\u003c\u003cendl; } }; ","date":"2024-03-22","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A14/:2:9","tags":["面向对象程序设计"],"title":"c++(four)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A14/"},{"categories":["面向对象程序设计"],"content":"构造函数和析构函数 一个类的所有对象都共享该类。每个对象都区别于其他的对象。外在的区别是对象的标识符，即对象名字。内在的区别是对象自身的属性值和所在的存储单元 在声明对象时对数据成员赋初值，称为对象的初始化。 在声明对象时，给对象分配存储单元，同时调用构造函数将对象初始化为一个特定的状态。 ","date":"2024-03-22","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A14/:3:0","tags":["面向对象程序设计"],"title":"c++(four)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A14/"},{"categories":["面向对象程序设计"],"content":"构造函数 构造函数是特殊形式的成员函数。 编译系统在遇见对象声明语句时，自动生成对构造函数的调用语句。因此构造函数是在对象被创建时由系统自动调用 如果程序中未定义构造函数，则编译系统自动生成一个默认形式的构造函数。 允许为内联函数、重载函数、带缺省形参值的函数。 构造函数的需要性 变量初始的方法 int a=1; int *pa=\u0026a; 数组初始的方法 int b[]={1,2,3,4}; 结构初始的方法 struct student{ int semesHours; //总需学时数 float gpa; //平均成绩 } void fn ( ) { student s = { 100 , 3.5 } ; //创建结构变量时，初始化 //… } 但是对类对象来说，如此初始化不行，这是由类的特殊性所决定。 例：下面的代码企图在对象创建时，为其初始化： class student{ public ; // …公共成员… protected : //此处的数据成员是受保护的 int semesHours ; float gpa ; } ; Void fa( ) { student s = { 100 , 3.5 } // error: 不能访问 // … } } 如果上面的函数允许那样初始化的话,就意味在函数中,允许： void fn ( ) { s.semesHours = 0 ; s.gpa = 0 ; } 类的封装性，就体现在一部分数据是不能让外界访问的。所以直接在非成员函 数中访问类对象的保护或私有数据是不允许的 类对象的初始化任务，自然就落在了类的成员函数身上，因为它们可以访问保护和私有数据成员。 初始化构想 class student { public: void init ( ) { semesHours = 100 ; gpa = 3.5 ; } // …其他公共成员 protected: int semesHours ; int gpa } void fn ( ) { student s ; s.init ( ); //类的初始化 //函数的其他部分 } 类对象的定义 student ss; 构造函数的作用 在对象被创建时利用特定的值构造对象，将对象初始化为一个特定的状态，使此对象具有区别于其他对象的特征。 定义构造函数的格式： class 类名 { public : 类名（形参列表）；//构造函数声明 ... }； 类名:: 类名（形参列表）// 构造函数的实现 { 函数体 } 构造函数举例: class Clock { public: Clock (int NewH, int NewM, int NewS); //构造函数 void SetTime(int NewH, int NewM, int NewS); void ShowTime（ ）; private: int Hour,Minute,Second; }; 构造函数的实现： Clock::Clock(int NewH, int NewM, int NewS) { Hour=NewH; Minute=NewM; Second=NewS; } 建立对象时构造函数的作用： void main（ ） { Clock c (0,0,0); //隐含调用构造函数，将初始值作为实参 c.ShowTime（ ）; } Clock c1; //错误的，没有给出必要的实参 构造函数可以带默认的形参值，也可以是内联函数 #include \u003c iostream.h\u003e class Clock { public: Clock(int NewH=7,int NewM=30,int NewS=0) //既是构造函数也是内联函数 { hour=NewH; minute=NewM; second=NewS; } void ShowTime() { cout\u003c\u003chour\u003c\u003c\":\"\u003c\u003cminute\u003c\u003c\":“\u003c\u003csecond\u003c\u003cendl; } private: int hour,minute,second; }; void main() { Clock c(6); c.ShowTime(); } 构造函数可以无形参值 下面的代码初始化桌子和凳子类对象： class Desk { public: Desk( ) // 构造函数定义 { weight = 10 ; height = 5 ; width = 5; length = 5 ; } protected : int weight ; int height ; int width ; int length ; }; class Stool { public: Stool( ) // 构造函数定义 { weight = 6 ; height = 3 ; width = 3; length = 3 ; } protected : int weight ; int height ; int width ; int length ; }; void fn( ) { Desk da ； //自动调用Desk( ), 创建对象并初始化 Stool sa ; //自动调用Stool( ) //… } 构造函数放在类的外部定义： #include \u003ciostream\u003e class Desk { public: Desk( ); // 构造函数声明 protected: int weight; int height; int width; int length; }; class Stool { public: Stool( ); // 构造函数声明 protected : int weight; int height; int width; int length; }; Desk :: Desk( ) //构造函数定义 { weight = 10; height = 5; width = 5; length = 5; cout \u003c\u003cweight\u003c\u003c“ “\u003c\u003cheight\u003c\u003c“ “\u003c\u003cwidth\u003c\u003c““\u003c\u003clength\u003c\u003cendl ; } Stool :: Stool( ) //构造函数定义 { weight = 6; height = 3; width = 3; length = 3; cout \u003c\u003cweight\u003c\u003c“ “\u003c\u003cheight\u003c\u003c“ “\u003c\u003cwidth \u003c\u003c““\u003c\u003clength\u003c\u003cendl; } void fn( ) { Desk da; //自动调用Desk( ) Stool sa; //自动调用Stool( ) } void main ( ) { fn( ); } //运行结果为： // 10 5 5 5 // 6 3 3 3 默认构造函数 若未提供一个类的构造函数（一个都未提供），则C++提供一个默认的构造函数。该默认构造函数无参数，仅负责创建对象，不做任何初始化工作。 只要一个类定义了一个或一个以上的构造函数，C++就不再提供默认的构造函数。即如果为类定义了一个带参数的构造函数，还想要无参构造函数，必须自己定义 举例： Class Student { //无构造函数 private: char name[20]; }; //等价于下面的 Class Student { Public: Student ( ) { } //一个空的无参构造函数 private: char name[20]; }; 拷贝构造函数 拷贝构造函数是一种特殊的构造函数，其形参是本类的对象的引用。其作用是使用一个已存在的对象（由拷贝构造函数的参数指定的对象）去初始化一个新的同类的对象。 class 类名 { public : 类名（形参）；//构造函数 //形参是本类的对象的引用 类名（类名 \u0026对象名）；//拷贝构造函数 ... }； 类名:: 类名（类名 \u0026对象名）// 拷贝构造函数的实现 { 函数体 } 如果程序员没有定义类的拷贝构造函数，则编译系统为程序自动生成一个默认拷贝构造函数。 这个默认拷贝构造函数执行的功能是：用作为初始值的对象的每个数据成员的值，初始化将要建立的对象的对应数据成员。 举例： class Point { public: Point(int xx=0,int yy=0){X=xx; Y=yy;} Point(Point\u0026 p); //拷贝构造函数 int GetX（ ） {return X;} int GetY（ ） {return Y;} private: int X,Y; }; Point::Point (Point\u0026 p) { X=p.X; Y=p.Y; cout\u003c\u003c\"拷贝构造函数被调\"\u003c\u003cendl; } 拷贝构造函数被调用的三种情况 当用类的一个对象去初始化该类的另一个对象时系统自动调用它实现拷贝赋值。 void main(void) { Point p1 (1, 2); Point p2(p1); //拷贝构造函数被调用 Point p3 = p2; //不同的方法含义一样(拷贝构造函数被调用) } 若函数形参的类型为类的对象,调用函数时,实参赋值给形参,系统自动调用拷贝构造函数 void fn ( Point p) { cout\u003c\u003cp.GetX（ ）\u003c\u003cendl; } void main（ ） { Point mp (1,2); fn (mp); //调用拷贝构造函数 } 函数 fn ( )的参数传递方式是值传递(引用传递除外）,实参mp传给形参p,形参p是mp的一个拷贝,即对象p用对象mp的值进行初始化 当函数的返回值类型是类的对象，系统自动调用拷贝","date":"2024-03-22","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A14/:3:1","tags":["面向对象程序设计"],"title":"c++(four)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A14/"},{"categories":["面向对象程序设计"],"content":"析构函数（destructor） 对象在声明时开始生存期，生存期结束时从内存中删除 完成对象被删除前的一些清理工作，例如关闭文件或释放内存 在对象的生存期即将结束的时刻由系统自动调用，然后对象消失，释放对象所占内存空间 如果程序中未定义析构函数，编译系统将自动生成一个默认的析构函数 析构函数也是特殊的类成员函数，它没有返回类型,没有参数,不能随意调用,也没有重载 只是在类对象生命期结束的时候,由系统自动调用 析构函数的格式 class 类名 { public : ~ 类名( ) ; //析构函数声明 ... }； 类名:: ~类名（） // 析构函数的实现 { 函数体 } 构造函数和析构函数举例 #include \u003ciostream\u003e class Point { public: Point ( int xx, int yy ); ~Point（ ）; //...其它函数原形 private: int X, Y; }; 类的应用举例 一圆型游泳池如图所示，现在需在其周围建一圆型过道，并在其四周围上栅栏。栅栏价格为35元/米，过道造价为20元/平方米。过道宽度为3米，游泳池半径由键盘输入。要求编程计算并输出过道和栅栏的造价 #include \u003ciostream\u003e const float PI = 3.14159; const float FencePrice = 35; const float ConcretePrice = 20; class Circle { private: float radius; public: Circle(float r); //构造函数 float Circumference（ ）; //圆周长 float Area（ ）; //圆面积 }; // 类的实现 // 构造函数初始化数据成员radius Circle::Circle(float r) {radius=r;} // 计算圆的周长 float Circle::Circumference（ ） { return 2 * PI * radius;} // 计算圆的面积 float Circle::Area（ ） { return PI * radius * radius; } void main （ ） { float radius; float FenceCost, ConcreteCost; // 提示用户输入半径 cout\u003c\u003c\"Enter the radius of the pool: \"; cin\u003e\u003eradius; // 声明 Circle 对象 Circle Pool(radius); Circle PoolRim(radius + 3); //计算栅栏造价并输出 FenceCost = PoolRim.Circumference() * FencePrice; cout \u003c\u003c \"Fencing Cost is ￥\" \u003c\u003c FenceCost \u003c\u003c endl; // 计算过道造价并输出 ConcreteCost = ( PoolRim.Area())- Pool.Area( ))*ConcretePrice; cout \u003c\u003c \"Concrete Cost is ￥\" \u003c\u003c ConcreteCost \u003c\u003c endl; } //运行结果 //Enter the radius of the pool: 10 //Fencing Cost is ￥2858.85 //Concrete Cost is ￥4335.39 ","date":"2024-03-22","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A14/:3:2","tags":["面向对象程序设计"],"title":"c++(four)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A14/"},{"categories":["面向对象程序设计"],"content":"类的组合 例： class Circle() { public: Circle(float r); float Circumference(); float area(); private: float radius; }; 类中的数据成员是另一个类的对象 可以在已有的抽象的基础上实现更复杂的抽象 在创建组合类的对象时，不仅要对本类中的基本数据类型成员进行初始化，也要对内嵌对象成员初始化 举例： class Point { private: float x, y; //点的坐标 public: Point(float h,float v); //构造函数 float GetX(void); //取X坐标 float GetY(void); //取Y坐标 void Draw(void); //在(x,y)处画点 };//...函数的实现略 class Line { private: Point p1,p2; //线段的两个端点 public: Line(Point a,Point b); //构造函数 void Draw(void); //画出线段 };//...函数的实现略 ","date":"2024-03-22","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A14/:4:0","tags":["面向对象程序设计"],"title":"c++(four)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A14/"},{"categories":["面向对象程序设计"],"content":"组合类的构造函数设计 组合类构造函数定义的一般形式： 类名::类名(形参表) ：内嵌对象1(形参表)，内嵌对象2(形参表)，…… { 本类的初始化 } 注：初始化列表，可以用于完成内嵌对象的初始化 对类中一般的数据成员也可以这样初始化 Point::Point(float h , float v):x(h) , y(v){ } ","date":"2024-03-22","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A14/:4:1","tags":["面向对象程序设计"],"title":"c++(four)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A14/"},{"categories":["面向对象程序设计"],"content":"组合类的构造函数调用 声明一个组合类的对象时，不仅它自身的构造函数将被调用，而且还将调用其内嵌对象的构造函数。 ","date":"2024-03-22","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A14/:4:2","tags":["面向对象程序设计"],"title":"c++(four)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A14/"},{"categories":["面向对象程序设计"],"content":"构造函数调用顺序 先调用内嵌对象的构造函数（按声明时出现的顺序，先声明者先构造）。然后执行本类构造函数的函数体。（析构函数的调用顺序相反） 若调用默认构造函数（即无形参的），则内嵌对象的初始化也将调用相应的默认构造函数 如果声明组合类的对象时没有指定对象的初始值，则自动调用无形参的构造函数。这时相应地，也调用内嵌对象的无形参的构造函数。 析构函数的调用执行顺序与构造函数刚好相反。 内嵌对象的构造顺序与内嵌对象的定义顺序相同 类的组合举例: class Part { public: Part() { }; Part (int i) { val=i; } ~Part() { }; void Print(){ cout\u003c\u003cval\u003c\u003cendl; } private: int val; }; class Whole { public: Whole() { }; Whole (int i, int j, int k); ~Whole(){ }; void Print(); private: Part one; Part two; int date; }; Whole::Whole() { date=0; } Whole::Whole (int i, int j, int k): two(i),one(j) { date=k; } void Whole::Print() { one.Print(); two.Print(); cout\u003c\u003cdate\u003c\u003cendl; } void main() { Whole w(5, 6, 7); w.Print(); } //输出结果: //6 //5 //7 例：类的组合—-线段距离Distance类 #include \u003c iostream\u003e #include \u003c cmath\u003e class point //point类声明 { public: point (int xx = 0 , int yy = 0 ) { X = xx , Y = yy ;} point( point \u0026p); int Getx( ) { return X;) int Gety( ) { return Y;) private: int x , y ; }; point::point(point \u0026p) { X = p.x ; Y = p.y ; cout\u003c\u003c“Point拷贝构造函数被调用”\u003c\u003cendl;} //类的组合 class Distance //Distance类的声明 { public: //外部接口 Distance ( Point xp1 , Point xp2 ); double GetDis( ) { return dist ; } private: Point p1 , p2 ; double dist ; }; // 组合类的构造函数 Distance::Distance( Point xp1 , Point xp2 ):p1(xp1) , p2(xp2) { cout\u003c\u003c“Distance构造函数被用”\u003c\u003cendl; double x = double( p1.Getx( ) – p2.Getx( ) ); double y = double( p1.Gety( ) – p2.Gety( ) ); dist = sqrt( x * x + y * y ) ; } // 主函数 void main( ) { //声明Point类的对象 Point myp1( 1 , 1) , myp2( 4 , 5 ); //声明Distance类的对象 Distance myd ( myp1 , myp2 ) ; cout\u003c\u003c“The distance is :” ; cout\u003c\u003cmyd.GetDis( ) \u003c\u003c endl ; } //程序的运行 结果为: //Point拷贝构造函数被调用 //Point拷贝构造函数被调用 //Point拷贝构造函数被调用 //Point拷贝构造函数被调用 //Distance构造函数被调用 //The distance is : 5 ","date":"2024-03-22","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A14/:4:3","tags":["面向对象程序设计"],"title":"c++(four)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A14/"},{"categories":["面向对象程序设计"],"content":"前向引用声明 类应该先声明，然后再使用 如果需要在某个类的声明之前，引用该类，则应进行前向引用声明。 前向引用声明只为程序引入一个代表该类的标识符，但具体声明在其它地方。 注意：在提供一个完整的类定义之前，不能定义该类的对象，也不能在内联函数中使用该类的对象。 举例： class B; //前向引用声明 class A { public: void f(B b); }; class B { public: void g(A a); }; ","date":"2024-03-22","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A14/:4:4","tags":["面向对象程序设计"],"title":"c++(four)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A14/"},{"categories":["面向对象程序设计"],"content":"类模板(class template) 通用代码重用 类模板 使用类模板使用户可以为类声明一种模式，使得类中的某些数据成员、某些成员函数的参数、某些成员函数的返回值，能取任意类型(包括系统预定义的和用户自定义的)。 参数化程序设计 在多数情况下，越通用的代码越能够重用 模板是C++支持参数化的工具 实现参数化多态性，就是将程序所处理的对象的类型参数化 ","date":"2024-03-22","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A14/:5:0","tags":["面向对象程序设计"],"title":"c++(four)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A14/"},{"categories":["面向对象程序设计"],"content":"类模板声明形式 template \u003c形式类型参数表\u003e class classname { //类声明体 }; “形式类型参数表”中可包含下列内容 class标识符 指明可以接受一个类型参数。 类型说明符 标识符 指明可以接受一个由“类型说明符”所规定类型的常量作为参数 模板类的成员函数必须是函数模板 template \u003c形式类型参数表\u003e 返回类型 classname \u003c类型名表\u003e :: MemberFuncName1 (形式参数表) { //成员函数定义体 } template \u003c形式类型参数表\u003e 返回类型 classname \u003c类型名表\u003e ::MemberFuncName2 (形式参数表) { //成员函数定义体 } 类模板(包括成员函数的定义)不是一个实实在在的类，只是对类的描述 建立类模板之后，可用以下方式创建类模板的实例： classname \u003c实际存在类型参数表\u003e object 其中实在类型参数表和类模板中形式类型参数表匹配。 classname \u003c实际存在类型参数表\u003e 是模板类( template class ),object是该模板类的一个对象。 举例： #include \u003ciostream\u003e template \u003cclass T, int i\u003e class TestClass { public: T buffer[i]; void setArray( ); void showArray(); }; template \u003cclass T, int i\u003e void TestClass\u003cT,i\u003e::setArray( ) { for(int j=0;j\u003ci;j++) cin\u003e\u003ebuffer[j]; }; template \u003cclass T, int i\u003e void TestClass\u003cT,i\u003e::showArray() { for(int j=0;j\u003ci;j++) cout\u003c\u003cbuffer[j]; cout\u003c\u003cendl; }; void main(void) { TestClass\u003cchar, 5\u003e ClassInst; ClassInst.setArray(); ClassInst.showArray(); } //运行结果： //a //b //c //d //e //abcde ","date":"2024-03-22","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A14/:5:1","tags":["面向对象程序设计"],"title":"c++(four)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A14/"},{"categories":["面向对象程序设计"],"content":"类模板和模板类 类模板和模板类的区别： 类模板是模板的定义，不是一个 实实在在的类，定义中用到通用形式 类型参数。 模板类是实实在在的类定义，是 类模板的实例化。形式类型参数被实 际类型所代替 例： Template \u003cclass T\u003e Class Store { Private: T item; Public: Store ( ); T GetElem ( ); void Putelem (T x); }; Void main(void) { Store \u003cint\u003e s1, s2; Store \u003cStudent\u003e s3; } //其中Store\u003cint\u003e s1,s2; //模板生成函数为： //Class Store //{ //Private: // int item; //Public: // Store ( ); // int GetElem ( ); // void Putelem (int x); //}; //其中Store \u003cStudent\u003e s3; //模板生成函数为： //Class Store //{ //Private: // Student item; //Public: // Store ( ); // Student GetElem ( ); // void Putelem (Student x); // }; 类模板应用举例 #include \u003ciostream\u003e #include \u003cstdlib\u003e // 结构体Student struct Student { int id; //学号 float gpa; //平均分 }; template \u003cclass T\u003e //类模板：实现对任意类型数据进行存取 class Store { private: T item; // 用于存放任意类型的数据 int haveValue; // 用于标记item是否已被存入内容 public: Store(void); // 缺省形式（无形参）的构造函数 T GetElem(void); //提取数据函数 void PutElem(T x); //存入数据函数 }; // 默认形式构造函数的实现 template \u003cclass T\u003e Store\u003cT\u003e::Store(void): haveValue(0) {} template \u003cclass T\u003e // 提取数据函数的实现 T Store\u003cT\u003e::GetElem(void) { // 如果试图提取未初始化的数据，则终止程序 if (haveValue == 0) { cout \u003c\u003c \"No item present!\" \u003c\u003c endl; exit(1); } return item; // 返回item中存放的数据 } template \u003cclass T\u003e // 存入数据函数的实现 void Store\u003cT\u003e::PutElem(T x) { haveValue++; // 将haveValue 置为 TRUE， //表示item中已存入数值 item = x; // 将x值存入item } void main(void) { Student g= {1000, 23}; Store\u003cint\u003e S1, S2; S1.PutElem(3); S2.PutElem(-7); cout \u003c\u003c S1.GetElem( ) \u003c\u003c \" \" \u003c\u003c S2.GetElem( ) \u003c\u003c endl; S3.PutElem(g); cout \u003c\u003c \"The student id is \" \u003c\u003cS3.GetElem( ).id \u003c\u003c endl; cout \u003c\u003c \"Retrieving object D \" ; cout \u003c\u003c D.GetElem( ) \u003c\u003c endl; //输出对象D的数据成员,由于D未经初始化, //在执行函数D.GetElement( )时出错 } //运行结果: //3 -7 //The student id is 1000 //Retrieving object D No item present! ","date":"2024-03-22","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A14/:5:2","tags":["面向对象程序设计"],"title":"c++(four)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A14/"},{"categories":["面向对象程序设计"],"content":"总结 类的组合 组合类构造函数定义的一般形式： 类名::类名(形参表) ：内嵌对象1(形参表)，内嵌对象2(形参表)，...... { 本类的初始化 } 前向引用声明 类模板 template \u003c形式类型参数表\u003e class classname { //类声明体 }; 使用一个模板类来建立对象时，声明形式 classname \u003c实在类型参数表\u003e object; ","date":"2024-03-22","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A14/:5:3","tags":["面向对象程序设计"],"title":"c++(four)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A14/"},{"categories":["面向对象程序设计"],"content":"函数 ","date":"2024-03-21","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A13/:0:0","tags":["面向对象程序设计"],"title":"c++(three)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A13/"},{"categories":["面向对象程序设计"],"content":"函数的定义与使用 所有的高级语言都有子程序的概念，实现模块的划分 C和C++中的子程序体现为函数 一个C++程序由一个主函数和若干其他函数构成 函数分为：标准库函数和用户自定义函数 ","date":"2024-03-21","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A13/:1:0","tags":["面向对象程序设计"],"title":"c++(three)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A13/"},{"categories":["面向对象程序设计"],"content":"函数的定义 函数是面向对象设计中的基本抽象单元，是对功能的抽象 函数声明的语法形式 函数的定义(函数的类型和返回值) 形式参数表 函数的返回值 ​ C++语言把函数返回值的数据类型规定为该函数的数据类型。因此，函数返回值的类型一定要与函数的类型相同 由return语句给出，例如： return 0 无返回值的函数(void类型)，不必写return语句 函数的定义(说明) 所有函数都是平行的，即在定义函数时是相互独立的，C++和C不允许函数嵌套定义，即在函数体中在定义一个函数是非法的(与PASCAL不同) C++程序的执行从main函数开始，调用其他函数后回到main函数，在main函数中结束整个程序的运行。main函数是系统定义的 例： int main(){ float add(float x,float y); //函数声明 float a,b,c; cin\u003e\u003ea\u003e\u003eb; c=add(a,b); cout\u003c\u003cc\u003c\u003cendl; } float add(float x,float y){ //函数首部 float z; //函数体 z=x+y; return z; } //float add(float x,float y){}为函数定义 float add(float x,float y){ //函数首部 int z; //float改为int //函数体 z=x+y; return z; //出错 } 函数定义的一般形式 获取参数并返回值 int bigger(int a,int b){ return(a\u003eb)?a:b; } 获取参数但不返回值 void delay(long a){ for(int i=1;i\u003c=a;i++); } 没有获取参数但返回值 int geti(void){ //键盘获取一个整数 int x; cout\u003c\u003c\"please input a integer:\\n\"; cin\u003e\u003ex; return x; } 没有获取参数也不返回值 void message(void) //在屏幕上显示一个消息 { cout\u003c\u003c\"This is a message.\\n\"; } ","date":"2024-03-21","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A13/:1:1","tags":["面向对象程序设计"],"title":"c++(three)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A13/"},{"categories":["面向对象程序设计"],"content":"函数的调用 调用形式 函数名(实参列表) 调用的方式 函数语句： func(); //此时函数可以无返回值 函数表达式 if((x=func())==somevalue) //函数做参数 // func()必须有一个明确的返回值 函数参数 m=max(a,max(b,c)); 函数声明和函数原型 一个函数调用另一个函数(被调函数)的条件： 点用函数之前必须首先对被调函数进行声明 函数声明(declaration) 是一条程序语句，包含函数名，返回类型和形式参数列表 作用是把函数的名字、返回类型以及形参的类型、个数和顺序通知编译系统，以便在调用该函数时按此进行对照检查(例如函数名是否正确、实参和形参的类型和个数是否一致) 函数声明和函数原型(说明) 函数声明的形式： 1.类型标识符 函数名(参数类型1，参数类型2，... ...); 2.类型标识符 函数名(参数类型1 参数名1，参数类型2 参数名2，... ...); 函数声明的说明 第1种是基本形式，只包含参数的类型 为了阅读，也允许加上参数名 以下三种声明形式等价 float add(float,float); float add(float a,float b); float add(float x,float y); 函数原型(function prototype) 在C++和C中，函数声明就是函数原型 函数声明和函数定义的区别 “定义”指对函数功能的确定，包括指定函数名，返回类型，形参及其类型，函数体，它是一个完整，独立的函数单位 “声明”只是把函数的原型通知编译系统 注意：声明函数时，函数原型预定义函数时函数首部在写法上必须一致，既函数名，返回类型，参数个数，参数类型和参数顺序必须相同，否则产生编译错误。 函数原型的作用 在编译阶段对函数调用的合法性进行全面检查 main(){ //编译从上到下逐条进行 float add(float x,float y); //如果没有函数声明，当编译“c=add(a,b)”时，编译系统不知道add是不是函数名，也无法判断实参的类型和个数是否正确，无法进行正确性检查。有可能导致运行时则错误 //在函数调用之前声明了函数原型，编译系统就会根据函数原型对函数调用的合法性进行全面检查，和函数原型不匹配的函数调用就会导致编译出错 c=add(a,b); ... } float add(float x,float y){ ... } 函数声明的位置 char letter(char,char); float f(float,float); int i(int,int); //如果在所有函数定义之前，在函数的外部已做了函数声明，那么函数原型在本文件中任何地方有效，即在本文件中任何地方都可以按照函数原型调用相应的函数 main() {...} char letter(char c1,char c2) {...} float f(float x,float y) {...} int i(int x,int y) {...} 函数在被调用之前必须声明或定义，如同变量使用之前必须先定义 ","date":"2024-03-21","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A13/:1:2","tags":["面向对象程序设计"],"title":"c++(three)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A13/"},{"categories":["面向对象程序设计"],"content":"函数调用的执行过程 函数调用的图例 嵌套调用 ","date":"2024-03-21","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A13/:1:3","tags":["面向对象程序设计"],"title":"c++(three)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A13/"},{"categories":["面向对象程序设计"],"content":"函数调用的内部机制 函数调用的过程就是栈空间的操作过程 建立被调函数的栈空间 保护主调函数的运行状态和返回地址 传递参数 将控制转变为被调函数 栈 是一种数据结构 是后进先出(Last In First Out)的线性表 ","date":"2024-03-21","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A13/:1:4","tags":["面向对象程序设计"],"title":"c++(three)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A13/"},{"categories":["面向对象程序设计"],"content":"栈 只允许在一端插入和删除的顺序表，插入和删除的一端称为栈顶，另一端称为栈底 特点：后进先出 ","date":"2024-03-21","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A13/:2:0","tags":["面向对象程序设计"],"title":"c++(three)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A13/"},{"categories":["面向对象程序设计"],"content":"函数调用时栈的建立过程 ","date":"2024-03-21","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A13/:2:1","tags":["面向对象程序设计"],"title":"c++(three)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A13/"},{"categories":["面向对象程序设计"],"content":"函数调用的返回 ","date":"2024-03-21","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A13/:2:2","tags":["面向对象程序设计"],"title":"c++(three)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A13/"},{"categories":["面向对象程序设计"],"content":"递归调用 再调用一个子程序或函数的过程之中出现直接或间接调用该子程序或函数本身，称为过程的递归调用 递归调用的形式 直接递归 void fun1(void){ ... fun1(); ... } Long fib(int x){ if(x\u003e2) return(fib(x-1)+fib(x-1)); //直接递归 else return 1; } 间接递归 例: int fn1(int a){ int b; b=fn2(a+1); //间接递归 //... } int fn2(int s){ int c; c=fn1(s-1); //间接递归 //... } 递归过程的两个阶段 递推 回归 例：求n! 分析：计算n!的公式如下 $n!= \\begin{cases}1,(n=0)\\n(n-1)!,(n\u003e0)\\end{cases}$ 这是一个递归实现的公式，应该用递归函数实现 long Factorial(long n){ if(n==0) return 1; else return n*Factorial(n-1); } 求解阶乘n!的过程 ","date":"2024-03-21","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A13/:2:3","tags":["面向对象程序设计"],"title":"c++(three)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A13/"},{"categories":["面向对象程序设计"],"content":"三点认识 对于一个较为复杂的问题，如果能够分解成几个相对简单的且解法相同或类似的子问题时，只要解决了这些子问题，那么原问题就迎刃而解了，这就是递归求解。 例：4！=4*3！ 递归结束条件 当分解后的子问题可以直接解决时，就停止分解。可以直接求解的问题叫做递归结束条件 如：0！=1 定义的结构 递归定义的函数可以简单地用递归过程来编程求解。递归直接反映了定义的结构 ","date":"2024-03-21","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A13/:2:4","tags":["面向对象程序设计"],"title":"c++(three)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A13/"},{"categories":["面向对象程序设计"],"content":"递归的条件 须有完成函数任务的语句 #include\u003ciostream\u003e void count(int val) //递归函数可以没有返回值 { if(val\u003e1) count(val-1); cout\u003c\u003c\"ok:\"\u003c\u003cval\u003c\u003cendl; //此语句完成函数任务 } 一个确定是否能避免递归调用的测试 例：上例代码中，语句“if(val\u003e1)”便是一个测试 一个递归调用语句 例：上例代码中，“count(val-1);” 先测试，后递归调用 例： #include\u003ciostream\u003e void count(int val) { count(val-1); //无限递归下去 if(val\u003e1) //该语句无法达到 cout\u003c\u003c\"ok:\"\u003c\u003cval\u003c\u003cendl; } ","date":"2024-03-21","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A13/:2:5","tags":["面向对象程序设计"],"title":"c++(three)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A13/"},{"categories":["面向对象程序设计"],"content":"自学(汉诺塔问题) 有三根针A、B、C。A针上有N个盘子，大的在下，小的在上，要求把这N个盘子从A针移到C针，在移动过程中可以借助B针，每次只允许移动一个盘，且在移动过程中在三根针上都保持大盘在下，小盘在上。 分析：将n个盘子从A移到C针可以分解为下面三个步骤 将A上n-1个盘子移到B针上(借助C针) 把A针上剩下的一个盘子移到C针上 将n-1个盘子从B针移到C针上(借助A针) 事实上，上面是三个步骤包含两种操作： 将多个盘子从一个针移到另一个针上，这是一个递归的过程。hanoi函数实现 将1个盘子从一个针上移到另一个针上用move函数实现 如图： 代码实现： #include\u003ciostream\u003e #include\u003cstrcalss\u003e void Hanoi(int n,string A,string B,string C) //解决汉诺塔问题的算法 { if(n==1) cout\u003c\u003cA\u003c\u003c\"to\"\u003c\u003cC\u003c\u003cendl; else{ Hanoi(n-1,A,C,B); cout\u003c\u003c\"move\"\u003c\u003cA\u003c\u003c\"to\"\u003c\u003cC\u003c\u003cendl; Hanoi(n-1,B,A,C); } } 过程： ","date":"2024-03-21","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A13/:3:0","tags":["面向对象程序设计"],"title":"c++(three)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A13/"},{"categories":["面向对象程序设计"],"content":"函数的参数传递机制(传递参数值) 函数定义中指定的形参，在函数未被调用时，并不占有存储单元，在函数被调用时才在栈中为形参分配存储单元，并将实参与形参结合 实参可以是常量，变量，表达式 实参类型必须与形参相同 传递时是传递参数值(Call by value)，即单向传递，将实参的值传递给形参，形参值的改变对实参不起作用 举例： #include\u003ciostream\u003e void Swap(int a,int b); int main() { int x(5),y(10); cout\u003c\u003c\"x=\"\u003c\u003cx\u003c\u003c\"y=\"\u003c\u003cy\u003c\u003cendl; Swap(x,y); cout\u003c\u003c\"x=\"\u003c\u003cx\u003c\u003c\"y=\"\u003c\u003cy\u003c\u003cendl; return 0; } void Swap(int a,int b) { int t; t=a; a=b; b=t; } ","date":"2024-03-21","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A13/:3:1","tags":["面向对象程序设计"],"title":"c++(three)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A13/"},{"categories":["面向对象程序设计"],"content":"引用 概念 引用是一个变量或对象的别名 通过引用名与通过被引用的变量名访问变量的效果一样 声明一个引用时，必须同时对它进行初始化，使它指向一个已存在的对象 一旦一个引用被初始化后，就不能改为指向其它对象 一个引用，从它诞生之时起，就必须确定是那个变量的别名，而且始终只能作为这一变量的别名，不能另作他用 引用的建立 建立引用时，先写上目标类型，后跟引用运算符”\u0026“，然后是引用的名字。引用能使用任何合法的变量名 例：引用一个整型变量 int someInt; int\u0026 rInt = someInt; 程序的建立和使用引用 例： #include\u003ciostream\u003e void main(){ int intOne; int\u0026 rInt=intOne; intOne=5; cout\u003c\u003c\"intOne:\"\u003c\u003cintOne\u003c\u003cendl; cout\u003c\u003c\"rInt:\"\u003c\u003crInt\u003c\u003cendl; rInt=7; cout\u003c\u003c\"intOne:\"\u003c\u003cintOne\u003c\u003cendl; cout\u003c\u003c\"rInt:\"\u003c\u003crInt\u003c\u003cendl; } //运行结果 //intOne:5 //rInt:5 //intOne:7 //rInt:7 ","date":"2024-03-21","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A13/:4:0","tags":["面向对象程序设计"],"title":"c++(three)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A13/"},{"categories":["面向对象程序设计"],"content":"函数的参数传递(用引用做形参) 引用运算符只在声明的时候使用，它放在类型名后面 int\u0026 rInt=intOne; 任何其它”\u0026“的使用都是地址操作符： 例： int *ip=\u0026intOne; cout\u003c\u003c\u0026ip; 为了提高可读性，不应在同一行上同时声明引用，指针和变量 int \u0026rInt,sa; 与指针类似，下面三种声明引用的方法都是合法的。 int \u0026rInt; 引用可以作为形参 void swap(int \u0026a,int \u0026b) { ... } 引用作为形参时，用实参来初始化形参。引用类型的形参就通过形式结合，成为实参的别名，对形参的任何操作就会作用于实参。 例：输入两个整数交换后输出 #include\u003ciostream\u003e void Swap(int\u0026 a, int\u0026 b); int main（ ） { int x(5), y(10); cout\u003c\u003c\"x=\"\u003c\u003cx\u003c\u003c\" y=\"\u003c\u003cy\u003c\u003cendl; Swap(x,y); cout\u003c\u003c\"x=\"\u003c\u003cx\u003c\u003c\" y=\"\u003c\u003cy\u003c\u003cendl; return 0; } void Swap(int\u0026 a, int\u0026 b) { int t; t=a; a=b; b=t; } //运行结果 //x=5,y=10 //x=1-,y=5 注意： 引用不能绑定常量 引用一旦初始化，其值就不能修改 数组不能定义引用 ","date":"2024-03-21","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A13/:4:1","tags":["面向对象程序设计"],"title":"c++(three)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A13/"},{"categories":["面向对象程序设计"],"content":"小结 值调用和引用调用的比较 值调用是在发生函数调用时，给形参分配存储单元，并用实参来初始化形参（将实参的值直接传递给形参）。这一过程是参数值的单向传递过程，一旦形参获得了值，便与实参脱离关系。以后无论形参怎样改变，都不会影响到实参。 引用调用将引用作为形参，在发生函数调用时，实参初始化形参，形参就成为实参的一个别名，对形参的任何操作就直接作用于实参。 ","date":"2024-03-21","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A13/:4:2","tags":["面向对象程序设计"],"title":"c++(three)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A13/"},{"categories":["面向对象程序设计"],"content":"内联函数 为何使用内联函数(内嵌函数) 函数调用需要建立栈内存环境，进行参数传递，并产生程序执行转移，需要时间和空间的开销。如果有的函数被频繁调用，则耗时很长，降低执行效率 将规模较小又使用频繁的函数定义为内联函数，在编译时就会将函数体的代码嵌入到主调函数内的每一个调用语句处，节省了参数传递，控制转移等开销 例： #include\u003ciostream\u003e using namespace std; int isnumber(char); //函数声明 int main(){ char c; while((c=cin.get())!='\\n') //读入一个字符给变量并于’\\n‘作比较 { if(isnumber(c)) //调用一个小函数 cout\u003c\u003c\"You entered a digit \\n\"; else cout\u003c\u003c\"You entered a non-digit \\n\"; } } int isnumber(char ch) //函数定义 { return(ch\u003e='0'\u0026\u0026ch\u003c='9')?1:0; } 为了提高效率，可将程序改为： #include\u003ciostream\u003e void main(){ char c; while((c=cin.get())!='\\n'){ if((ch\u003e='0'\u0026\u0026ch\u003c='9')?1:0) cout\u003c\u003c\"You entered a digit \\n\"; else cout\u003c\u003c\"You entered a non-digit \\n\"; } } 解决办法 将isnumber()函数声明为inline inline int isnumber(char); inline int isnumber(char c){ return(ch\u003e='0'\u0026\u0026ch\u003c='9')?1:0; } 声明和定义时使用关键字inline inline 类型说明符 被调函数名 (含类型说明的形参表) 例： #include\u003ciostream\u003e inline int isnumber(char); //inline函数声明 void main() { char c; while((c=cin.getc())!='\\n') { if(isnumber(c)) //调用一个小函数 cout\u003c\u003c\"You entered a digit \\n\"; else cout\u003c\u003c\"You entered a non-digit \\n\"; } } int isnumber(char ch) //此处无inlinr,视为inline { return(ch\u003e='0'\u0026\u0026ch\u003c='9')?1:0; } 先声明后调用 内联函数的声明必须出现在内联函数第一次被调用之前 例：下面的代码不会像预计的那样被编译 #include\u003ciostream\u003e int isnumber(char); //此处无inline void main() { char c; while((c=cin.getc())!='\\n') { if(isnumber(c)) //调用一个小函数 cout\u003c\u003c\"You entered a digit \\n\"; else cout\u003c\u003c\"You entered a non-digit \\n\"; } } int isnumber(char ch) //此处为inline { return(ch\u003e='0'\u0026\u0026ch\u003c='9')?1:0; } ","date":"2024-03-21","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A13/:5:0","tags":["面向对象程序设计"],"title":"c++(three)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A13/"},{"categories":["面向对象程序设计"],"content":"内联函数声明与使用 内联函数的函数体限制 内联函数体内不能有循环语句和switch语句 递归函数(自己调用自己的函数)是不能被用来做内联函数的 内联函数体只适合只有1~5行的小函数 对内联函数不能进行异常接口声明 使用内按函数可以节省运行时间，但却增加了目标程序的长度 举例： #include\u003ciostream\u003e inline int max(int a,int b,intc){ if(b\u003ea) a=b; if(c\u003ea) a=c; return a; } void main(){ int i=7,j=10,k=25,m; m=max(i,j,k); //编译系统遇见函数调用max(i,j,k)时，就用max函数体的代码代替max(i,j,k),同时将实参代替形参。这样，max(i,j,k)就被置换成： // if ( j\u003ei ) i = j ; // if ( k\u003ei ) i = k; // m=i; cout\u003c\u003cm\u003c\u003cendl; } ","date":"2024-03-21","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A13/:5:1","tags":["面向对象程序设计"],"title":"c++(three)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A13/"},{"categories":["面向对象程序设计"],"content":"带默认形参值的函数(默认形参值的作用) 默认形参值 一般情况下，实参个数应该与形参个数相同。C++允许实参和形参个数不同，办法是在形参列表中对形参指定默认值。 调用时如给出实参，则用实参初始化形参，否则采用预先给出的默认形参值。 c++可以给函数定义默认参数值。 通常要为函数的每个参数给定对应的实参 例： void delay(int loops); //函数声明 void delay(int loops) //函数定义 { if(loops==0) return; for(int i=0;i\u003cloops;i++); } 有时需要用相同的实参反复调用delay()函数。c++可以给参数定义默认值。 例： void delay(int loops=1000); 默认形参值得说明次序 默认形参值必须按从右向左顺序声明，并且在默认形参值的右面不能有非缺省形参值的参数。因为调用时实参初始化形参是从左向右的顺序。 例： int add(int x,int y=5,int z=6); //正确 int add(int x=1,int y=5,int z); //错误 int add(int x=1,int y,int z=6); //错误 缺省形参值与函数的调用位置 默认形参值在函数声明中提供，当既有声明又有定义时，定义中不允许默认参数。如果函数只有定义，则默认形参值才可以在函数定义中提供。 缺省形参值得作用域 在相同的作用域内，缺省形参值的说明应保持唯一，但如果在不同的作用域内，允许说明不同的缺省形参。 注： 在相同的作用域内，即使前后定义的值相同也不行； 如果一个函数在定义之前又有原型声明，默认形参值需要在原型中给出，定义中不能再出现默认形参值。 例： int add(int x=1,int y=2); void main(void) { int add(int x=3,int y=4); add(); //使用局部缺省形参值（实现3+4） } void fun(void){ ... add(); //使用全局缺省形参值(实现1+2) } ","date":"2024-03-21","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A13/:6:0","tags":["面向对象程序设计"],"title":"c++(three)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A13/"},{"categories":["面向对象程序设计"],"content":"函数重载 如果没有重载机制，即使是完全相同的操作，但是针对不同的数据类型，就需要定义名称完全不同的函数。 例如定义加法函数，必须对整数加法和浮点数加法使用不同的函数名： int iadd(int x,int y) { int z; z=x+y; return z; } int fadd(float x,float y) { float z; z=x+y; return z; } C++允许功能相近的函数在相同的作用域内以相同函数名定义, 从而形成重载。方便使用,便于记忆。 若干函数,名称相同,但形参个数或类型不同,编译器根据实参和形参的类型及个数的最佳匹配，自动确定调用那一个函数,这就是函数重载。 例： //形参类型不同 int add(int x,int y); float add(float x,float y); //形参个数不同 int add(int x,int y); int add(int x,int y,int z); 注意事项 重载函数的形参必须不同: 个数不同或类型不同。 编译程序将根据实参和形参的类型及个数的最佳匹配来自动选择调用哪一个函数 不要将不同功能的函数声明为重载函数，以免出现调用结果的误解、混淆。这样不好： 例：编写三个名为add的重载函数，分别实现两整数相加，两实数相加和两个复数相加的功能 #include\u003ciostream.h\u003e struct complex { double real; double imaginary; }; void main(void) { int m, n; double x, y; complex c1, c2, c3; int add(int m, int n); double add(double x, double y); complex add(complex c1, complex c2); cout\u003c\u003c\"Enter two integer: \"; cin\u003e\u003em\u003e\u003en; cout\u003c\u003c\"integer\"\u003c\u003cm\u003c\u003c'+'\u003c\u003cn\u003c\u003c\"=“\u000b\u003c\u003cadd(m,n)\u003c\u003cendl; cout\u003c\u003c\"Enter two real number: \"; cin\u003e\u003ex\u003e\u003ey; cout\u003c\u003c\"real number \"\u003c\u003cx\u003c\u003c'+'\u003c\u003cy\u003c\u003c\u000b\"= \"\u003c\u003cadd(x,y) \u003c\u003cendl; cout\u003c\u003c\"Enter the first complex number: \"; cin\u003e\u003ec1.real\u003e\u003ec1.imaginary; cout\u003c\u003c\"Enter the second complex number: \"; cin\u003e\u003ec2.real\u003e\u003ec2.imaginary; c3=add(c1,c2); cout\u003c\u003c\"complex number (\" \u003c\u003cc1.real\u003c\u003c ',' \u003c\u003c c1.imaginary \u003c\u003c\")+(\"\u003c\u003cc2.real\u003c\u003c',' \u003c\u003cc2.imaginary\u003c\u003c\")=(\"\u003c\u003cc3.real\u003c\u003c',' \u003c\u003cc3.imaginary\u003c\u003c\")\\n\"; } int add(int m, int n) { return m+n; } double add(double x, double y) { return x+y; } complex add(complex c1, complex c2) { complex c; c.real=c1.real+c2.real; c.imaginary=c1.imaginary+c2.imaginary; return c; } //运行结果 //Enter two integer: 3 5 //integer 3+5=8 //Enter two real number: 2.3 5.8 //real number 2.3+5.8= 8.1 //Enter the first complex number: 12.3 45.6 //Enter the second complex number: 56.7 67.8 //complex number (12.3,45.6)+(56.7,67.8)=(69,113.4) 重载函数需要注意以下五个问题 函数的返回类型不能成为判断依据 如果在两个函数的参数列表中只有缺省实参不同，那么它们也不会被看作是重载函数。 采用typedef定义的类型也不能作为判断依据。 采用const来修饰按值传递的参数也意味着不改变实参的数值，所以不能被看作是重载函数 重载函数中所有的函数定义都必须在同一个域中，不同类域中的函数也不能构成重载函数 重载函数的选择 重载函数被调用时，系统会根据指定的实参在多个同名的函数中选择一个最合适的函数，通常分为三个步骤： 在重载函数集合中找出可行函数，可行函数的参数个数要和调用时的实参的个数相同，或者多一些缺省的参数，可行函数的参数类型要和调用时实参的类型相同，或者可以转换。 在可行函数中，寻找精确匹配的函数，精确匹配是指实参和形类的类型和个数完全相同，也指从数组到指针的类型转换，从函数到指针的类型转换。 依据数据类型转换规则，找到可匹配函数。类型转换被分成三个等级：提升转换、标准转换和自定义转换。 如果通过上述三步仍然无法找到任何可匹配函数，那么该函数的调用就是二义的。 ","date":"2024-03-21","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A13/:7:0","tags":["面向对象程序设计"],"title":"c++(three)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A13/"},{"categories":["面向对象程序设计"],"content":"函数模板 ","date":"2024-03-21","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A13/:8:0","tags":["面向对象程序设计"],"title":"c++(three)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A13/"},{"categories":["面向对象程序设计"],"content":"代码重用 按不同方式重复使用已有的代码 代码必须通用，不受数据类型的限制，这是参数化程序设计 模板有可以使用和操作任何数据类型的通用代码构成，其中将所使用的数据类型说明为参数 函数模板可以用来创建一个通用功能的函数，以支持多种不同形参，进一步简化重载函数的函数体设计。 ","date":"2024-03-21","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A13/:8:1","tags":["面向对象程序设计"],"title":"c++(three)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A13/"},{"categories":["面向对象程序设计"],"content":"函数模板的定义形式 template\u003c类型形式参数表\u003e 类型名 函数名(形式参数表) { //函数体 } 如果形式参数包含基本数据类型，加前缀typename template \u003ctypename T\u003eT func(T x) 如果形式参数表包含类类型名，加前缀class template T func(T x) template \u003cclass T\u003e 或 template \u003ctypename T\u003e 类型名 函数名(形式参数表) { 函数体 } 例：求绝对值函数的模板 #include\u003ciostream.h\u003e template\u003ctypename T\u003e T abs (T x) { return x\u003c0?-x:x; } void main（ ） { int n=-5; double d=-5.5; cout\u003c\u003cabs(n)\u003c\u003cendl; cout\u003c\u003cabs(d)\u003c\u003cendl; } 当类型参数的含义确定后，编译器将以函数模板为样板，生成一个函数： int abs (int x) { return x\u003c0?-x:x; } 对于调用表达式abs(d)，由于实参d为double类型，所以推导出模板中类型参数T为double。接着，编译器将以函数模板为样板 double abs (double x) { return x\u003c0?-x:x; } ","date":"2024-03-21","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A13/:8:2","tags":["面向对象程序设计"],"title":"c++(three)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A13/"},{"categories":["面向对象程序设计"],"content":"函数模板的说明 函数模板 函数模板的定义不是一个实实在在的函数，编译系统不为其产生任何执行代码。该定义只是对函数的描述，表示它每次能处理在类型形式参数表中说明的数据类型 当编译系统发现一个函数调用：func(实参表)，将根据实参表中的类型，确认是否匹配函数模板中对应的形式参数表，然后生成一个函数。该函数的函数体与函数模板中的函数体相同，而形式参数表的类型则以实参表的实际类型为依据。该函数称为模板函数。 函数模板与模板函数的区别 函数模板是模板的定义，定义中用到通用类型参数； 模板函数是实实在在的函数定义,由编译系统遇见具体的函数调用时生成,具有执行代码。 对上例的说明 编译器从调用abs（ ）时实参的类型，推导出函数模板的类型参数。例如,对于调用表达式abs(n),由于实参n为int类型,所以推导出模板中类型参数T为int。 当编译器发现调用函数模板时，就创建一个模板函数。在上例中，当编译器发现abs(n)调用用时，产生一个如下的函数定义，生成其程序代码： int abs(int x){ return x\u003c0?-x:x; } 当发现abs(d)调用时，产生如下的函数定义，也生成其程序代码： double abs(double x){ return x\u003c0?-x:x; } ","date":"2024-03-21","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A13/:8:3","tags":["面向对象程序设计"],"title":"c++(three)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A13/"},{"categories":["面向对象程序设计"],"content":"函数模板实例化 隐式实例化 #include \u003ciostream\u003e using namespace std; //定义函数模板 template\u003ctypename T\u003e T add(T t1, T t2) { return t1 + t2; } int main() { cout \u003c\u003c add(1, 2) \u003c\u003c endl; //传入int类型参数 cout \u003c\u003c add(1.2, 3.4) \u003c\u003c endl; //传入double类型参数 system(\"pause\"); return 0; } 显式实例化 #include \u003ciostream\u003e using namespace std; template\u003ctypename T\u003e T add(T t1, T t2) { return t1 + t2; } template int add\u003cint\u003e(int t1, int t2); //显式实例化为int类型 int main() { cout \u003c\u003c add\u003cint\u003e(10, 'B') \u003c\u003c endl; //函数模板调用 cout \u003c\u003c add(1.2, 3.4) \u003c\u003c endl; system(\"pause\"); return 0; } ","date":"2024-03-21","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A13/:8:4","tags":["面向对象程序设计"],"title":"c++(three)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A13/"},{"categories":["面向对象程序设计"],"content":"使用函数模板注意事项 函数模板中每一个类型参数在函数参数表中必须至少使用一次 在全局域中声明的模板参数同名对象、函数或类型、在函数模板中将被隐藏。 函数模板中定义声明的对象或类型不能与模板参数同名 模板参数名在同一模板参数表中只能使用一次，但可以在多个函数模板声明或定义之间重复使用。 ","date":"2024-03-21","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A13/:8:5","tags":["面向对象程序设计"],"title":"c++(three)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A13/"},{"categories":["面向对象程序设计"],"content":"使用C++系统函数 模板参数名在同一模板参数表中只能使用一次，但可以在多个函数模板声明或定义之间重复使用。 例如： 求平方根函数(sqrt)，求绝对值函数(abs)等 使用系统函数是要包含相应的头文件 使用函数之前必须先声明函数原型。系统函数的原型存在于不同的头文件中。用#include指令嵌入相应的头文件，就可以使用系统函数。 例如： #include\u003cmath\u003e ","date":"2024-03-21","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A13/:9:0","tags":["面向对象程序设计"],"title":"c++(three)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A13/"},{"categories":["编译原理"],"content":"词法分析 ","date":"2024-03-19","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%863/:0:0","tags":["编译原理"],"title":"编译引论(第三章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%863/"},{"categories":["编译原理"],"content":"词法分析程序的功能 词法分析程序的主要任务是按语言的词法规则从源程序中逐个识别单词，把字符串形式的源程序转换为单词串的形式，并把每个单词转换成他们的内部表示，即所谓的“TOKEN”，同时进行词法检测 词法分析和语法分析之间的关系通常由两种形式 词法分析程序既可作为编译器的独立一遍来完成 也可作为词法分析的一个子程序 ","date":"2024-03-19","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%863/:1:0","tags":["编译原理"],"title":"编译引论(第三章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%863/"},{"categories":["编译原理"],"content":"单词的种类及词法分析的输出 单词符号是一个程序语言的最小语法单位，一般分为5类： 保留字。保留字是由程序语言定义的具有固定意义的标识符。有时称这些标识符为关键字或基本字。例如，Pascal中的begin,end,if,while都是保留字。这些字通常不用作一般标识符 标识符。用来表示各种名字，如变量名，数组名，过程名等 常数。常数的类型一般有整型，实型，布尔型，文字性等。例如，100，3.14159，TRUE，‘Sample’ 运算符。如+，-，*，/等 界符。如逗号，分号，括号，/*，*/等 词法分析器所输出的单词符号通常表示成二元式：(单词类别，单词符号的属性值) 单词类别通常用整数编码。标识符一般统归为一类。常数则宜按类型(整，实，布尔等)分类。关键字可将全体视为一类，也可以一字一类。采用一字一类的分法实际处理起来较为方便。运算符可采用一类的分法，但也可以把具有一定共性的运算符视为一类。至于界符一般用一类的分法 单词符号的属性是指单词符号的特性或特征。属性值则是反应特性或特征的值。例如，对于某个标识符，常将存放它的有关信息的符号表项的指针作为其属性值；对于某个常数，则将存放它的常数表项的指针作为其属性值 ","date":"2024-03-19","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%863/:2:0","tags":["编译原理"],"title":"编译引论(第三章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%863/"},{"categories":["编译原理"],"content":"词法分析的手工设计 ","date":"2024-03-19","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%863/:3:0","tags":["编译原理"],"title":"编译引论(第三章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%863/"},{"categories":["编译原理"],"content":"新程序的输入 利用词法分析器生成器：此时生成器将提供用于源程序字符流的读入和缓冲的若干子程序 利用传统的系统程序设计语言来编写词法分析器：此时要利用该语言所具有的输入/输出能力来处理读入操作 不论扫描缓冲区设得多大都不能保证单词符号不会被它的边界所打断。因此，扫描缓冲区最好是用一个如图所示得一分为二的缓冲区域 ","date":"2024-03-19","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%863/:3:1","tags":["编译原理"],"title":"编译引论(第三章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%863/"},{"categories":["编译原理"],"content":"单词的识别和超前搜索 有些语言(如FORTRAN)对于保留字不加保护，用户可以用它们作为普通标识符，这就使得保留字的识别相当困难。请看下面两条正确的FORTRAN语言语句： DO99K=1,10 DO99K=1.10 若下一个界符是逗号，则可以肯定DO是保留字，否则，DO不构成保留字，它只是用户标识符的头两个字母，因此，为了区别语句1，2，必须超前扫描到等号后的第一个界符处。 标识符的识别 大多数语言的标识符是字母开头的字母和数字组成的串，而且在程序中标识符出现后都跟着算符和界符，因此标识符的识别比较简单 常数的识别 大多数语言算数常数的表示大体相似，对于它们的识别比较直接。但对于某些语言的常数的识别也需要用超前搜索的方法。例如，对于FORTRAN语言的语句： IF(5.EQ.M)I=10 其中，5.EQ.M只有当超前扫描到字母Q时才能断定5的词性。因为5.EO8和5.EQ.M的前三个字符完全一样 算符和界符的识别 词法分析器将那些有多个字符复合成的算符和界符(如C语言中的++)拼合成一个单词符号。因为这些字符串是不可分的整体，若分化开来，便失去了原来的意义。在这里同样需要超前搜索 ","date":"2024-03-19","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%863/:3:2","tags":["编译原理"],"title":"编译引论(第三章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%863/"},{"categories":["编译原理"],"content":"状态转换图 所谓状态转换图，就是一张有穷的有向图。在状态转换图中，结点代表状态，用圆圈表示。状态之间用箭弧连接。箭弧上的标记(字符)代表在射出结点状态下可能出现的合法的输入字符。如图a; 一个状态转换图可用于识别(或接受)一定的字符串，如图b; 如果在状态i时输入字符不为“字母”，则意味着识别不出标识符，或者说这个转换图工作不成功。有如，识别整数的状态转换图如图c所示，其中，i为初态，k为终态。大多数程序语言的单词符号都可以用状态转换图予以识别 注：终态结上打个星号“*”意味着多读进一个不属于标识符部分的字符，应把它退还给输入串 ","date":"2024-03-19","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%863/:3:3","tags":["编译原理"],"title":"编译引论(第三章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%863/"},{"categories":["编译原理"],"content":"词法分析的手工构造 简单语言的单词符号 状态转换图 单词可分为单字符单词和多字符单词。对于单字符的识别比较简单，见字符即知，如=，+，*等，无须多读，无须退回。对于多字符单词的识别比较麻烦，存在多读，退回处理。一个程序设计语言的单词识别，可以用若干张状态转换图予以描述，也可以用一张状态图转换图来描述。 为了把这个例子阐述得更简单，有几点重要限制： 所有保留字(如IF,WHILE等)都是“保留字”，用户不得使用它们作为自己定义的标识符，这样就避免了识别保留字时使用超前搜索技术。例如，DO(2)=x这种写法是绝对禁止的 把保留字作为一类特殊标识符来处理，对保留字不专门设计对应的状态图。把保留字及其类别编码预先安排在一张表格中(即保留字表)。当状态转换图识别出一个标识符时，就去查保留字表，确定是它是否为保留字。 如果保留字，标识符和常数之间没有运算符或界符作间隔时，则必须至少用一个空白符作间隔 在上述限制条件下，多数单词符号的识别就不必使用超前搜索技术。在此，可通过一张状态转换图来识别上图的单词符号，如图所示： 状态转换图的程序实现 用程序实现状态转换图的办法是让每个状态结点对应一段程序 设计一组全局变量，过程和函数 ch：字符变量，存放最新读入的源程序字符 strtoken：字符数组，存放构成单词符号的字符串 Get_char：过程，将下一输出字符读到ch中，搜索指示器前一字符位置 Get_BC：过程，检查ch中的字符是否是空白符，若是，则调用Get_char直到ch中进入一个非空白字符 Concat：过程，将ch中的字符连接到字符数组strtoken之后。如调用Concat之前，strtoken中存放的是“VA”，而ch中存放着“R”，则调用Concat后，strtoken的值就变为“VAR” Retract：过程，将搜索指示器回调一个字符位置，将ch置为空白字符 Letter和Digit：布尔函数，分别用于判断ch中的字符是否为字母和数字 Reserve：整型函数，对字符数组strtoken中的字符串查找保留字表，若它是一个保留字则返回它的编码，否则返回0值(假定0不是保留字的编码) Insert_Id：整型函数，将字符数组strtoken中的标识符插入符号表，返回符号表指针 Insert_Const：整型函数，将字符数组strtoken中的常数插入常数表，返回常数表指针 Error：出错处理 状态转换图的具体实现 一般来说，构造识别状态转换图的程序，可让每个状态节点对应一段程序。具体实现时，可分为不含回路的分叉状态节点和含回路的状态节点来讨论。 对于不含回路的分叉状态结点，可让它对应一个switch语句或一组if…then…else语句 例如，如图所示的不含回路的分叉状态结点的转换图，其状态节点0所对应的程序段可表示为 Get_char(); If(Letter()); {...状态1的对应程序段...;} else if(Digit()) {...状态2的对应程序段...;} else if(ch='_') {...状态3的对应程序段...;} else {...错误处理} 当程序执行达到\"错误处理\"时,意味着现行状态0和当前所面临的输入串不匹配. 对于含有回路的状态结点，可让它对应一个有while语句的if语句构成的程序段。例如，如图所示的按回路的状态节点的转换图，其状态节点0所对应的程序段可为 Get_char(); While(Letter() or Digit()) Get_char(); ...状态1的对应程序段... 对于上图 中的状态c,由于它既是标识符的出口又是保留字的出口，因此，需要对strtoue查询保留字表。这项工作由整型函数过程Reserve来完成。若此过程工作结果所得的值为0，则表示strtoken中的字符串是一个标识符(假定0不是保留字的编码)；否则，表示保留字编码。 综上，如图 所示的状态转换图所对应的词法分析器的主题程序如下： int code,value; strtoken:=\" \"; /*将strtoken初始化为空串*/ Get_char(); Get_BC(); if(Letter()) begin while(Letter() or Digit()) begin Concat(); Get_char(); end Retract(); code:=Reserve(); if(code = 0) begin vaue:=Insert_Id(strtoken); return($ID,value); end else return(code,-); end else if (Digit()) begin while(Digit()) begin Concat(); Get_char(); end Retract(); value:=Insert_Const(strtoken); return($INT,value); end else if(ch='=') return($ASSIGN,-); else if(ch='+') return($PLUS,-); else if(ch='*') begin Get_char(); if(ch='*') return($POWER,-); Retract(); return($STAR,-); end else if(ch=',') return($COMMA,-); else if(ch='(') return($LPAR,-); else if(ch=')') return($RPAR,-); else Error(); /*错误处理*/ ","date":"2024-03-19","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%863/:3:4","tags":["编译原理"],"title":"编译引论(第三章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%863/"},{"categories":["编译原理"],"content":"正规式与正规集 设字母表为$\\sum$，辅助字母表$*\\sum = {\\varepsilon,\\phi,|,\\cdot , * ,( , )}$，下面是正则表达式和它所表示的正规集的递归定义： $\\varepsilon$和$\\phi$都是$\\sum$上的正规式，它们所表示的正规集分别为{$\\varepsilon$}和$\\phi$ ; 任何$a \\in \\sum$,a是$\\sum$ 上的一个正规式，它所表示的正规集为{a}; 假定U和V都是$\\sum$上的正规式，它们所表示的正规集分别记为L(U)和L(V),则： U|V是正规式，它所表示的正规集为L(U)$\\cup$L(V)； U$\\cdot$V是正规式，它所表示的正规集L(U)L(V)(即连接积)。 $U^$是正规式，它所表示的正规集为$(L(U))^$ 仅有有限次使用上述3步骤而得到的表达式才是$\\sum$上的正规式。仅有这些正规式所表示的字符集才是$\\sum$上的正规集 ","date":"2024-03-19","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%863/:4:0","tags":["编译原理"],"title":"编译引论(第三章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%863/"},{"categories":["编译原理"],"content":"有限自动机 ","date":"2024-03-19","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%863/:5:0","tags":["编译原理"],"title":"编译引论(第三章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%863/"},{"categories":["编译原理"],"content":"确定有限自动机 一个确定有限自动机(DFA)M是一个五元式：$M=(S, \\sum ,f,s_0,Z)$ S是一个有限集，它的每个元素称为一个状态 $\\sum$是一个有穷字母表，它的每个元素称为一个输入字符 f是转换函数，是一个从$S \\times \\sum$至S的单值映射，f($S_1$,x)=$S_2$意指：当现行状态为$S_1$,面临的输入符号为x时,将转到下一状态$S_2,S_2$称为$S_1$的一个后继状态； $S_0 \\in S$,它是唯一的一个初态； $Z \\subseteq S$称为终止状态集（可空）。 一个DFA的转换函数可用一个状态转换矩阵或状态转换表来表示，该矩阵的行表示状态$S_i（S_i∈S）$,列表示输入字符$a_j（a_j∈∑）$,矩阵中的元素则是转换函数$ f (S_i , a_j)$的值。 例：已知DFA M=（{A,B,C,D},{x, y}, f ,A,{D}）其中f为： 确定有限自动机识别的符号串 对于Σ上的任意符号串$W ∈Σ^＊$，若存在一条从初态结点到终态结点的路径，该路径上每条箭弧的标记连接成的符号串恰好是W，则称W为DFA $M_D$所识别。 DFA $M_D$所能识别的符号串的全体记为$L(M_D)$,称为$M_D$所识别的语言。 例：已知自动机的状态转换图如下： DFA的确定性 DFA的确定性表现在转换函数f：S×∑→S是一个单值函数。也就是说，对任何状态Si∈S和输入符号a∈∑，f (Si ,a) 唯一地确定了下一状态。从状态转换图的角度来看，假定字母表∑含有n个输入字符，那么，任何一个状态结点最多只有n条弧射出，而且每条箭弧以一个不同的输入字符来标记。如果f是一个多值函数，这就涉及到非确定有限自动机的概念。 ","date":"2024-03-19","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%863/:5:1","tags":["编译原理"],"title":"编译引论(第三章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%863/"},{"categories":["编译原理"],"content":"非确定有限自动机 一个非确定有限自动机(NFA)M是一个五元式：$M=(S, \\sum ,f,S_0,Z)$ S是一个有限集，它的每个元素称为一个状态。 ∑是一个有穷字母表，它的每个元素称为一个输入字符。 f是转换函数，是一个从S×Σ* 到S的子集的映射，即f：S×Σ*→2s $S_0 \\subseteq S$，是一个非空初态集； $Z \\subseteq S$称为终止状态集（可空）。 和确定有限自动机一样，非确定有限自动机也可以用状态转换图和状态转换矩阵来表示。 显然，一个含有m个状态和n个输入字符的NFA可表示成如下的状态转换图：该图含有m个状态结点，每个节点可射出若干条箭弧与别的结点相连接，每条弧用Σ*中的一个字（不一定要不同的字而且可以使空串ε）做标记，整张图至少含有一个初态结点以及若干个（可以是0个）终态结点。某些结点既可以是初态结点也可以是终态结点。 例：已知NFA M=$({0,1,2,3},{a,b}, f , S_0,{3})$其中f为： 非确定有限自动机识别的语言 对于Σ*中的α，若存在一条从某一初态结点到某一终态结点的通路，且这条通路上所有箭弧的标记字依序连接成的字（忽略那些标记为ε的弧）等于α，则称α可为NFA M所识别（即接受）。 NFA M所能识别的所有字的集合称为该自动机识别的语言，记为L(M)。 若M的某些结点既是初态结点又是终态结点，或者存在一条从某个初态结点到某个终态结点的ε通路，那么，空字ε可为M所接受 如图所示的就是一个NFA，该NFA能识别Σ上所有含有相继两个a或相继两个b的字 DFA与NFA的关系 DFA 是NFA的特例，凡是能被DFA接受的符号串必然能被NFA所接受。NFA与DFA的区别在于DFA只有唯一的一个初态， NFA有一个非空初态集（即可以有若干初态）；DFA的转换函数f是一个单值函数，NFA的转换函数f是一个多值函数。 ","date":"2024-03-19","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%863/:5:2","tags":["编译原理"],"title":"编译引论(第三章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%863/"},{"categories":["编译原理"],"content":"词法分析器的自动生成 Lex是一个基于正规式的描述构造词法分析器的工具，也称为Lex编译器，它已经广泛用于产生各种语言的词法分析器。它输入的是用Lex语言编写的源程序，输出的是词法分析的C语言程序。 Lex的流程如下图所示 ","date":"2024-03-19","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%863/:6:0","tags":["编译原理"],"title":"编译引论(第三章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%863/"},{"categories":["编译原理"],"content":"LEX正则约定 ","date":"2024-03-19","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%863/:6:1","tags":["编译原理"],"title":"编译引论(第三章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%863/"},{"categories":["编译原理"],"content":"LEX的元字符约定 ","date":"2024-03-19","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%863/:6:2","tags":["编译原理"],"title":"编译引论(第三章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%863/"},{"categories":["编译原理"],"content":"lex源程序的结构(lex输入文件的格式) 说明部分(辅助定义部分) % % 识别规则部分 % % 辅助程序部分(用户子程序部分) 其中规则部分是必须的，定义和辅助程序部分是任选的。如果没有辅助程序部分，则第二个分隔号%%（双百分号）可以省去；但由于第一个%%用来指示规则部分的开始，故即使没有说明部分，也不能将其省去 说明部分 它是 C 和 Lex 的全局声明。它的作用，在于对规则部分要引用的文件和变量进行说明，通常可包含头文件，常数定义、全局变量定义、正则式定义等。每一个正则式定义由分隔符（适当个数的空格或制表符）连接的正则式的名字和正则式表达式组成,即: $D_i R_i$ 其中，$ D_i$表示正则式的名字，Ri表示正则表达式。除正则式定义以外，定义部分的其余代码须用符号%{和%}括起来，其间可以是包括include语句、声明语句在内的C语句。 %{ int wordCount = 0; int noCount = 0; %} chars [A-za-z] numbers ([0-9])+ words {chars}+ 注意 凡是对已经定义的正则表达式的名字的引用，都必须用花括号将它们括起来。在LEX源程序中，起标识作用的符号%%，%{以及%}都必须处在所在行的最左字符位置。 识别规则部分 识别规则部分起始于“%%”符号，终止于“%%”符号，其间则是词法规则。词法规则由词形和动作两部分组成。即： $ P_i$ {ACTION i} $P_i$词形部分可以由任意的正则表达式组成,ACTION i动作部分是由C语言语句组成，这些语句用来对所匹配的词形进行相应处理。规则部分完全决定了词法分析程序的功能，它只能识别出词形中正则表达式所定义的单词。 例如: %% {words} {wordCount++; /*increase the word count */ } {numbers} {noCount++; /*increase the number count */ } \\n {;} . {;} 辅助程序部分 这部分包含了识别规则部分的动作代码段中所调用的各个局部函数，着写函数由用户用C语言编写的，这样就可以达到简化编程的目的。它们将由LEX系统直接拷贝到输出文件lex.yy.c中。 例如： %% main( ) { yylex(); /* start the analysis*/ printf(\" Count of words:%d\\n\", wordCount); printf(\" Count of nombers:%d\\n\", noCount); } 综合上述几个例子，我们可以编一个字(由字母组成的)和数字（由数字组成）的个数统计的词法分析器了。 LEX输入源程序 %{ int wordCount = 0 ,noCount=0; %} chars [A-za-z] numbers ([0-9])+ words {chars}+ %% {words} {wordCount++; /*increase the word count */ } {numbers} {noCount++; /*increase the number count */ } \\n {; /*do nothing */ } . {; /*do nothing */ } %% main( ) { yylex(); /* start the analysis*/ printf(\" No of words:%d\\n\", wordCount); printf(\" Count of nombers:%d\\n\", noCount); } ","date":"2024-03-19","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%863/:6:3","tags":["编译原理"],"title":"编译引论(第三章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%863/"},{"categories":["编译原理"],"content":"非确定有限自动机的确定化 补充算法 已知NFA $M_N$=(S,Σ,f,$S_0$,Z)，假设与之等价的DFA $M_D$ =(S’,Σ,f’,$S_0’$,Z’)，其中： DFA $M_D$ 的状态集S’就是S的一切子集组成的集合； Σ不变； $S_0’= S_0$ ； S’中含有NFA $M_N$的终态子集就是DFA $M_D$ 的终态的集合Z’； DFA MD转换函数f’的构成：若${p_1,p_2, …,p_k}$是DFA $M_D$的一个状态，则 $f’({p_1,p_2, …,p_k},a)= f(p_1,a) ∪f(p_2,a) ∪ … ∪ f(p_k,a)$ 通过上述步骤，便可得到与NFA $M_N$等价的DFA $M_D$等价，从而得到与之对应的状态转换矩阵和状态转换图。 非确定的有限自动机和确定的有限自动机从功能上来说是等价的，它们所接受的语言类相同。给定任一不确定的有限自动机NFA M，就能构造一个确定的有限自动机DFA M＂，使得L(M)=L（M＂） ","date":"2024-03-19","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%863/:7:0","tags":["编译原理"],"title":"编译引论(第三章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%863/"},{"categories":["编译原理"],"content":"状态集I的ε闭包 假定I是一NFA M的状态集S的一个子集，则ε_closure(I) 称为状态集I的ε闭包，ε闭包也是状态集S的一个子集，其计算方法如下： 若q∈I，则q∈ε_closure(I)，即I的所有成员都是I的ε闭包的成员; 若q∈I，那么从q出发经过任意条ε弧而能到达的任何状态都属于ε_closure (I)。 例：对图所示的NFA M，求I={1}、I={2}、I={1，2}的ε闭包。 解： 当I={1}时，有f(1,ε)=3，f(3,ε) =5，f(3,ε) =4， 则有 ε_closure({1})={1,3,4,5}； 当I={2}, 有f(2,ε)=5， 则有ε_closure({2})={2,5} 当I={1,2}, 则有ε_closure({1,2})=ε_closure({1})∪ε_closure({2}) ={1,3,4,5}∪{2,5} ={1,2,3,4,5} ","date":"2024-03-19","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%863/:7:1","tags":["编译原理"],"title":"编译引论(第三章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%863/"},{"categories":["编译原理"],"content":"状态集I的a弧转换集 假定I是一NFA M的状态集S的一个子集，I={ $P_1, P_2,…,P_n$ }, a∈∑,即a是字母表∑ 的一个输入符号，则P的a弧转换集为： 即J是从状态子集I中的每个状态出发，沿着标记为a的箭弧而转移到达的状态所组成的集合。 从定义可知，状态集I的a弧转换集Ia也是状态子集，其元素为从I的每个状态出发，沿着标记为a的箭弧所转移到达的每个后继状态的ε闭包。 ","date":"2024-03-19","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%863/:7:2","tags":["编译原理"],"title":"编译引论(第三章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%863/"},{"categories":["编译原理"],"content":"非确定有限自动机的确定化方法(子集法) 过程如下： 假定NFA M=(S, Σ, f,S0，Z)，首先对NFA M的状态转换图进行改造： 引进新的初态结点X和终态结点Y（X S,Y S），从X到S0任意状态结点连一条ε箭弧，从Z中任意状态结点连一条ε箭弧到Y 对M的状态转换图进行图所示的替换，其中k是新引入的状态。重复这种分裂过程直至状态转换图中的每条箭弧上的标记或为ε，或为Σ中的单个字母。将最终得到的NFA Mˊ，显然L(Mˊ)=L(M)。 对改造后的NFA Mˊ使用子集法进行确定化 对Σ={a1，…，ak}，构造一张表，该表的每一行含有k+1列。置该表的首行首列为ε_CLOSURE({X})，它就是DFA的唯一初态 如果某一行的第一列的状态子集已经确定，如记为I，那么，置该行的i+1列为Iai（i=1，….，k）。然后，检查该行上的所有状态子集，看它们是否已在表的第一列中出现，将未曾出现者填入到后面空行的第一列。重复上述过程，直至出现在第i+1列（i=1，…，k）上的所有状态子集均已在第一列上出现。 **将构造出来的表视为状态转换矩阵，将其中的每个状态子集视为新的状态，就得到了一个DFA M＂。它的初态是该表首行首列的那个状态，终态是那些含有原来NFA M的任一终态的状态子集。 ** 例：已知有非确定的有限自动机NFA M，具体如图所示，利用子集法将它确定化。 解： 改造状态转换图，引进新的初态结点X和终态结点Y，得到新的状态转换图如图所示。 构造状态转换矩阵，因为f(X,ε)=0，f(0,ε) =1，所以ε_CLOSURE(X) ={X ,0,1}，根据子集法可构造出所有状态子集，具体见表3.5。对表3.5中的所有状态子集重新命名，得到表3.6所列的状态转换矩阵。 与表3.6相对应的状态转换图如图3.17所示，其中0为初态，3﹑4﹑5和6为终态。显然，图3.15和图3.17所示的有限自动机是等价的。 ","date":"2024-03-19","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%863/:7:3","tags":["编译原理"],"title":"编译引论(第三章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%863/"},{"categories":["编译原理"],"content":"确定有限自动机的化简 确定有限自动机DFA M的化简是指：寻找一个状态数比M少的DFA Mˊ，使得L(M)=L(Mˊ)。化简的方法就是消除DFA M中的无关状态，合并等价状态。 通常把无用状态和死状态统称为无关状态。 所谓无用状态，就是指从初态出发，读入何输入串都不可能到达的状态； 所谓死状态，就是对于任何输入符号，该状态的后继状态都是它自身，而不可能从它到达终态。 如图所示的状态转换图中，状态1是无用状态，状态2是死状态，状态1、2均为无用状态 DFA M的状态最小化过程的核心思想：将DFA M的状态集分割成一些不相交的子集，使得任何不同的两子集中的状态都是可区别的，而同一子集中的任何两个状态都是等价的。最后，在每个字集中选出一个代表，同时消去其它等价状态。 具体过程如下： 把DFA M的所有状态集S分成两个子集——终态集与非终态集，形成基本分划∏。显然，属于这两个不同子集的状态是可区别的。 对各状态子集按下面的方法进一步划分 假定经过第i次划分后，∏={$S_1,S_2,….,S_m$}，其中的任何一个都是状态子集。对于任意一个状态子集Sj={$q_1,q_2,….,q_k$}，若存在一个输入字符a∈Σ，使得($S_j$)a（即将子集Sj的所有状态读入a所到达的状态的集合）不全包含在现行∏的某一子集中，就将$S_j$一分为二。 经上述过程之后，得到一个最后分划∏。对于∏中的每一个子集，选取子集中的一个状态代表其他状态，删除其他一切的等价状态。例如，假定∏中有子集$S_j={q_1，…，q_k}$，则可将$q_2，…，q_k$从原来的状态集中删除。若$S_j$中含有原来的初态，则$q_1$是新初态；若$S_j$中含有原来的终态，则$q_1$是新终态。 通过上述步骤进行化简后，再删除所有的无关状态，便可以得到最简的DFA M 例：已知有图所示的DFA M，试写出其最小化过程。 解： 首先，把DFA M的状态分成两个子集：终态集{3,4,5,6}，非终态集{0,1,2}，即S={3,4,5,6}∪{0,1,2}。 其次，考察子集{3,4,5,6}，由于{3,4,5,6}a={3,6}  {3,4,5,6}和{3,4,5,6}b={4,5}  {3,4,5,6}，所以，它不能再分划。 再考察{0,1,2}，由于{0,1,2}a={1,3}，它既不包含在{3,4,5,6}之中也不包含在{0,1,2}之中，因此，应把{0,1,2}一分为二。由于状态1经a箭弧到达状态3，而状态0和2经a箭弧都能到达状态1，因此，应把1分出来，形成{1}，{0,2}。 现在，整个状态集划分成三个子集，即S={3,4,5,6}∪{1}∪{0,2}。 由于{0,2}b={2,5}未包含在上述三个子集中的任何一个子集之中，故{0,2}也应一分为二：{0}，{2}。 至此，整个划分结束，状态集分成四个子集，即S={3,4,5,6}∪{0}∪{1}∪{2}，且每个子集都已不可再分。 ","date":"2024-03-19","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%863/:7:4","tags":["编译原理"],"title":"编译引论(第三章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%863/"},{"categories":["编译原理"],"content":"正规文法与有限自动机的等价性 一个正规集可以由正则文法产生，也可以用有限自动机来识别，对于正规文法G和有限自动机M，如果L（G）=L(M)，则称G和M是等价的。对于正规文法和有限自动机的等价性，有以下两个结论： 对任一正规文法G（$G_R$右线性文法和左线性文法$G_L$），都存在一个有限自动机（FA）M，使得$L(M)= L(G_R)=L(G_L)$。 对任一有限自动机FAM，都存在一个正规文法（$G_R$右线性文法和左线性文法$G_L$），使得$L(M)=L(G_R)=L(G_L)$。 ","date":"2024-03-19","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%863/:8:0","tags":["编译原理"],"title":"编译引论(第三章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%863/"},{"categories":["编译原理"],"content":"右线性文法→有限自动机 设右线性文法$G_R=(V_T,V_N, P,S)$，$NFA为（S,Σ, f,S_0,Z）$。根据右线性文法的四个部分求NFA的五个部分。 文法$G_R$的开始符号S就是NFA的初态； 文法$G_R$的$V_T$就是NFA的输入字母表Σ； 为NFA引入一个终态符号Z’，$Z \\notin V_N$，则NFA的终态集Z={Z’}； 文法GR的$V_N∪{Z’}$构成NFA的状态集S； 利用文法$G_R$的产生式集P来构成NFA的转换函数f，具体方法如下： 若对于某个$A∈V_N$及$a∈V_T∪{ε}$，P中产生式A→a，则令 f（A，a）=Z’。 对任意的$A∈V_N及a∈V_T∪{ε}$，设P中左端为A，右端第一符号为a的所有产生式为：$A→aA_1|….|aA_k$（不包括A→a），则令 $f(A,a)={A_1，…，A_k}$。 例：已知$G_R[A]＝（{A,B,C,D}，{0,1}，A，P）$，其中产生式集P为： ","date":"2024-03-19","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%863/:8:1","tags":["编译原理"],"title":"编译引论(第三章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%863/"},{"categories":["编译原理"],"content":"有限自动机→右线性文法 有限自动机转换成右线性文法，需要满足一个条件：有限自动机只有一个初态结，且终态结没有非 $ \\varepsilon $ _弧射入。 如果不满足,则须进行改造。具体工作如下: 如果M有多个初态结,则引入一个新的初态结,并从新的初态结引一_弧到原初态结,原初态结则不再作初态。 如果M的终态结有射入弧,则引入一新的终态,并从原来的任意终态结引一$\\varepsilon$_弧到新终态结,原终态结则不再作终态 构造过程: 有限自动机M的输入字母表Σ就是文法G的终结符号集$V_T$; 初态结就是文法G的开始符号S;文法G的产生式集P由M的转换函数f得到: 若f(A,a)=B,则A→aB 若f(A,a)=Z’,其中Z’∈Z,则A→a M的终态不会出现在文法的产生式中,所以$V_N$为M的状态集S去掉终态集Z中的状态构成,即$V_N=S-Z$。 例： 将下图有限自动机转换成右线性文法： 右线性文法$G[S]=(V_N,V_T,P,S)$，其中$V_N ={S,S_1,S_2,A,B}$ , $V_T ={a,b,c}$,P由下列规则组成: $S →S_1∣S_2$ $S_1→aA$ $S_2→cA$ $A →aA∣ bB ∣ \\varepsilon$ $B →bB∣ aB ∣ \\varepsilon $ ","date":"2024-03-19","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%863/:8:2","tags":["编译原理"],"title":"编译引论(第三章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%863/"},{"categories":["编译原理"],"content":"左线性文法→有限性自动机 设左线性文法$GL=(V_T,V_N,P,S)$，$NFA为（S,Σ, f,S_0,Z）$。根据右线性文法的四个部分求NFA的五个部分。 文法$G_L$的开始符号S就是NFA的终态； 文法$G_L$的$V_T$就是NFA的输入字母表Σ； 为NFA引入一个初态S’，$S’ \\notin VN$，则NFA的初态集$S_0 ={S’}$； 文法$G_L$的$V_N∪{S’}$构成M的状态集S； 利用文法$G_L$的产生式集P来构成NFA的转换函数f，具体方法如下： 若对某个$A∈V_N及a ∈V_T∪{ε}$，P中有产生式A→a，则令 f（S’,a）=A。 对任意的$A∈V_N$及$a ∈V_T∪{ε}$，若P中所有右端第一符号为A，第二个符号为a的产生式为：$A_1→A_a|，….，A_k→Aa$，则令 $f（A，a）={A_1，….，A_k}$。 例： 已知有左线性文法G[S]: S→Sa | Aa|Bb A→Ba | a B→Ab| b 试构造与文法G[S]等价的有限自动机。 解：按照左线性文法到有限自动机的转换方法，为有限自动机引入一个初态S’；因为文法G[S]的开始符号S作为有限自动机的终态（设该终态为Z’），为了方便设计，避免混淆现将所有产生式中的S替换成Z。 ","date":"2024-03-19","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%863/:8:3","tags":["编译原理"],"title":"编译引论(第三章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%863/"},{"categories":["编译原理"],"content":"有限自动机→左线性文法 有限自动机转换成左线性文法，需要满足一个条件：有限自动机只有一个终态结,且初态结没有非$\\varepsilon _$弧射入 如果它不满足，则须对进行改造，具体工作如下：如果NFA M有多个终态结，则引入一个新的终态结，并从原来的终态结各引_弧到新的终态结（原终态结则不再作终态）。如果NFA M的初态结有射入弧，则引入一新的初态，并从该初态结各引一_弧到原初态结（原初态结则不再作初态） 一般的，改造后的非确定有限自动机$NFA M=（S,Σ, f,S_0，Z）$，由它构造左线性文法$G_L=( V_N,V_T, P, S)$的方法是： NFA M的输入字母表Σ就是文法$G_L$的终结符号集$V_T$； NFA M的唯一终态结就是文法$G_L$的开始符号； 文法$G_L$的产生式集P由NFA M的转换函数f得到，具体方法是： 若f(A,a)=B，则B→Aa∈P； 若f(S’,a)=B，其中S’∈$S_0$，则B→a∈P； 显然，NFA M的初态不会出现在文法的产生式中，所以$V_N$为NFA M的状态集S去掉初态集$S_0$中的状态构成，即$V_N=S-S_0$。 例： 将上图的有限自动机转换成与之等价的左线性文法 解：按照有限自动机到左线性文法的转换方法，由于该有限自动机有多个终态，则引入一新终Z，则改造后的有限自动机如图所示 按上述方法，与该自动机相应的左线性文法为$G[Z]=( V_N, V_T,P,Z)$，其中，Z 是文法开始符号，$V_N ={Z,A,B}, V_T ={a,b,c}$，P的规则如下： **Z→A | B ** ​ A→Aa | a | c ​ **B→Ba |Bb| Ab ** ","date":"2024-03-19","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%863/:8:4","tags":["编译原理"],"title":"编译引论(第三章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%863/"},{"categories":["编译原理"],"content":"正则表达式与有限自动机的等价性 有限自动机→正则表达式，具体步骤如下： 首先拓广转换图的概念，允许每条箭弧用正则表达式作标记。 在FA M的转换图上加进一个初态结X和一个终态结Y，从初态结X用弧连接到M的所有初态结；从M的所有终态结用弧连接到Y结； 反复用替换规则，对自动机进行消弧，直到只剩下一个初态X,一个终态Y，和一条箭弧为止，则箭弧上的标记的正则表达式就是所求的e。 例： 已知有一个非确定的有限自动机NFA M如图3.29所示，试转换出与之等价的正规式 解：按照有限自动机到正规式的转换方法，首先引入一个初态X和一个终态Y，得到如图所示的状态转换图。 ","date":"2024-03-19","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%863/:8:5","tags":["编译原理"],"title":"编译引论(第三章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%863/"},{"categories":["编译原理"],"content":"正则表达式e→有限自动机FA M 具体步骤如下： 先构造一个FA M的一个广义转换图，其中，只有X与Y两个状态，X是初态，Y是终态，弧上是正规表达式e。 然后，按照替换规则对正规表达式e逐步进行分解，直到转换图中所有的弧上都是中的单个符号或$\\varepsilon$为止。 例： 构造与正规式$ (a|b)^(aa|bb)(a|b)^$ 等价的非确定的有限自动机 注：第1，2步骤中的$ (a|b)^(aa|bb)^(a|b)^$和$(aa|bb)^$要改为$ (a|b)^(aa|bb)(a|b)^$和$(aa|bb)$ ","date":"2024-03-19","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%863/:9:0","tags":["编译原理"],"title":"编译引论(第三章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%863/"},{"categories":["计算机组成原理"],"content":"数据与文字的表示方法 ","date":"2024-03-16","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%862/:0:0","tags":["计算机组成原理"],"title":"计算机组成(第二章)","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%862/"},{"categories":["计算机组成原理"],"content":"数据格式 ","date":"2024-03-16","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%862/:1:0","tags":["计算机组成原理"],"title":"计算机组成(第二章)","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%862/"},{"categories":["计算机组成原理"],"content":"分类 符号数据：非数字符号的表示(ASCII,汉字，图形等) 数值数据：数字数据的表示方式(定点，浮点) 计算机数字和字符的表示方法有利于数据的存储，加工(处理)，传送 ","date":"2024-03-16","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%862/:1:1","tags":["计算机组成原理"],"title":"计算机组成(第二章)","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%862/"},{"categories":["计算机组成原理"],"content":"编码 用少量，简单的基本符号，选择合适的规则表示尽量多的信息，同时利于信息处理(速度，方便) ","date":"2024-03-16","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%862/:1:2","tags":["计算机组成原理"],"title":"计算机组成(第二章)","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%862/"},{"categories":["计算机组成原理"],"content":"数值数据 计算机在数据，文字的表示方式时，应该考虑以下几个因素 表示的数据类型(符号，小数点，数值) 数值的范围 数值精度 存储，处理，传送的硬件代价 ","date":"2024-03-16","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%862/:2:0","tags":["计算机组成原理"],"title":"计算机组成(第二章)","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%862/"},{"categories":["计算机组成原理"],"content":"常用的表示方法 ","date":"2024-03-16","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%862/:3:0","tags":["计算机组成原理"],"title":"计算机组成(第二章)","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%862/"},{"categories":["计算机组成原理"],"content":"定点表示法 所有数据的小数点位置固定不变 理论上位置可以任意，但实际上将数据表示有两种方法(小数点位置固定—定点表示法/定点格式) 纯小数 纯整数 定点数表示 带符号数 不带符号数 定点纯整数 表示数的范围是 $0\\leqslant|x|\\leqslant 2^n-1$ 定点表示法的特点 定点数表示数的范围受字长限制，表示数的范围有限 定点表示的精度有限 机器中，常用定点纯整数表示 ","date":"2024-03-16","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%862/:3:1","tags":["计算机组成原理"],"title":"计算机组成(第二章)","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%862/"},{"categories":["计算机组成原理"],"content":"浮点表示 小数点位置随阶码不同而浮动 格式 $N=R^E.M$ 基数R，取固定的值，比如10.2等；指数E；尾数M； 机器中表示 ","date":"2024-03-16","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%862/:3:2","tags":["计算机组成原理"],"title":"计算机组成(第二章)","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%862/"},{"categories":["计算机组成原理"],"content":"IEEE754标准(规定了浮点数的表示规格，运算规则等) 规则规定了单精度(32)和双精度(64)的基本格式 规则中，尾数用原码，指数用移码(便于对阶和比较) 基数R=2，基数固定，采用隐含方式来表示它 32位的浮点数 S是数的符号位，1位，在最高位，“0”表示正数，“1”表示负数。 M是尾数，23位，在低位部分，采用纯小数表示 E是阶码，8位，采用移码表示。移码比较大小方便 指数偏移，127 64位的浮点数 符号位1位，阶码域11位，尾数域52位，指数偏移值是1023. 因此规格化的64位浮点数x的真值为： $x=(-1)^S\\times(1.M)\\times2^{E-1023}$ e=E-1023 一个规格化的32位浮点数x的真值表示为： $x=(-1)^S\\times(1.M)\\times2^{E-127}$ e=E-127 例题： ","date":"2024-03-16","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%862/:3:3","tags":["计算机组成原理"],"title":"计算机组成(第二章)","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%862/"},{"categories":["计算机组成原理"],"content":"数的机器码表示 ","date":"2024-03-16","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%862/:4:0","tags":["计算机组成原理"],"title":"计算机组成(第二章)","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%862/"},{"categories":["计算机组成原理"],"content":"数的机器码表示 真值：一般书写的数 机器码：机器中表示的数，要解决在计算机内部数的正，负符号和小数点的运算问题 原码，反码，补码，移码 ","date":"2024-03-16","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%862/:4:1","tags":["计算机组成原理"],"title":"计算机组成(第二章)","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%862/"},{"categories":["计算机组成原理"],"content":"原码表示法 原码特点 将真值的正负号换成1和0，表示简单，易于同真值之间进行转换 实现乘除运算规则简单 进行加减运算十分麻烦，做减法无法求解正确结果…… ","date":"2024-03-16","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%862/:4:2","tags":["计算机组成原理"],"title":"计算机组成(第二章)","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%862/"},{"categories":["计算机组成原理"],"content":"反码表示法 定义 正数的表示与原，补码相同，负数的补码符号位为1，数值位是将原码的数值按位取反，就得到该数的反码表示 电路容易实现，触发器的输出有正负之分 ","date":"2024-03-16","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%862/:4:3","tags":["计算机组成原理"],"title":"计算机组成(第二章)","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%862/"},{"categories":["计算机组成原理"],"content":"补码表示法 补码是在“模”和“同余”的概念下导出的(“模\"是指一个计量单位的计量系统的计量范围，即产生“溢出”的量。) 定义 正数的补码就是正数本身，负数的补码是原负数加上模。 计算机运算受字长限制，属于有模运算 定点小数$x_0x_1x_2……x_n$溢出量为2，以2为模(周期) 定点整数$x_0x_1x_2……x_n$溢出量为$2^{n+1}$，以$2{n+1}$为模(周期) 定点小数$x_0x_1x_2……x_n$ $[x]_补=\\begin{cases}x,1\u003ex\\geq-1\\2+x,0\\geq x \\geq -1\\end{cases}$ $符号\\begin{cases}0,正数\\1,负数\\end{cases}$ 补码性质 高位表示正负 正数补码，尾数与原码相同 范围$-2^n\\sim2^n-1$(定点正数) 无正负0之分 变形补码(双符号补码) 为了防止溢出而设定 结论 若运算结果超出了计算机所能表示的数值范围，则只保留它的小于模的低n位的数值，超过n位的高位部分就自动舍弃了。 ","date":"2024-03-16","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%862/:4:4","tags":["计算机组成原理"],"title":"计算机组成(第二章)","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%862/"},{"categories":["计算机组成原理"],"content":"移码表示法(用在阶码中) 定点整数定义：$[x]_移=2^n+x$ ($2^n\u003ex\\geq-2^n$) 00000000~11111111($-2^n\\sim 2^n-1$) 例： 特点 移码和补码尾数相同，符号位相反 范围 $-2^n\\sim 2^n-1$ 例：以定点整数为例，用数轴形式说明原码，反码，补码表示范围和可能的数码组合情况 例：将十进制真值(-127,-1,0,+1,+127)列表表示成二进制数及原码，反码，补码，移码值(要求8位) ","date":"2024-03-16","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%862/:4:5","tags":["计算机组成原理"],"title":"计算机组成(第二章)","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%862/"},{"categories":["计算机组成原理"],"content":"字符和字符串(非数值)的表示方法 符号数据：字符信息用数据表示，如ASCII等 常见的ASCII码用七位二进制表示一个字符，它包括10个十进制数字(0~9)，52个英文大写和小写字母(a ~ z,A~Z)，34个专用符号和32个控制符号，共计128个字符 字符表示方法ASCII：用一个字节表示，低7位用来编码(128)，最高位位校验位 字符串的存放方法：向量存放法 在存储器中占用一片连续的空间，每个字节存放一个字符代码，字符串的所有元素(字符)在物理上是相邻的。 ","date":"2024-03-16","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%862/:5:0","tags":["计算机组成原理"],"title":"计算机组成(第二章)","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%862/"},{"categories":["计算机组成原理"],"content":"奇偶校验概念 奇偶校验码是一种最简单的数据校验码，它的码距等于2，可以检测出一位错误(或奇数位错误)，但不能确定出错的位置，也不能检测出偶数位错误 码距：将两个码字逐位进行对比，具有不同的位的个数，例如01和10，码距为2 奇偶校验实现方法是：有若干为有效信息(如一个字节)，再加上一个二进制位(校验位)组成检验码 ","date":"2024-03-16","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%862/:6:0","tags":["计算机组成原理"],"title":"计算机组成(第二章)","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%862/"},{"categories":["计算机组成原理"],"content":"CRC循环冗余校验 循环冗余校验码 与奇偶校验码一样只能检错不能纠错 应用于数据通信领域和磁介质存储系统中 利用多项式校验 步骤： K=信息码的长度，R=生成多项式最高次幂-\u003e校验码位数N=K+R 生成多项式$G(x)=ax3+bx2+cx1+dx0$，对应二进制码abcd，即为模2除法的除数 信息码左移R位，利用模2除法(上商规则:最高位为1则商1，最高位为0则商0，减法规则：对应位上相同，结果为0，不同，结果为1)，产生余数，将余数补在信息码后形成CRC码，余数某位是1，则该位出错。 ","date":"2024-03-16","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%862/:7:0","tags":["计算机组成原理"],"title":"计算机组成(第二章)","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%862/"},{"categories":["计算机组成原理"],"content":"定点加法，减法运算 ","date":"2024-03-16","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%862/:8:0","tags":["计算机组成原理"],"title":"计算机组成(第二章)","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%862/"},{"categories":["计算机组成原理"],"content":"补码加减法 公式：$[x+y]_补=[x]_补+[y]_补$ 补码减法： 为了将减法转变为加法，需证明公式：$[x-y]_补=[x]_补+[-y]_补$ 证明： $[X]_补+[Y]_补=[X+Y]_补$证明 假设|x|\u003c1,|y|\u003c1,|x+y|\u003c1 现在分四种情况来证明 使用补码加减法求解下列题目 ","date":"2024-03-16","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%862/:8:1","tags":["计算机组成原理"],"title":"计算机组成(第二章)","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%862/"},{"categories":["计算机组成原理"],"content":"溢出的检测 检测方法 双符号位法(参与加减运算的数采用变形补码表示) 单符号位法 ","date":"2024-03-16","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%862/:9:0","tags":["计算机组成原理"],"title":"计算机组成(第二章)","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%862/"},{"categories":["计算机组成原理"],"content":"基本的加法器 半加器 $H_i=A_i\\bigoplus B_i$ 不考虑进位 全加器 考虑低位进位$C_{i-1}$和向高位的进位$C_i$ ","date":"2024-03-16","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%862/:10:0","tags":["计算机组成原理"],"title":"计算机组成(第二章)","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%862/"},{"categories":["计算机组成原理"],"content":"各种逻辑的图形符号 ","date":"2024-03-16","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%862/:10:1","tags":["计算机组成原理"],"title":"计算机组成(第二章)","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%862/"},{"categories":["计算机组成原理"],"content":"串行加法器 将n个全加器相连可得n位加法器，但其加法时间较长。这是因为其位间进位是串行传送的，本位全加和$F_i$必须等低位进位$C_{i-1}$来到后才能进行，加法时间与位数有关 只有改变进位逐位传送的路径，才能提高加法器工作速度 解决办法之一是采用“超前进位产生电路”来同时形成各位进位，从而实现快速加法，我们称这种加法器为超前进位加法器 ","date":"2024-03-16","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%862/:10:2","tags":["计算机组成原理"],"title":"计算机组成(第二章)","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%862/"},{"categories":["计算机组成原理"],"content":"定点乘法运算 乘法实现方法 在现有的加法和减法器的基础上增加适当的以为线路及控制逻辑可以实现 用LSI和VLSI工艺实现专用的乘法器 编制子程序(单片机等低端机器) 原理 尾数乘法如下： ","date":"2024-03-16","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%862/:11:0","tags":["计算机组成原理"],"title":"计算机组成(第二章)","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%862/"},{"categories":["计算机组成原理"],"content":"定点原码乘法原理 n位乘n位积可能为2n位 乘积的最后是所有部分积之和，有n个数相加，而FA只有两个输入端 所以需要改造 方法一：硬件实现方法(串行的“加法和移位”)，硬件结构简单，速度太慢(时间延迟太长) 方法二：不带符号位的阵列乘法器 ","date":"2024-03-16","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%862/:11:1","tags":["计算机组成原理"],"title":"计算机组成(第二章)","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%862/"},{"categories":["计算机组成原理"],"content":"由手工计算到机器运算 由手工计算到机器运算，需要解决3个问题： 符号如何让处理 多个部分积如何相加 为保持两次部分积之间的位权对应关系，会导致加法器位数的增加，能否在不增加位数的情况下保持位权对应？ 由于解决方式的不同，形成了两种主要的乘法器结构 采用常规的加法器来实现 将n位乘法转换为n次累加和移位，每次处理1位 为避免加法器位数的扩充，可以把手工计算时的新部分积“左移-\u003e累加”改为机器运算的原部分积“累加-\u003e右移” 采用阵列乘法器实现 利用中大规模集成电路把多项部分积同时相加，这样结构的乘法器称为阵列乘法器 ","date":"2024-03-16","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%862/:11:2","tags":["计算机组成原理"],"title":"计算机组成(第二章)","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%862/"},{"categories":["计算机组成原理"],"content":"原码一位乘法 原码一位乘法是从手算演变而来的，即用两个操作数的绝对值相乘，乘积的符号为两操作数符号的异或值(同号为正，异号为负) 乘积P=|X|$\\times$|Y| 符号$P_s=X_s\\bigoplus Y_s$ 式中：$P_s$为乘积的符号，$X_s$和$Y_s$为被乘数和乘数的符号 规则 参加运算的操作数取其绝对值 令乘数的最低位为判断位，若为\"1”，加被乘数，若为“0”，不加被乘数(加0)； 累加后的部分积以及乘数右移一位 重复n次(2)和(3) 符号位单独处理，同号为正，异号为负。 基本过程 每次将一位乘数所对应的部分积与原部分积的累加和相加并移位 设置寄存器： A：存放部分累加和，乘积高位，格式为双符号位 B：存放被乘数，格式为双符号位 C：存放乘数，乘积低位，格式为无符号位 设置初值： A=00.0000 B=|X|=00.1101 C=|Y|= .1011 操作步骤 ","date":"2024-03-16","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%862/:11:3","tags":["计算机组成原理"],"title":"计算机组成(第二章)","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%862/"},{"categories":["计算机组成原理"],"content":"算法流程 ","date":"2024-03-16","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%862/:11:4","tags":["计算机组成原理"],"title":"计算机组成(第二章)","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%862/"},{"categories":["计算机组成原理"],"content":"原码一位乘法的硬件实现 A,B为n+2位，C为n位，加法器为n+2位，异或门 A,C寄存器级连在一起，具有右移功能。每次移位时，A的最低位进入C的最高位，而C的最低位被丢掉。最后，A的内容为乘积的高位部分，C的内容为乘积的低位部分 C的最低位作为控制信号，控制运算器加被乘数还是加0； 说明 原码乘法虽然容易实现，但一般计算机中数据多以补码表示。若仍用原码做乘法，需要进行码制转换，反倒不方便而且又影响速度。 因为补码符号位直接参加运算，所以补码乘法不能简单地套用原码乘法的算法。实现补码乘法有2种方法。 一种方法为校正法，使用较少，只给出算式： $[X \\times Y]_补=[X]_补 \\times (O.X_1X_2…X_n)-[X_补] \\times Y_0$ 另一种更好的方法为比较法，该算法是英国人Booth夫妇提出，所以也称为Booth法。该算法无需校正，控制较为简单。以下主要讨论比较法。 ","date":"2024-03-16","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%862/:11:5","tags":["计算机组成原理"],"title":"计算机组成(第二章)","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%862/"},{"categories":["计算机组成原理"],"content":"补码一位乘法 算法分析 $X_补 = X_0.X_1X_2….._n$ Y为正：$Y_补 = 0.Y_1Y_2….Y_n$ $(XY)_补 = X_补(0.Y_1Y_2….Y_n)$ Y为负：$Y_补=1.Y_1Y_2….Y_n$ $(XY)_补 = X_补(0.Y_1Y_2…..Y_n)+(-X)_补$ Y符号任意： $(XY)_补 = X_补(0.Y_1Y_2…..Y_n)+(-X)_补Y_0$(符号位$Y_0$) ","date":"2024-03-16","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%862/:12:0","tags":["计算机组成原理"],"title":"计算机组成(第二章)","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%862/"},{"categories":["计算机组成原理"],"content":"比较法(BOOTH乘法) 递推公式 $[Z_0]_补 = 0$ $[Z_1]_补 = 2^{-1}{[Z_0]_补+(Y_n+1-Y_n)[X_补]}$ $[Z_2]_补 = 2^{-1}{[Z_1]补+(Y_n-Y{n-1})[X_补]}$ . .. … $[Z_n]_补 = 2^{-1}{[Z_n-1]_补+(Y_2-Y_1)[X_补]}$ $\\therefore [X \\times Y]_补 = [Z_n]_补 +(Y_1-Y_s)[X_补]$ 式中，$[Z_0]$为初始部分积，$[Z_1]_补$~$[Z_n]_补$依次为各次求得的累加并右移之后的部分积 ","date":"2024-03-16","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%862/:12:1","tags":["计算机组成原理"],"title":"计算机组成(第二章)","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%862/"},{"categories":["计算机组成原理"],"content":"BOOTH乘法规则 参与运算的数用补码表示 符号为参加运算 乘数最低位后面增加一位附加位$Y_{n+1}$其初值为0 由于每求一次部分积要右移一位，所以乘数的最低两位$Y_n$、$Y_{n+1}$的值决定了每次应执行的操作； 移位按补码右移规则进行 共需做n+1次累加，n次移位，第n+1次不移位 比较法算法 运算实例 X=-0.1101,Y=-0.1011.求$(XY)_补$ 初值：A=00.0000,B=$X_补$=11.0011， -B=$(-X)_补$=00.1101,C=$Y_补$=1.0101 A,B取双符号位，符号参加运算 C取单符号位，符号参加移位，以决定最后是否修正 ","date":"2024-03-16","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%862/:12:2","tags":["计算机组成原理"],"title":"计算机组成(第二章)","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%862/"},{"categories":["计算机组成原理"],"content":"补码一位乘法的硬件实现 A,B,C为n+2位，加法器为n+2位 与或门有n+2个 各器件的作用与原码一位乘法相同。控制方式上有所不同，即由C寄存器的最低两位来控制加、减被乘数或加0操作。 ","date":"2024-03-16","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%862/:12:3","tags":["计算机组成原理"],"title":"计算机组成(第二章)","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%862/"},{"categories":["计算机组成原理"],"content":"阵列乘法器 ","date":"2024-03-16","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%862/:13:0","tags":["计算机组成原理"],"title":"计算机组成(第二章)","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%862/"},{"categories":["计算机组成原理"],"content":"不带符号的阵列乘法器 ","date":"2024-03-16","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%862/:13:1","tags":["计算机组成原理"],"title":"计算机组成(第二章)","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%862/"},{"categories":["计算机组成原理"],"content":"带符号位的阵列乘法器 求补电路 原理：算前求补—乘法器—算后求补，见下图 小结 E=0时，输入和输出相等 E=1时，则从数最右端往左边扫描，直到第一个1的时候，该位和右边各位保持不变$0 \\bigoplus A = A$,左边各数值位按位取反$1 \\bigoplus A = \\ 乛A$ 可以用符号作为E的输入 原：1.11110，补：1.00010(不变，左边数值位取反) 时间延迟分析：转换n+1位带符号的时间延迟为$t=n2T+5T$，其中n2T为或门延迟时间，5T为最高位与门和异或门的时延。 带符号位的阵列乘法器(间接法) ","date":"2024-03-16","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%862/:13:2","tags":["计算机组成原理"],"title":"计算机组成(第二章)","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%862/"},{"categories":["计算机组成原理"],"content":"定点除法运算 除法—\u003e若干余数与除数加减，移位 例：$0.10110 \\div 0.11111$ 实现出发的关键：比较余数，除数绝对值大小，以决定上商 除法运算是乘法运算的逆运算。乘法通过加-右移实现，不难想到机器除法运算是通过减-左移实现的。 机器实现除法运算有两个先决条件(纯小数) 除数不等于0，否则商为无穷大 被除数要小余除数，否则商会溢出 ","date":"2024-03-16","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%862/:14:0","tags":["计算机组成原理"],"title":"计算机组成(第二章)","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%862/"},{"categories":["计算机组成原理"],"content":"原码恢复余数法 算法 比较两数大小可用减法试探 实例 X=-0.10110，Y=0.11111，求X/Y，给出商Q和余数R 设置：A：被除数，余数，B：除数。C：商 初值： $A=|X|=00.10110$ $B=|Y|=00.11111$,$-B=11.00001$ $C=|Q|=0.00000$ 说明 A,B双符号位。X,Y绝对值，|X|小于|Y| 运算结束后，余数乘以$2^{-n}$，与被除数同号 ","date":"2024-03-16","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%862/:15:0","tags":["计算机组成原理"],"title":"计算机组成(第二章)","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%862/"},{"categories":["计算机组成原理"],"content":"原码不恢复余数法(加减交替法) 算法分析 算法 $r_{i+1}=2r_i+(1-2Q_i)Y$ $r_i$为正，则$Q_i$为1，第i+1步作$2r_i-Y$ $r_i$为负，则$Q_i$为0，第i+1步作$2r_i+Y$ 实例 X=0.10110,Y=-0.11111,求X/Y，给出商Q和余数R 初值： A=|X|=00.10110 B=|Y|=00.11111,-B=11.00001 C=|Q|=0.00000 运算规则 A,B取双符号位，X,Y取绝对值运算，|X|\u003c|Y| 根据余数的政府决定商值及下一步操作 求n位商，作n步操作；若第n步余数为负，则第n+1步恢复余数，不移位 原码不恢复余数法的硬件实现 A、B寄存器，n+2位，C寄存器，n+1位，加法器，n+2位 ，与或门，n+2个 A、C寄存器级连在一起，具有左移一位功能。每次移位时，C的最高位进入A的最低位，而C的最低位用来保存每次运算得到的商。A的初值为被除数，最后变为余数，C的内容为除法得到的商。 在运算过程中，由余数的符号决定商值和下一步操作，即控制运算器加除数还是减除数。 ","date":"2024-03-16","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%862/:16:0","tags":["计算机组成原理"],"title":"计算机组成(第二章)","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%862/"},{"categories":["计算机组成原理"],"content":"阵列除法器 同乘法一样，为提高除法的运算速度，可采用阵列除法器。以下介绍两个正数的不恢复余数阵列除法器。 可控加减单元CAS是构成阵列除法器的基本单元。由一个全加器和一个异或门组成。如图所示 可控加减单元CAS有四个输入端和四个输出端。 当控制线P=0时,$Y_i \\bigoplus P =Y_i$，全加器完成$Y_i+X_i$ 当控制线P=1时,$Y_i \\bigoplus P =\\stackrel{-} Y_i$，全加器完成$ \\stackrel{-} Y_i+X_i$ ","date":"2024-03-16","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%862/:17:0","tags":["计算机组成原理"],"title":"计算机组成(第二章)","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%862/"},{"categories":["计算机组成原理"],"content":"原理 被除数X各位沿竖直线送到CAS，除数Y沿斜线送到CAS。做加法还是做减法，由控制线P决定。由于是两正数相除，除法阵列第一行应执行减法操作，所以该行控制端P=1，同时将P作为该行末端的进位输入，从而完成减法运算。 如果够减，有进位，商为1，下行做减法。如果不够减，无进位，商为0，下行做加法。其它行工作同上，得出商和余数。 ","date":"2024-03-16","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%862/:18:0","tags":["计算机组成原理"],"title":"计算机组成(第二章)","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%862/"},{"categories":["计算机组成原理"],"content":"定点运算器的组成 ","date":"2024-03-16","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%862/:19:0","tags":["计算机组成原理"],"title":"计算机组成(第二章)","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%862/"},{"categories":["计算机组成原理"],"content":"算术逻辑运算部件ALU 计算机的主要功能是对数据进行各种加工和处理，包括加、减、乘、除这些基本的算术运算，与、或、非这些基本的逻辑运算，以及由此构成的其它复杂的运算。运算器则是实现这些运算的主要部件。 无论多么复杂的运算，最终都要分解为加法运算来实现。其中，减法运算通过补码转化为加法来实现 ；乘、除运算可以转换为加减运算、移位操作来实现。加法和移位是计算机中最基本的两种运算操作。 可见，**加法器又是运算器的核心部件。**在加法器的基础上增加移位功能，并通过选择输入控制条件，就可以实现所有的运算。 全加器 全加器（FA）是最基本的运算单元，由它构成加法器。 全加器有**三个输入量：**操作数$A_i$、$B_i$、以及低位传来的进位信号$C_{i-1}$ 。 全加器有**两个输出量：**本位和$S_i$、以及向高位的进位信号$C_i$。 根据真值表得： Si=Ai⊕Bi⊕Ci-1 Ci=AiBi+(Ai⊕Bi)Ci-1 Si : 本位和 Ci : 向高位的进位 一个全加器只完成一位加法 全加器构成加法器 全加器并不存储信息，可用门电路来实现。用全加器能够方便地构成加法器。加法器分为串行加法器和并行加法器。 串行加法器只有一个全加器，数据逐位串行送入加法器进行计算。由于运算速度慢，一般不用。 并行加法器则由若干个这样的全加器构成，各位数据同时运算。并行加法器的位数与操作数的位数相等。并行加法器的最长运算时间主要取决于进位信号的传递时间。例如：11…11和00…01相加，最低位产生的进位将逐位影响到最高位. 由此可见，提高并行加法器速度的关键是尽量加快进位产生和传递的速度。 进位产生与传递 进位链的概念： 并行加法器中的每一个全加器都有一个从低位送来的进位输入和一个传送给高位的进位输出。我们把构成进位信号产生和传递的逻辑网络称为进位链。 进位链上每一位的进位表达式为： $C_i=A_iB_i+(A_i⊕B_i)C_{i-1}$ （注意是逻辑关系） 设 Gi=AiBi ，称为进位产生函数 Pi=Ai⊕Bi ，称为进位传递函数 ∴ 进位表达式 Ci=Gi+PiCi-1 并行加法器的串行进位 把n个全加器串联起来，就可以实现两个n位数的相加。这种加法器称为串行进位的并行加法器，串行进位又叫**行波进位。 ** 并行加法器的并行进位 改进串行进位方式的基本思路是各进位同时形成，避免各进位之间的依赖关系。现在来分析一下进位关系。 只要满足下述两条件中任一个，就可形成C1： (1)X1，Y1均为“1”； (2)X1，Y1任一个为“1”，且进位C0为“1”。由此，可写得 C1的表达式为C1=X1Y1+(X1⊕Y1)C0 只要满足下述两条件中任一个，就可形成C2： (1)X2，Y2均为“1”； (2)X2，Y2任一为“1”，且X1，Y1均为“1”； (3)X2，Y2任一为“1”，同时X1，Y1任一为“1”，且C0为 “1”。由此可得C2表达式为 C2=X2Y2+(X2⊕Y2)X1Y1+(X2⊕Y2)(X1⊕Y1)C0 以上进位输出只与$G_i$、$P_i$以及最低进位$C_0$有关，而且不依赖于其低位进位$C_{i-1}$的输入，因此各级进位可以同时产生，形成并行进位。 并行进位的特点 并行进位的特点是各级进位信号同时形成，与字长无关，提高了整体运算速度 。并行进位又叫先行进位。 最长延迟时间仅为2ty。 随着加法器位数的增加，Ci的逻辑表达式会变得越来越长，输入变量会越来越多，电路结构也会变得越来越复杂，导致电路实现也越来越困难。 并行进位方式需继续改进，才能有实用价值。这就是下面要介绍的分组进位方式。 单级先行进位 以16位加法器为例，将其分为4组，每组4位。 在组内，按照并行进位函数直接产生C1～C4，这些进位可同时得到。实现这种进位逻辑的电路称为4位先行进位电路（CLA），如74181ALU。 利用这种4位一组的CLA电路和4位全加器可以构成4位CLA加法器。注意，4位CLA加法器包含了两部分逻辑：4位全加器和4位一组的先行进位链，这个组内的进位为一级进位。 在组间，每个组的进位输入是前一个组的进位输出，而每个组的进位输出是下一个组的进位输入。 上述组内并行、组间串行的进位方式也称为单级先行进位方式，原理如下图所示。 多级先行进位 组内进位信号能同时产生、组间进位信号也能同时产生，由此可以构成多级并行进位逻辑。16位2级先行进位加法器如图所示。 为说明问题，我们不妨仍以16位加法器为例，仍然4位一组，分成4个小组，先就第一小组的进位输出函数C4做一下分析： G1称为组进位产生函数，P1称为组进位传递函数；这两个函数类似于进位产生函数G和进位传递函数P. 四个组内的最高进位C16、C12、C8、C4可以分别表示为: 例：某加法器最低位为第1位，采用串行进位方式。写出进位信号C3的逻辑式（操作数Ai、Bi、初始进位C0）。 例2：某加法器采用组内并行、组间并行的进位链，四位一组。写出进位信号C6的的逻辑式（操作数Ai、Bi、初始进位C0）。 ","date":"2024-03-16","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%862/:19:1","tags":["计算机组成原理"],"title":"计算机组成(第二章)","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%862/"},{"categories":["计算机组成原理"],"content":"多功能算术逻辑部件ALU 参加运算的两个数$A_i、B_i$和低位进位Ci-1先不进行全加，先把两个输入$A_i、B_i$和四个控制参数$S_0、S_1、S_2、S_3$进行组合，形成函数$X_i和Y_i$， 然后再将$X_i、Y_i$和低位进位$C_{i-1}$通过全加器进行全加。 这样一来，控制参数不同，得到的组合函数也不同，从而实现多种算术和逻辑运算。 ","date":"2024-03-16","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%862/:20:0","tags":["计算机组成原理"],"title":"计算机组成(第二章)","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%862/"},{"categories":["计算机组成原理"],"content":"算术逻辑部件ALU 算术逻辑部件ALU大体上有三部分组成 全加器 进位链 输入选择器 下面以ALU的一位逻辑为例，原理性地说明算术、逻辑功能是如何实现的。 通过不同的输入选择，实现不同的功能，这进一步说明：数据是在传送过程实现运算、并得到处理的。多位ALU的实现思路完全一样 运算器的组织 运算器主要由算逻部件ALU、寄存器、多路转换器、内部数据总线组成。 在运算器内部，各功能模块之间的连接大都采用总线结构，称为运算器的内部总线，ALU和各寄存器都挂在上面。 运算器大体上有如下三种结构：单总线结构、双总线结构和三总线总线结构。 单总线结构的运算器 双总线结构的运算器 两个操作数可以同时到达ALU进行运算，且马上可以得到运算结果，输出端需要设置一个缓冲寄存器 ；完成一次运算需要2步 。 特殊寄存器分成两组，它们分别与一条总线交换数据。通用寄存器中的数据就可以进入到任一组特殊寄存器中去，从而使数据传送更为灵活。 三总线结构的运算器 两条总线同时供给操作数，输出与第三条总线相连；完成一次运算需要1步。特点是操作速度快，控制相对复杂一些 ","date":"2024-03-16","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%862/:20:1","tags":["计算机组成原理"],"title":"计算机组成(第二章)","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%862/"},{"categories":["计算机组成原理"],"content":"浮点运算方法和浮点运算器 ","date":"2024-03-16","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%862/:21:0","tags":["计算机组成原理"],"title":"计算机组成(第二章)","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%862/"},{"categories":["计算机组成原理"],"content":"浮点加法、减法运算 浮点加减运算 设有两个浮点数ｘ和ｙ,它们分别为 $ｘ＝2^{Ex}·M_x$ $ｙ＝2^{Ey}·M_y$ 其中$E_x$和$E_y$分别为数ｘ和ｙ的阶码,$M_x$和$M_y$为数ｘ和ｙ的尾数。两浮点数进行加法和减法的运算规则是 $ｘ±ｙ＝(M_x2^{Ex-Ey}±M_y)2^{Ey}$， 设$E_x\u003c＝E_y$ 浮点运算步骤如下： 0 操作数的检查,看有无简化操作的可能； 比较阶码大小并完成对阶（小阶向大阶对齐）； 尾数进行加或减运算； 结果规格化并进行舍入处理 例: 设$x＝2^2×0.11011011,y=-2^4×0.10101100$ 0操作数检查（非0） 对阶：阶码对齐后才能加减。规则是阶码小的向阶码大的数对齐； 若△E＝0,表示两数阶码相等,即Ex＝Ey； 若△E\u003e0,表示Ex\u003eEy； 若△E\u003c0,表示Ex\u003cEy。 当Ex≠Ey 时,要通过尾数的移动以改变Ex或Ey,使之相等 原则:小阶向大阶 设△E\u003e0,表示Ex\u003eEy，则移动y的尾数，My右移△E位 阶差=Ex-Ey=00 010- 00 100 =11 110 即阶差为-2，Mx右移两位，Ex加2 x=00100 , 0.00110110（11） 尾数相加 00.00110110（11）+11.01010100=11.10001010（11） 结果规格化 在浮点加减运算时,尾数求和的结果也可以得到01.ф…ф或10.ф…ф,即两符号位不等,此时将运算结果右移以实现规格化表示,称为向右规格化。 规则：尾数右移1位，阶码加1 结果是00.0..01…..或11.1…10…时，则向左规格化 规则：尾数左移1位，阶码减1，直到规格化 右规，阶码加1，左规，阶码减1 刚才例子左规为11.00010101（10），阶码减1为00011 舍入处理（对阶和向右规格化时） 就近舍入(0舍1入):类似”四舍五入”,丢弃的最高位为1,进1 朝0舍入:截尾 朝＋∞舍入:正数多余位不全为”0”,进1;负数,截尾 朝－∞ 舍入:负数多余位不全为”0”,进1;正数,截尾 溢出判断和处理 阶码上溢，一般将其认为是＋∞和－∞ 。 阶码下溢，则数值为0 尾数上溢，两个同符号位的数相加。处理方法是尾数右移，阶码 加1 尾数下溢。尾数右移时，最低位从最右端流出。要进行舍入处理 。 课堂练习：x=0.110121 y=-0.101023 尾数和阶符都采用补码表示，都采用双符号位表示法。求x+y [x]浮=0001，00.1101 [y]浮=0011，11.0110 阶差=1110 即为-2 Mx应当右移2位， [x]浮=0011，00.0011（01） 尾数和为11.1001（01） 左规11.0010（10），阶码减1为0010 舍入（就近舍入）11.0011 丢弃10 x+y=-0.1101*210 ","date":"2024-03-16","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%862/:21:1","tags":["计算机组成原理"],"title":"计算机组成(第二章)","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%862/"},{"categories":["计算机组成原理"],"content":"浮点乘法和除法运算 设有两个浮点数ｘ和ｙ： $ｘ＝2^{Ex}·M_x　$　$ｙ＝2^{Ey}·M_y$ 乘除运算分为四步 0操作数检查 阶码加减操作（无需对阶） 尾数乘除操作 结果规格化和舍入处理 浮点数的阶码运算（移码的运算规则） $[X]_移+[Y]_移=2^n+[X+Y]_移$ 移码采用双符号位，为了对溢出进行判断 01 为正 00 为负 10 上溢 11 下溢 x＝＋011,y＝＋110,求[$x+y]_移 和 [x-y]_移$,并判断是否溢出 $[x]_移＝01 011, [y]_补＝00 110, [-y]_补＝11 010$ $[x+y]_移＝[x]_移＋[y]_补＝10 001$, 结果上溢。 $[x-y]_移＝[x]_移＋[-y]_补＝00 101$, 结果正确,为－3。 尾数处理 截断 舍入 尾数用原码表示时 只要尾数最低为1或者移出位中有1数值位，使最低位置1 0舍1入 尾数用补码表示时 丢失的位全为0，不必舍入。 丢失的最高位为0，以后各位不全为0时；或者最高为1，以后各位全为0时，不必舍入 丢失的最高位为1，以后各位不全为0时，则在尾数的最低位入1的修正操作 例： 设有浮点数x＝2-5×0.0110011， y＝23×(－0.1110010)，阶码用4位移码表示,尾数(含符号位)用8位补码表示。求[x×y]浮。要求用补码完成尾数乘法运算,运算结果尾数保留高8位(含符号位),并用尾数低位字长值处理舍入操作。 解： 移码采用双符号位,尾数补码采用单符号位,则有 $[Mx]_补＝0.0110011, [My]_补＝1.0001110,$ $[Ey]_移＝01 011, [Ey]_补＝00 011, [Ex]_移＝00 011,$ $[x]_浮＝00 011, 0.0110011, [y]_浮＝01 011, 1.0001110$ 判断操作是否为”0”,求阶码和 $[Ex＋Ey]_移＝[Ex]_移＋[Ey]_补＝00 011＋00 011＝00 110,$ 值为移码形式－2。 尾数乘法运算可采用补码阵列乘法器实现,即有 $[Mx]_补×[My]_补＝[0.0110011]_补×[1.0001110]_补 =[1.1010010,1001010]_补$ 规格化处理 乘积的尾数符号位与最高数值位符号相同，不是规格化的数,需要左规，阶码变为00 101(-3), 尾数变为 1.0100101,0010100。 舍入处理 尾数为负数，取尾数高位字长，按舍入规则,舍去低位字长，故尾数为1.0100101 。 最终相乘结果为 $[x×y]_浮＝00 101,1.0100101$ 其真值为 $x×y＝2^{－3}×(－0.1011011)$ 实现的逻辑框图 浮点运算器实例 CPU之外的浮点运算器（数学协处理器）如80287 完成浮点运算功能，不能单用。 可以和80386或80286异步并行工作 高性能的80位字长的内部结构。有8个80位字长以堆栈方式管理的寄存器组。 浮点数格式完全符合IEEE标准 CPU之内的浮点运算器（486DX以上） ","date":"2024-03-16","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%862/:21:2","tags":["计算机组成原理"],"title":"计算机组成(第二章)","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%862/"},{"categories":["计算机组成原理"],"content":"本 章 小 结 一个定点数由符号位和数值域两部分组成。按小数点位置不同，定点数有纯小数和纯整数两种表示方法。 按IEEE754标准，一个浮点数由符号位S、阶码E、尾数M三个域组成。其中阶码E的值等于指数的真值e加上一个固定偏移值。 为了使计算机能直接处理十进制形式的数据，采用两种表示形式：(1)字符串形式，主要用在非数值计算的应用领域；(2)压缩的十进制数串形式，用于直接完成十进制数的算术运算。 数的真值变成机器码时有四种表示方法：原码表示法，反码表示法，补码表示法，移码表示法。其中移码主要用于表示浮点数的阶码E，以利于比较两个指数的大小和对阶操作 字符信息属于符号数据，是处理非数值领域的问题。国际上采用的字符系统是七单位的ASCII码。直接使用西文标准键盘输入汉字，进行处理，并显示打印汉字，是一项重大成就。为此要解决汉字的输入编码、汉字内码、字模码等三种不同用途的编码 为运算器构造的简单性，运算方法中算术运算通常采用补码加、减法，原码乘除法或补码乘除法。为了运算器的高速性和控制的简单性，采用了先行进位、阵列乘除法、流水线等并行技术措施。运算方法和运算器是本章的重点 ","date":"2024-03-16","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%862/:22:0","tags":["计算机组成原理"],"title":"计算机组成(第二章)","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%862/"},{"categories":["计算机算法设计与分析"],"content":"分治法 ","date":"2024-03-12","objectID":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A12/:0:0","tags":["计算机算法设计与分析"],"title":"算法与程序(第二章)","uri":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A12/"},{"categories":["计算机算法设计与分析"],"content":"思想 分+治+合 ","date":"2024-03-12","objectID":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A12/:1:0","tags":["计算机算法设计与分析"],"title":"算法与程序(第二章)","uri":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A12/"},{"categories":["计算机算法设计与分析"],"content":"过程 分治法产生的子问题是原问题的较小模式 反复应用分治手段，可以使子问题规模不断减小 最终使子问题缩小到很容易直接求出其解 将规模较小问题的答案逐级向上合并(递归过程)，可得大问题答案 分治法解决问题通常使用递归算法 递归的概念 直接或间接地调用自身的算法称为递归算法 ","date":"2024-03-12","objectID":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A12/:2:0","tags":["计算机算法设计与分析"],"title":"算法与程序(第二章)","uri":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A12/"},{"categories":["计算机算法设计与分析"],"content":"递归算法的框架 ","date":"2024-03-12","objectID":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A12/:3:0","tags":["计算机算法设计与分析"],"title":"算法与程序(第二章)","uri":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A12/"},{"categories":["计算机算法设计与分析"],"content":"要素 边界条件与递归方程是递归函数的两个要素 递归函数只有这两个要素才能在有限次运算得出结果 ","date":"2024-03-12","objectID":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A12/:4:0","tags":["计算机算法设计与分析"],"title":"算法与程序(第二章)","uri":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A12/"},{"categories":["计算机算法设计与分析"],"content":"小结 优点:结构清晰，可读性强，而且容易用数学归纳法来证明算法的正确性，因此它为设计算法，调试程序带来很大方便 缺点:递归算法的运行效率较低，无论是耗费的计算时间还是占用的存储空间都比非递归算法要多 建议: 如果问题用递推方法可解决，就不要使用递归算法 用栈模拟的非递归算法，对运行效率改善有限，不建议使用 分治法的适用条件 n个问题分解为k个规模较小的子问题，子问题之间相互独立，不包含公共的问题，名子问题的解合并得到原问题的解 ","date":"2024-03-12","objectID":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A12/:5:0","tags":["计算机算法设计与分析"],"title":"算法与程序(第二章)","uri":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A12/"},{"categories":["计算机算法设计与分析"],"content":"最优子传构性质 最优子结构是依赖特定问题和子问题的分割方式而成立的条件。各子问题具有最优解，就能求出整个问题的最优解，此时条件成立。 比如求广州到北京的最短距离，假设这个路径必经过中间的南京，那么先把路径分割为（广州，南京）和（南京，北京）。分别求出子路径的最短距离然后再连接，就可以得到广州到北京的最短路径。 因此，寻求最短路径的问题可以利用子路径的最优解获得整个问题的最优解。这样就可以证明，最短路径具有最优子结构。 ","date":"2024-03-12","objectID":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A12/:6:0","tags":["计算机算法设计与分析"],"title":"算法与程序(第二章)","uri":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A12/"},{"categories":["计算机算法设计与分析"],"content":"分治法时间复杂度分析 一个分治法将规模为n的问题分成k个规模为n/m的子问题去解。为方便起见，设分解阈值n0为1，且adhoc解规模为1的问题耗费1单位时间。另外，将原问题分解为k个子问题及用merge将k个子问题的解合并为原问题的解需用f(n)单位时间 二分搜索技术 将n个元素分成个数大致相同的两半，取a[n/2]与x作比较。如果x=a[n/2]，则找到x，算法终止；如果x\u003ca[n/2]，则只在数组a的左半部继续搜索x;如果x\u003ea[n/2]，则只在数组a的右半部继续搜索x 具体描述算法如下： ","date":"2024-03-12","objectID":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A12/:7:0","tags":["计算机算法设计与分析"],"title":"算法与程序(第二章)","uri":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A12/"},{"categories":["计算机算法设计与分析"],"content":"二分搜索技术(递归算法) int BinarySearch_Rec(int num[], int target, int left, int right) { while (left \u003c= right) { int mid = left + (right - left) / 2; if (num[mid] == target) return mid; else if (num[mid] \u003e target) return BinarySearch_Rec(num, target, left, mid - 1); else if (num[mid] \u003c target) return BinarySearch_Rec(num, target, mid + 1, right); } return -1; } 算法复杂度分析 利用主定理或递归树可求其时间复杂性为:O(logn) ","date":"2024-03-12","objectID":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A12/:7:1","tags":["计算机算法设计与分析"],"title":"算法与程序(第二章)","uri":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A12/"},{"categories":["计算机算法设计与分析"],"content":"二分搜索技术(非递归算法) int BinarySearch(int num[], int target, int len) //非递归实现 { int left = 0; int right = len - 1; // 第一个细节点 while (left \u003c= right) // 第二个细节点 { int mid = left + (right - left) / 2; if (num[mid] == target) return mid; else if (num[mid] \u003e target) right = mid - 1; // 第三个细节点 else if (num[mid] \u003c target) left = mid + 1; // 第四个细节点 } return -1; } 算法复杂度分析 每执行一次while循环，待搜素数组的大小减小1/2.在最坏情况下，while循环被执行了O(logn)次，因此算法在最坏情况下计算时间复杂性为O(logn) ","date":"2024-03-12","objectID":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A12/:7:2","tags":["计算机算法设计与分析"],"title":"算法与程序(第二章)","uri":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A12/"},{"categories":["计算机算法设计与分析"],"content":"快速幂算法 给定实数a和非负整数n，用分治法设计求$a^n$的快速算法(递归算法) 分析： 算法如下 double exp2(double a,int n){ if(a==0) return 0; if(n\u003c=0) return 1; else{ int x=exp2(a,n/2); if(n%2) return a*x*x; else return x*x; } } 该问题满足四个条件时间复杂性O(logn) 给定正整数a和n，用分治法设计求$a^n$的快速算法(非递归算法) 举例求$a^{93}$ n=93的二进制表示(如图)，也就是n=64+16+8+4+1,因此$a^{93}=a^{64}a^{16}a^8a^4a$ 算法如下 double exp2(double a,int n){ int i; double b,s=1.0; i=n; b=a; while(i\u003e0){ if(i%2) s*=b; i/=2; b*=b; } return s; } ","date":"2024-03-12","objectID":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A12/:8:0","tags":["计算机算法设计与分析"],"title":"算法与程序(第二章)","uri":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A12/"},{"categories":["计算机算法设计与分析"],"content":"Strassen矩阵乘法 首先，仍假设n是2的幂。将矩阵A,B和C中的每个矩阵都分块成4个大小相等的子矩阵，每个子矩阵都是n/2*n/2的方阵。由此可将方程C=AB重写为： 时间复杂性分析 上述分治法的计算时间耗费T(n)应满足 这个递归方程的解仍然是T(n)=O($n^3$)。因此，该方法并不比用原始定义直接计算更有效。究其原因，由于是该方法并没有减少矩阵的乘法次数。 要想改进矩阵乘法的计算时间复杂性，必须减少乘法运算 优化 时间复杂性分析 Strassen矩阵乘法中用了7次对于n/2阶矩阵乘积的递归调用和18次n/2阶矩阵的加减运算。由此可知，该算法所需的计算时间T(n)满足如下递归方程： 解此递归方程得T(n)=O($n^{log7}$)$\\approx$O($n^{2.81}$)。由此可见，Strassen矩阵乘法的计算时间复杂性比普通矩阵乘法有较大改进 ","date":"2024-03-12","objectID":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A12/:9:0","tags":["计算机算法设计与分析"],"title":"算法与程序(第二章)","uri":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A12/"},{"categories":["计算机算法设计与分析"],"content":"棋盘覆盖 当k\u003e0时，将$2^k\\times 2^k$棋盘分割为4个$2^{k-1}\\times 2{k-1}$子棋盘，如图a所示。特殊方格必位4个较小子棋盘之一中，其余3个子棋盘中无特殊方格。为了将这3个无特殊方格的子棋盘转化为特殊棋盘，可以用一个L型骨牌覆盖这3个较小棋盘的会合处，如b所示，这3个子棋盘上被L型骨牌覆盖的方格就成为该棋盘上的特殊方格，从而将原问题转化为4个较小规模的棋盘覆盖问题。递归地使用这种分割，直至棋盘简化为$1\\times1$棋盘 算法如下 void chessBoard(int tr, int tc, int dr, int dc, int size) { if (size==1) return; int s = size/2; //分割棋盘 int t = ++num; //L型骨牌号 //覆盖左上角子棋盘 if (dr \u003c tr + s \u0026\u0026 dc \u003c tc +s) { //特殊方格在此棋盘中 chessBoard(tr,tc,dr,dc,s); } else //此棋盘中无特殊方格 { //用t号L型骨牌覆盖右下角 Matrix[tr+s-1][tc+s-1] = t; //覆盖其余方格 chessBoard(tr,tc,tr+s-1,tc+s-1,s); } //覆盖右上角子棋盘 if (dr \u003c tr + s \u0026\u0026 dc \u003e= tc + s ) { //特殊方格在此棋盘中 chessBoard(tr,tc+s,dr,dc,s); } else //此棋盘中无特殊方格 { //用t号L型骨牌覆盖左下角 Matrix[tr+s-1][tc+s] = t; //覆盖其余方格 chessBoard(tr,tc+s,tr+s-1,tc+s,s); } //覆盖左下角子棋盘 if (dr \u003e= tr + s \u0026\u0026 dc \u003c tc + s) { //特殊方格在此棋盘中 chessBoard(tr+s,tc,dr,dc,s); } else { //用t号L型骨牌覆盖右上角 Matrix[tr+s][tc+s-1] = t; //覆盖其余方格 chessBoard(tr+s,tc,tr+s,tc+s-1,s); } //覆盖右下角子棋盘 if (dr \u003e= tr + s \u0026\u0026 dc \u003e= tc + s) { //特殊方格在此棋盘中 chessBoard(tr+s,tc+s,dr,dc,s); } else { //用t号L型骨牌覆盖左上角 Matrix[tr+s][tc+s] = t; //覆盖其余方格 chessBoard(tr+s,tc+s,tr+s,tc+s,s); } } 复杂度分析 T(n)=O($n^2$) 本算法可使用队列或者栈实现，非递归算法 ","date":"2024-03-12","objectID":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A12/:10:0","tags":["计算机算法设计与分析"],"title":"算法与程序(第二章)","uri":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A12/"},{"categories":["计算机算法设计与分析"],"content":"合并排序 将待排序元素分成大小大致相同的两个子集合，分别对两个子集合进行排序，最终将排好序的子集合合并成要求好的排好序的集合 算法描述(可递归) template\u003cclass Type\u003e void MergeSort(Type a[],int left,int right){ if(left\u003cright){ //至少有2个元素 int i =(left + right)/2; //取中点 MergeSort(a,left,i); MergeSort(a,i+1,right); Merge(a,b,left,i,right); //合并到数组b Copy(a,b,left,right); //复制回数组a } } 算法MergeSort的递归过程可以消去 复杂度分析 最坏时间复杂度：O(nlogn) 平均时间复杂度：O(nlogn) 辅助空间：O(n) 稳定性：稳定 ","date":"2024-03-12","objectID":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A12/:11:0","tags":["计算机算法设计与分析"],"title":"算法与程序(第二章)","uri":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A12/"},{"categories":["计算机算法设计与分析"],"content":"快速排序 快速排序算法是基于分治策略的另一个排序算法。其基本思想是，对于输入的子数组a[p:r]，按以下三个步骤进行排序。 分解(Divide):以a[p]为基准元素将a[p:r]划分成3段a[p:q-1],a[q]和a[q+1:r]，使a[p:q-1]中任何一个元素小于等于a[q]，而a[q+1:r]中任何一个元素大于等于a[q]。下标q在划分过程中确定 递归求解(Conquer)：通过递归调用快速排序算法，分别对a[p:q-1]和a[q+1:r]进行排序 合并(Merge):由于对a[p:q-1]和a[q+1:r]的排序是就地进行的，因此在a[p:q-1]和a[q+1:r]都已排好的序后，不需要执行任何计算，a[p:r]则已排好序 算法如下： template(class Type) void QuickSort(Type a[],int p,int r){ if(p\u003cr){ int q=Partition(a,p,r); QuickSort(a,p,q-1); //对左半段排序 QuickSort(a,q+1,r); //对右半段排序 } } 对含有n个元素的数组a[0:n-1]进行快速排序只要调用QuickSort(a,0,n-1)即可。 上述算法中的函数Partition()以一个确定的基准元素a[p]对子数组a[p:r]进行划分，它是快速排序算法的关键。 算法如下： template\u003cClass Type\u003e int Partition (Type a[],int p,int r){ int i =p,j=r+1; Type x =a[p]; //将小于x的元素交换到左边区域，将大于x的元素交换到右边区域 while(true){ while(a[++i]\u003cx\u0026\u0026i\u003cr); while(a[--j]\u003ex); if(i\u003e=j) break; Swap(a[i],a[j]); } a[p] = a[j]; a[j] = x; return j; } 复杂度分析 快速排序算法的性能取决于划分的对称性 最坏情况，每次划分出的二个子问题，一个长度为0，另一个长度为n-1，其对应的时间复杂性的递归定义为： 最坏时间复杂度：O($n^2$) 平均时间复杂度：O(nlogn) 稳定性：不稳定 通过修改算法partition，可以设计出采用随机选择策略的快速排序算法。可以在a[p:r]中随机选出一个元素作为划分基准。可以期望划分是较对称的。 template\u003cClass Type\u003e int RandomizedPartition(Type a[],int p,int r){ int i = Random(p,r); Swap(a[i],a[p]); return Partition(a,p,r); } void RandomizedQuickSort(Type a[],int p,int r){ if(p\u003cr){ int q=RandomizedPartition(a,p,r); RandomizedQuickSort(a,p,q-1); //对左半段排序 RandomizedQuickSort(a,q+1,r); //对右半段排序 } } ","date":"2024-03-12","objectID":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A12/:12:0","tags":["计算机算法设计与分析"],"title":"算法与程序(第二章)","uri":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A12/"},{"categories":["计算机算法设计与分析"],"content":"线性时间选择 给定线性序集中n个元素和一个整数k，$1\\leq k \\leq n$，要求找出这n个元素中第k小的元素 template\u003cClass Type\u003e Type RandomizedSelect(Type a[],int p,int r,int k){ if(p==r) return a[p]; int i=RandomizedPartition(a,p,r); j=j-p+1; if(j==k) return a[i]; if(k\u003cj) return RandomizedSelect(a,p,i,k); else return RandomizedSelect(a,i+1,r,k-j); } 时间复杂性分析 在最坏情况下，算法RandomizedSelect需要O($n^2$)计算时间 但可以证明，算法RandomizedSelect可以在O(n)平均时间内找出n个输入元素中的第k小元素 ","date":"2024-03-12","objectID":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A12/:13:0","tags":["计算机算法设计与分析"],"title":"算法与程序(第二章)","uri":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A12/"},{"categories":["计算机算法设计与分析"],"content":"循环赛日程表 设计一个满足以下要求的比赛日程表 每个选手必须与其他n-1个选手各赛一次 每个选手一天只能赛一次； 循环赛一共进行 n−1 天 选手人数$n=2^k$ 算法如下 void table(int[N][N],int i,int j,int n){ //i,j左上角行号列号，n为长度 if(n\u003e1){ table(a,i,j,n/2); table(a,i+n/2,j,n/2); copy(a,i,j,i+n/2,j+n/2,n/2); //左上表拷贝至右下表 copy(a,i+n/2,j+n/2,n/2); //左下表拷贝至右上表 } } 小结 在使用分治策略解决问题时，注意检查四个条件是否满足 尽量保证划分出的子问题规模大致一致。平衡子问题思想 如果可以使用递推的方式解决问题，尽量使用递推算法 递归的分治算法的时间复杂性分析，要先写出其时间复杂性的递归方程，然后用主定理或递归树解方程 用递归算法解决问题时，要分析出其边界条件和递归方程(过程) ","date":"2024-03-12","objectID":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A12/:13:1","tags":["计算机算法设计与分析"],"title":"算法与程序(第二章)","uri":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A12/"},{"categories":["数据结构"],"content":"概念 相互之间存在一种或多种特定关系的数据元素的集合 逻辑结构，存储结构，运算合称为三要素 ","date":"2024-03-10","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:0:0","tags":["数据结构"],"title":"数据结构(第一章)","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["数据结构"],"content":"数据结构形式定义 数据结构是一个二元组 Data_Structure = (D,S) D是数据元素的有限集，S是D上关系的有限集 基本术语 ","date":"2024-03-10","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:1:0","tags":["数据结构"],"title":"数据结构(第一章)","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["数据结构"],"content":"数据 所有能被计算机识别，存储和处理的符号的集合 ","date":"2024-03-10","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:2:0","tags":["数据结构"],"title":"数据结构(第一章)","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["数据结构"],"content":"数据元素 是数据的基本单位，具有完整的实际意义。一个数据元素可由若干个数据项组成 ","date":"2024-03-10","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:3:0","tags":["数据结构"],"title":"数据结构(第一章)","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["数据结构"],"content":"数据项 构成数据元素的项目。是数据不可分割的最小单位 ","date":"2024-03-10","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:4:0","tags":["数据结构"],"title":"数据结构(第一章)","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["数据结构"],"content":"数据类型 指一个类型和定义在这个类型上的操作集合。 ","date":"2024-03-10","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:5:0","tags":["数据结构"],"title":"数据结构(第一章)","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["数据结构"],"content":"抽象数据元素 抽象定义的，没有实际含义的数据元素 ","date":"2024-03-10","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:6:0","tags":["数据结构"],"title":"数据结构(第一章)","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["数据结构"],"content":"抽象数据类型 用户自己定义的数据类型 数据结构涵盖的内客 ","date":"2024-03-10","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:7:0","tags":["数据结构"],"title":"数据结构(第一章)","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["数据结构"],"content":"逻辑结构 ","date":"2024-03-10","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:8:0","tags":["数据结构"],"title":"数据结构(第一章)","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["数据结构"],"content":"线性结构 线性表，栈，队，串，数组 ","date":"2024-03-10","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:8:1","tags":["数据结构"],"title":"数据结构(第一章)","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["数据结构"],"content":"非线性结构 树结构，图结构，集合结构 ","date":"2024-03-10","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:8:2","tags":["数据结构"],"title":"数据结构(第一章)","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["数据结构"],"content":"物理结构(存储结构) 是数据的逻辑结构在计算机存储器内的表示(或映像)。它依赖于计算机 ","date":"2024-03-10","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:9:0","tags":["数据结构"],"title":"数据结构(第一章)","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["数据结构"],"content":"分类 顺序结构，链式结构，索引结构，散列结构 ","date":"2024-03-10","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:9:1","tags":["数据结构"],"title":"数据结构(第一章)","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["数据结构"],"content":"数据运算 在数据的逻辑结构上定义的操作算法 ","date":"2024-03-10","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:10:0","tags":["数据结构"],"title":"数据结构(第一章)","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["数据结构"],"content":"分类 插入运算，删除运算，修改运算，查找运算，排序运算 数据类型与抽象数据类型的区别 ","date":"2024-03-10","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:10:1","tags":["数据结构"],"title":"数据结构(第一章)","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["数据结构"],"content":"数据类型 是一个值的集合和定义在该值上的一组操作的总称 ","date":"2024-03-10","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:11:0","tags":["数据结构"],"title":"数据结构(第一章)","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["数据结构"],"content":"抽象数据类型 由用户定义，用以表示应用问题的数据类型。它由基本的数据类型构成，并包括一组相关的服务(或称操作) 它与数据类犁实质上是一个概念，但其特征是使用与实现相分离，实行数据封装和信息隐蔽(独立于计算机) ","date":"2024-03-10","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:12:0","tags":["数据结构"],"title":"数据结构(第一章)","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["数据结构"],"content":"抽象数据类型用三元组表示 ADT = (D,S,P) D:数据对象 S:D上的关系集 P:D上的操作集 ","date":"2024-03-10","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:13:0","tags":["数据结构"],"title":"数据结构(第一章)","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["数据结构"],"content":"ADT常用定义格式 算法和算法分析 ","date":"2024-03-10","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:14:0","tags":["数据结构"],"title":"数据结构(第一章)","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["数据结构"],"content":"算法 是对特定问题求解步骤的一种描述，是指令的有限序列，输入转换输出的计算步骤 好的程序设计：好算法+好结构 ","date":"2024-03-10","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:15:0","tags":["数据结构"],"title":"数据结构(第一章)","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["数据结构"],"content":"基本特性 有穷性，确定性，可行性，必有输出 ","date":"2024-03-10","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:15:1","tags":["数据结构"],"title":"数据结构(第一章)","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["数据结构"],"content":"评价指标 正确性，可读性，健状性，高效率(常用时间复杂度衡量)与低存储量(常用空间复杂度衡量)需求 ","date":"2024-03-10","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:15:2","tags":["数据结构"],"title":"数据结构(第一章)","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["数据结构"],"content":"算法描述方式 自然语言，程序设计语言，流程图，类高级语言(类C语言，类Pascal语言等) ","date":"2024-03-10","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:15:3","tags":["数据结构"],"title":"数据结构(第一章)","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["数据结构"],"content":"类C语言描述语法 类C语言精选了C语言的一个核心子集，也做了若干扩充，以利于描述 ","date":"2024-03-10","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:15:4","tags":["数据结构"],"title":"数据结构(第一章)","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["数据结构"],"content":"时间复杂度 若存在两个正常数c,n0，对于所有的$n\u003e=n_0$，有| f(n) |\u003c= c| g(n) |， 则记作f(n)=O(g(n)) 频度：是指该语句重复执行的次数 定理：若$$A(n)=a_mn^m+a_{m-1}n^{m-1}+…+a_1n+a_0是一个m次多项式，则A(n)=0(n^m)$$ ","date":"2024-03-10","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:16:0","tags":["数据结构"],"title":"数据结构(第一章)","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["数据结构"],"content":"空间复杂度 算法所需存储空间的量度 记作：S(n)=O(f(n)) 其中n为问题的规模(或大小) ","date":"2024-03-10","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:17:0","tags":["数据结构"],"title":"数据结构(第一章)","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["数据结构"],"content":"线性表定义 一个线性表是n个数据元素的有限序列 ","date":"2024-03-10","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%842/:0:0","tags":["数据结构"],"title":"数据结构(第二章)","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%842/"},{"categories":["数据结构"],"content":"数据元素类型 原子型 整数，字符 结构类型 表示学生的数据元素 ","date":"2024-03-10","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%842/:1:0","tags":["数据结构"],"title":"数据结构(第二章)","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%842/"},{"categories":["数据结构"],"content":"线性表中的元素之间的关系是线性关系 存在惟一的第一个元素 存在惟一的最后一个元素 除第一个元素之外，每个元素均只有一个直接前驱 除最后一个元素之外，每个元素均只有一个直接后继 ","date":"2024-03-10","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%842/:2:0","tags":["数据结构"],"title":"数据结构(第二章)","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%842/"},{"categories":["数据结构"],"content":"顺序表 线性表的顺序存储 ","date":"2024-03-10","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%842/:3:0","tags":["数据结构"],"title":"数据结构(第二章)","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%842/"},{"categories":["数据结构"],"content":"内涵 指用一组地址连续的存储单元依次存储线性表的数据元素。 ","date":"2024-03-10","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%842/:3:1","tags":["数据结构"],"title":"数据结构(第二章)","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%842/"},{"categories":["数据结构"],"content":"特点 存储单元地址连续(需要一段连续空间)逻辑上相邻的数据元素其物理位置也相邻存储密度大(100%) 随机存取 元素序号与存储位置存在如下关系： *Loc(ai) = Loc(ai)+(i-1)d (1\u003c=i\u003c=n) 线性表的动态分配顺序存储结构 在上述定义中，数组指针elem指示线性表的基地址，length指示线性表的当前长度。顺序表的初始化操作就是为顺序表分配一个预定义大小的数组空间，并将线性表的当前长度设为“0”.listsize指示顺序表当前分配的存储空间大小，一旦因插入元素而空间不足时，可再进行分配，即为顺序表增加一个大小为存储LISTINCREMENT个数据元素的空间 ","date":"2024-03-10","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%842/:3:2","tags":["数据结构"],"title":"数据结构(第二章)","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%842/"},{"categories":["数据结构"],"content":"线性表上的基本运算 ","date":"2024-03-10","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%842/:4:0","tags":["数据结构"],"title":"数据结构(第二章)","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%842/"},{"categories":["数据结构"],"content":"插入运算 含义 将元素e插入到线性表:($a_1,a_2,……,a_{i-1},a_i,……,a_n$)中，构成新的线性表($a_1,a_2,……,a_{i-1},e,a_i,……,a_n$)，满足$a_{i-1}\\leq e \\leq a_i$，(其中$\\leq$为比较关系)，即不破坏原线性关系。 一般情况下，在第i($1\\leq i \\leq n$)个元素之前插入一个元素时，需将第n至第i(共n-1+1)个元素向后移动一个位置。 算法如下： Status ListInsert Sq(SqList \u0026L,int i ,ElemType e){ //在顺序线性表L中第i个位置之前插入新的元素额， //i的合法值为1\u003c=i\u003c=ListLength_Sq(L)+1 if(i\u003c1||i\u003eL.length+1) return ERROR; //i值不合法 if(L.length\u003e=L.listsize){ //当前存储空间已满，增加分配 newbase = (ElemType *)realloc(L.elem,(L.listsize+LISTINCREMENT)*sizeof(ElemType)); if(!newbase) exit(OVERFLOW); //存储分配失败 L.elem = newbase; //新基址 L.listsize+=LISTINCREMENT; //增加存储容量 } q=\u0026(L.elem[i-1]); //q为插入位置 for(p=\u0026(L.elem[L.length-1]);p\u003e=q;--p) *(p+1)=*p; //插入位置及之后的元素右移 *q=e; //插入e ++L.length; //表长增1 return OK; } //ListInsert_Sq 顺序表上插入运算效率分析 时间复杂度 最好情况：在表尾插入，不移动元素，T(n)=O(1) 最坏情况：在表头插入，移动n个元素，T(n)=O(n) 平均复杂度 设$p_i$为在第i个元素之前插入一个元素的概率，且$P_1=P_2=…=P_i=…P_n=1/(n+1)$，则平均移动次数为： $E_is = \\sum \\limits^{n+1}{i=1}P_i(n-i+1)=1/(n+1)\\sum\\limits^{n+1}{i=1}(n-i+1)=n/2$ 即T(n)=O(n) 空间复杂度 不需要额外空间，S(n)=O(1). ","date":"2024-03-10","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%842/:4:1","tags":["数据结构"],"title":"数据结构(第二章)","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%842/"},{"categories":["数据结构"],"content":"删除运算 顺序表上删除运算的实现 一般情况下，删除第i($1\\leq i \\leq n$)个元素时需将从第i+1至第n(共n-i)个元素依次向前移动一个位置 算法如下： Status ListDelete_Sq(SqList \u0026L,int i,ElemType \u0026e){ //在顺序线性表L中删除第i个元素，并用e返回其值 //i的合法值为1\u003c=i\u003c=ListLength_Sq(L) if((i\u003c1) || (i\u003eL.length)) return ERROR //i值不合法 p=\u0026(L.elem[i-1]); //p为删除元素的位置 e=*p; //被删除元素的值赋给e q=L.elem+L.length-1; //表尾元素的位置 for(++p;p\u003c=q;++p) *(p-1) = *p; //被删除元素之后的元素左移 --L.length; //表长减1 return OK; }//ListDelete_Sq ","date":"2024-03-10","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%842/:4:2","tags":["数据结构"],"title":"数据结构(第二章)","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%842/"},{"categories":["数据结构"],"content":"顺序表上删除运算效率分析 平均复杂度 假设$q_i$是删除第i个元素的概率，则在长度为n的线性表中删除一个元素时所需移动元素次数的期望值(平均次数)为 $E_dl=\\sum\\limits^n_{i=1}q_i(n-i)=1/n\\sum\\limits^n_{i=1}(n-1)=(n-1)/2$ 即：T(n)=O(n) 空间复杂度 S(n)=O(1) ","date":"2024-03-10","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%842/:4:3","tags":["数据结构"],"title":"数据结构(第二章)","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%842/"},{"categories":["数据结构"],"content":"顺序表的优缺点 优点 不需要额外的存储空间来表示元素间的逻辑关系 可以随机地存取表中的任意一个元素 缺点 插入和删除元素时要移动大量的元素 必须事先进行空间分配，表的容量难以扩充(新算法已解决) ","date":"2024-03-10","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%842/:4:4","tags":["数据结构"],"title":"数据结构(第二章)","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%842/"},{"categories":["数据结构"],"content":"类语言书写的算法与C程序之间的差别 算法中除形式参数外，变量不做定义，在C程序中必须定义 算法中使用的元素类型(ElemType)没有定义，C程序中必须定义，常量OK,ERROR,OVERFLOW等在第一章统一定义 算法中的比较运算符(equal,less)未作定义，C程序中必须定义 必要的头文件(用作输入输出的stdio.h及内存申请的stdlib.h)，在C程序中必需包含 ","date":"2024-03-10","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%842/:5:0","tags":["数据结构"],"title":"数据结构(第二章)","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%842/"},{"categories":["数据结构"],"content":"线性表的链式表示和实现 ","date":"2024-03-10","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%842/:6:0","tags":["数据结构"],"title":"数据结构(第二章)","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%842/"},{"categories":["数据结构"],"content":"线性表的链式存储思路 逻辑结构 存储结构 实现方式 对每一个元素的存储单位进行扩充，在包含元素值存储的同时，在结点中存储与当前元素有直接关系的其他元素(直接前驱/直接后继)存储单位的地址(指针) 链式存储单位结构示意图 ","date":"2024-03-10","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%842/:6:1","tags":["数据结构"],"title":"数据结构(第二章)","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%842/"},{"categories":["数据结构"],"content":"链表(线性表的链式存储) 内涵 线性表的链式存储指用任意的存储单位存放线性表中的元素，每个元素与其直接前驱和(或)直接后继之间的关系用指针来存储，这称为链表 术语 结点：数据元素及其有直接关系的元素的地址构成的存储单位 链表结点结构示意图 ","date":"2024-03-10","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%842/:6:2","tags":["数据结构"],"title":"数据结构(第二章)","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%842/"},{"categories":["数据结构"],"content":"单链表 链表中，如果每个结点中只包含一个指针域，则称之为线性链表或单链表 单链表的存储 每个结点存储当前元素的直接后继。 线性表($a_1,a_2,…,a_{i-1},a_i,a_{i+1},…,a_n$) 链表示意图 单链表的内存镜像 单链表的C语言实现 //用结构指针描述 typedef struct LNode{ ElemType data; //数据域 struct LNode *next //指针域 }LNode,*LinkList 与之对应的结点结构示意图 单链表构建示意图(表头插入法) 带头结点的单链表 ","date":"2024-03-10","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%842/:6:3","tags":["数据结构"],"title":"数据结构(第二章)","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%842/"},{"categories":["数据结构"],"content":"单链表上的查找运算 在单链表中，必须从头指针出发进行查找 查找第i个元素 查找指定元素是否在表中 ….. 若找到，则返回该元素的值，否则返回ERROR 在单链表上查找第i个元素的示意图 用类C语言实现单链表上的查询(查找第i个元素) Status GetElem_L(LinkList L,int i,ElemType \u0026e){ //L为带头结点的单链表的头指针 //当第i个元素存在时，其赋值给e并返回OK，否则返回ERROR p=L-\u003enext; j=1; //初始化，p指向第一个结点，否则返回ERROR while(p\u0026\u0026j\u003c1){ p=p-\u003enext; ++j; } if(!p||j\u003ei) return ERROR; //第i个元素不存在 e=p-\u003edata; //取第i个元素 return OK; }//GetElem_L ","date":"2024-03-10","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%842/:6:4","tags":["数据结构"],"title":"数据结构(第二章)","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%842/"},{"categories":["数据结构"],"content":"单链表的插入运算(第i个位置插入新的结点) 用类C语言实现单链表上的插入(插入第i个元素) Status ListInsert_L(LinkList \u0026L,int i,ElemType e){ //在带头结点的单链线性表L中的第i个位置之前插入元素e p=L; j=0; while(p\u0026\u0026j\u003ci-1){ p=p-\u003enext; ++j; } //寻找i-1个结点 if(!p||j\u003ei-1) return ERROR; //i小于1或者大于表长+1 s=(LinkList)malloc(sizeof(LNode)); //生成新结点 s-\u003edata=e; s-\u003enext=p=\u003enext; //插入L中 p-\u003enext=s; return OK; }//ListInsert_L 用类C语言实现单链表上的删除(删除第i个元素) Status ListDelete_L(LinkList \u0026L,int i,ElemType \u0026e){ //在带头结点的单链线性表L中，删除第i个元素，并由e返回其值 p=L; j=0; while(p-\u003enext\u0026\u0026j\u003ci-1){ //寻找第i个结点，并令p指向其前驱 p=p-\u003enext; ++j; } if(!(p-\u003enext)||j\u003ei-1) return ERROR; //删除位置不合理 q=p-\u003enext; p-\u003enext=q-\u003enext; //删除并释放结点 e=q-\u003edata; free(q); return OK; }//ListDelete_L ","date":"2024-03-10","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%842/:6:5","tags":["数据结构"],"title":"数据结构(第二章)","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%842/"},{"categories":["数据结构"],"content":"单链表的表示和实现 链表的优缺点 优点： 插入，删除时无需移动元素，只需修改指针 根据需要申请存储空间，且不要求连续的存储空间 缺点： 对表中的元素只能进行顺序访问 用指针指示元素之间的逻辑关系（直接前驱，后继），存储空间利用率低 用表头插入法建立结点的单链表 线性单链表存储结构 typedef struct LNode{ ElemType data; struct LNode *next; }LNode,*LinkList; 基本步骤 建立头结点： L=(LinkList)malloc(sizeof(LNode)); L-\u003enext = NULL; 建立新结点p,填入元素： p = (LinkList)malloc(sizeof(LNode)); p-\u003edata=a; 将新结点p插入到头结点之后，修改头结点指针域指向p: p-\u003enext=L-\u003enext; L-\u003enext=p; 重复2，3步骤直到插入所有结点，结束 用c语言实现表头插入算法 LinkList CreateList_LH(int n){ int i; //声明本函数的内部变量类型 LinkList head; //head为指向链表的指针类型 LNode *p //p为指向结点的指针类型 head=null; for(i=n;i\u003e0;--i){ //从后向前输入元素 p=(LNode *)malloc(sizeof(LNode)); //未做溢出判定，应加入 scanf(\"%d\",\u0026p-\u003edata); //将键盘输入置入p的数据域 p-\u003enext=head; head=p; //返回指向链表的头指针 } } 用表尾插入法建立带头结点的单链表 基本步骤 建立头结点，并附设一个指针r一直指向最后一个结点 L = (LinkList)malloc(sizeof(LNode)); L.next=NULL; r-L; 申请一个新的结点空间，存入元素值 p=(LinkList)malloc(sizeof(LNode)); p-\u003edata=ai; p-\u003enext=NULL; 将新结点插入链表尾部，r指向最后结点 r-\u003enext=p; r=p; 重复2，3步骤直到最后一个结点，结束 用表尾插入法建立带头结点的单链表 基本步骤 初始化指针Head和指向最后结点的指针r head=NULL; r=NULL; 申请一个新的结点并令p指向该结点，存入元素值 将新结点插入表尾 r-\u003enext=p; r=p; //注：表尾插入法建立的链表与输入元素顺序一致 //1.当r指向非空结点时使用上面的语句 //2.当r指向空地址时 head=p;r=p; 重复2，3步骤直到最后一个结点，结束 用表尾插入法建立不带头结点的单链表(元素为字符，C语言) LinkList CreateList_LT(){ char ch; LinkList head; LNode *p,*r; //p指向新申请的结点，r指向链表的尾结点 head=NULL; r=NULL; while((ch=getchar())!='\\n'){ p=(LNode *)malloc(sizeof(LNode)); p-\u003edata=ch; if(head==NULL) //插入第一个结点 head=p; else r-\u003enext=p; //插入第二个及以后的结点 r=p; } if(r!=NULL) r-\u003enext=NULL; return(head); } 线性单链表删除 用类C语言实现线性单链表上的删除 Status ListDelete_L(LinkList \u0026L,int i,ElemType \u0026e){ //在带头结点的单链线性表L中，删除第i个元素，并由e返回其值 p=L;j=0; while(p-\u003enext\u0026\u0026j\u003ci-1){ 寻找第i个结点，并令p指向其前驱 p=p-\u003enext; ++j; } if(!(p-\u003enext)||j\u003ei-1) return ERROR; //删除位置不合理 q=p-\u003enext; p-\u003enext=q-\u003enext; //删除并释放结点 e=q-\u003edata; free(q); return OK; }//ListDelete_ ","date":"2024-03-10","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%842/:6:6","tags":["数据结构"],"title":"数据结构(第二章)","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%842/"},{"categories":["数据结构"],"content":"循环单链表和双向链表 双向链表的插入操作(将元素e插入到链表的第i个结点前) 基本步骤 定位指针p指向结点$a_{i-1}$ 建立新结点s并赋e; 修改s的next指针域指向p下一结点 s-\u003enext=p-\u003enext; 修改s的prior指针域指向p结点 s-\u003eprior=p 修改p的next指针域指向s结点 p-\u003enext=s 修改s的下一结点的prior指针域指向s s-\u003enext-prior=s 用类C语言实现双向循环链表插入 Status ListInsert_DuL(DuLinkList \u0026L,int i,ElemType e){ //在带头结点的双链循环线性表L中第i个位置之前插入元素e //i的合法值为1\u003c=i\u003c=表长+1 if(!(p=GetElemP_DuL(L,i))) //在L中确定插入位置指针p return ERROR; //i等于表长加1时，p指向头结点；i大于表长加1时，p=NULL if(!(s=(DuLinkList)malloc(sizeof(DuLNode)))) return ERROR; s-\u003edata=e; s-\u003eprior=p-\u003eprior; p-\u003eprior-\u003enext=s; s-\u003enext=p; p-\u003eprior=s; return OK; }//ListInsert_DuL 双向链表的删除操作(删除第i个结点) 基本步骤 定位指针p指向结点$a_i$ 修改p的前一结点的next指针域指向p下一结点 p-\u003eprior-\u003enext=p-\u003enext; 修改p的下一结点的prior指针域指向p前一结点 p-\u003enext-prior=p-\u003eprior; 释放结点p 用类C语言实现双向循环链表删除 Status ListDelete_DuL(DuLinkList \u0026L,int i,ElemType \u0026e){ //删除带头结点的双链循环线性表L的第i个元素，i的合法值为1\u003c=i\u003c=表长 if(!(p=GetElemP_DuL(L,i))) //在L中确定第i个元素的位置指针p return ERROR; //P=NULL,即第i个元素不存在 e=p-\u003edata; p-\u003eprior-\u003enext=p-\u003enext; p-\u003enext-\u003eprior=p-\u003eprior; free(p); return OK; }//ListDelete_DuL 双向循环链表 合并线性表 Status MergeList_L(LinkList \u0026La,LinkList \u0026Lb,LinkList \u0026Lc,int(*compare)(ElemType,ElemType)){ //已知单链线性表La和Lb的元素按值非递减排列 //归并La和Lb得到新的单链线性表Lc，Lc的元素也按值非递减排列 if(!InitList(Lc)) return ERROR; //存储空间分配失败 ha=GetHead (La); hb=GetHead (Lb); ∥ha和hb分别指向La和Lb的头结点 pa=NextPos (La,ha); pb=NextPos (Lb,hb); ∥pa和pb分别指向La和Lb中当前结点 while(pa\u0026\u0026pb){ ∥La和Lb均非空 a=GetCurElem (pa); b=GetCurElem (pb); ∥a和b为两表中当前比较元素 if(( * compare) ( a, b) \u003c o){ a\u003c=b; DelFirst(ha,g); Append(Lc,g); pa= NextPos(La,ha); }else{ a\u003eb; DelFirst(hb,g); Append( Lc,q); pb=NextPos(Lb,hb); }∥while if (pa) Append( Lc, pa); ∥链接La中剩余结点 else Append(Lc,pb); ∥链接b中剩余结点 FreeNode(ha); FreeNode (hb); ∥释放La和Lb的头结点 return OK; }∥MergeList _L ","date":"2024-03-10","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%842/:6:7","tags":["数据结构"],"title":"数据结构(第二章)","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%842/"},{"categories":["数据结构"],"content":"一元多项式的表示及相加 一元多项式的形式 $A(x)=p_0+p_1x+p_2x^2+ \\cdots + p_ix^i+p_nx^n$ 存储形式 线性表多项式相加 如图，两个线性链表分别表示一元多项式$A_{17}(x)=7+3x+9x^8+5x^{17}$和一元多项式$B_8(x)=8X+22x^7-9x^8$.从图中可见，每个结点表示多项式中的一项 其相加得到： ","date":"2024-03-10","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%842/:7:0","tags":["数据结构"],"title":"数据结构(第二章)","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%842/"},{"categories":["面向对象程序设计"],"content":"c++的产生 c++是从c语言发展演变而来的，引入了类的机制，最初也被称为\"带类的C\" ","date":"2024-03-09","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/:0:0","tags":["面向对象程序设计"],"title":"c++(two)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/"},{"categories":["面向对象程序设计"],"content":"特点 保持c的简洁，高效和接近汇编语言等特点 对c的类型系统进行改革和扩充 c++也支持面向过程的程序设计，不是一个纯正的面向对象的语言 支持面向对象的方法 ","date":"2024-03-09","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/:1:0","tags":["面向对象程序设计"],"title":"c++(two)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/"},{"categories":["面向对象程序设计"],"content":"实例 #include\u003ciostream\u003e using namespace std; int main(){ ​ cout\u003c\u003c\"Hello\\n\"; ​ cout\u003c\u003c\"Welcome to c++!\\n\"; } 结果 Hello! Welcome to c++! ","date":"2024-03-09","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/:2:0","tags":["面向对象程序设计"],"title":"c++(two)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/"},{"categories":["面向对象程序设计"],"content":"实例说明 在新的c++标准程序库中，所有标识符都声明在命名空间std中，且头文件不使用扩展名 头文件使用旧版(带扩展名)和新版(不带扩展名)皆可，但不可以混用 名字空间防止命名冲突 1. 命名空间声明： namespace NS{ ​ class File; ​ void fun(); } 2. 命名空间内标识符使用： NS::File obj; NS::Fun(); 3. 简洁方法: using namespace NS; 函数 把相关的语句组织在一起，注明相应的名称，利用这种方法把程序分块，这种形式的组合就叫做函数 一个c++程序由一个主函数(main)和若干个函数构成 ","date":"2024-03-09","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/:3:0","tags":["面向对象程序设计"],"title":"c++(two)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/"},{"categories":["面向对象程序设计"],"content":"分类 标准库函数和用户自定义函数 由主函数调用其他函数，其他函数也可以相互调用 ","date":"2024-03-09","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/:4:0","tags":["面向对象程序设计"],"title":"c++(two)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/"},{"categories":["面向对象程序设计"],"content":"函数驱动机制 ","date":"2024-03-09","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/:5:0","tags":["面向对象程序设计"],"title":"c++(two)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/"},{"categories":["面向对象程序设计"],"content":"c++字符集 大小写的英文字母：A~Z,a~z 数字字符:0~9 特殊字符： 空格 ! # % ^ \u0026 * __(下划线) + = -(减号) ~ \u003c \u003e / \\ ’ \" ; . , () [ ] {} 关键字 https://blog.csdn.net/wuxinliulei/article/details/9787901 ","date":"2024-03-09","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/:6:0","tags":["面向对象程序设计"],"title":"c++(two)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/"},{"categories":["面向对象程序设计"],"content":"词法记号 关键字：C++预定义的单词 标识符：程序员声明的单词，它命名程序正文的一些实体 文字：在程序中直接使用符号表示的数据 操作符：用于实现各种运算的符号 分隔符：用于分隔各个词法记号或程序正文，分隔符是() {} , ; 空白：空格，制表符（TAB键产生的字符），换行符（Enter键所产生的字符）和注释的总称 ","date":"2024-03-09","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/:6:1","tags":["面向对象程序设计"],"title":"c++(two)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/"},{"categories":["面向对象程序设计"],"content":"标识符的构成规则 以大写字母，小写字母或下划线(_)开始 可以由以大写字母，小写字母，下划线(_)或数字0·9组成 大写字母和小写字母代表不同的标识符 注释两种(/….****/或则//) 基本数据类型和表达式 ","date":"2024-03-09","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/:6:2","tags":["面向对象程序设计"],"title":"c++(two)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/"},{"categories":["面向对象程序设计"],"content":"C++的基本数据类型 ","date":"2024-03-09","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/:6:3","tags":["面向对象程序设计"],"title":"c++(two)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/"},{"categories":["面向对象程序设计"],"content":"数据类型 常量与变量 整型数据 ","date":"2024-03-09","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/:6:4","tags":["面向对象程序设计"],"title":"c++(two)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/"},{"categories":["面向对象程序设计"],"content":"变量 在程序执行过程中其值可以变化的量，需用名字标识 ","date":"2024-03-09","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/:7:0","tags":["面向对象程序设计"],"title":"c++(two)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/"},{"categories":["面向对象程序设计"],"content":"声明和定义 变量在使用之前需要首先声明其类型和名称 ","date":"2024-03-09","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/:7:1","tags":["面向对象程序设计"],"title":"c++(two)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/"},{"categories":["面向对象程序设计"],"content":"声明语句的形式 ","date":"2024-03-09","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/:7:2","tags":["面向对象程序设计"],"title":"c++(two)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/"},{"categories":["面向对象程序设计"],"content":"变量赋初值 注：C++中有字符串常量，却无字符串变量 ","date":"2024-03-09","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/:7:3","tags":["面向对象程序设计"],"title":"c++(two)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/"},{"categories":["面向对象程序设计"],"content":"整型数据及取值范围 实型数据 字符型数据(一) 布尔型数据 ","date":"2024-03-09","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/:8:0","tags":["面向对象程序设计"],"title":"c++(two)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/"},{"categories":["面向对象程序设计"],"content":"符号常量 为常量命名，这就是符号常量 符号常量在使用之前一定要首先声明 常量声明语句的形式 符号常量在声明时一定要赋初值，而在程序中间不能改变其值 例： ","date":"2024-03-09","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/:8:1","tags":["面向对象程序设计"],"title":"c++(two)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/"},{"categories":["面向对象程序设计"],"content":"不同类型数据混合运算时的类型转换 不同类型数据进行混合运算时，C++编译器会自动进行类型转换 为了避免不同的数据类型在运算中出现混淆，应尽量使用同种类型数据。 可以采用强制类型转换： 例如： ","date":"2024-03-09","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/:8:2","tags":["面向对象程序设计"],"title":"c++(two)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/"},{"categories":["面向对象程序设计"],"content":"变量的存储类型 auto:采用堆栈方式分配内存空间，属于暂时性存储，其存储空间可以被若干变量多次覆盖使用 register:存放在通用寄存器中 extern:在所有函数和程序段中都可以引用 static:在内存中都是以固定地址存放的，在整个程序运行期间都有效 运算符和表达式 ","date":"2024-03-09","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/:9:0","tags":["面向对象程序设计"],"title":"c++(two)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/"},{"categories":["面向对象程序设计"],"content":"表达式是计算求值的基本单位 表达式组成 有运算符(例：+，-，*，/)，运算量(也称操作符，可以是常量，变量等等)和括号组成 例：a+b,x/y 表达式的值 执行表达式所规定的运算，所得到的结果值是表达式的值 表达式的定义 一个常量或表示对象的标识符是一个最简单的表达式，其值是常量或对象的值 一个表达式的值可以用来参与其他操作，即用作其他运算符的操作数，这就形成了更复杂的表达式 包括在括号中的表达式仍是一个表达式，其类型和值与未加括号时的表达式相同 运算符的种类：算术，关系，逻辑。 运算符的分类： 一元运算符(单目运算符) 二元运算符(双目运算符) ","date":"2024-03-09","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/:9:1","tags":["面向对象程序设计"],"title":"c++(two)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/"},{"categories":["面向对象程序设计"],"content":"算术运算符与算术表达式 基本算术运算符 优先级与结核性 先乘除，后加减，同级自左至右 ++，– 例：i++;j–； ","date":"2024-03-09","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/:10:0","tags":["面向对象程序设计"],"title":"c++(two)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/"},{"categories":["面向对象程序设计"],"content":"增量和减量运算符 增量运算符：前增量和后增量 前增量操作++a:先修改变量使之增1，然后将增1过的a的值作为表达式的值 后增量操作a++:先将变量a的值作为表达式的值确定下来，再将a增1 ","date":"2024-03-09","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/:11:0","tags":["面向对象程序设计"],"title":"c++(two)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/"},{"categories":["面向对象程序设计"],"content":"赋值运算符和赋值表达式 ","date":"2024-03-09","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/:12:0","tags":["面向对象程序设计"],"title":"c++(two)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/"},{"categories":["面向对象程序设计"],"content":"简单的赋值运算符 “=” 例：n=n+5,a=b=c=5 作用 将等号右边表达式的值赋给等号左边的对象 类型 等号左边对象的类型 值 等号左边对象被赋值后的值 运算的结合性为自右向左 ","date":"2024-03-09","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/:12:1","tags":["面向对象程序设计"],"title":"c++(two)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/"},{"categories":["面向对象程序设计"],"content":"复合的赋值运算符 有10种符合运算符 这10种复合的赋值运算都是二元运算符，优先级与“=”相同，结合性也是自右向左。 ","date":"2024-03-09","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/:12:2","tags":["面向对象程序设计"],"title":"c++(two)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/"},{"categories":["面向对象程序设计"],"content":"逗号运算和逗号表达式 格式 表达式1，表达式2 求解顺序及结果 先求解1，再求解2，最终结果为表达式2的值，若多个表达式，结果为最后表达式的值 ","date":"2024-03-09","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/:13:0","tags":["面向对象程序设计"],"title":"c++(two)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/"},{"categories":["面向对象程序设计"],"content":"关系运算与关系表达式 关系运算是比较简单的一种逻辑运算，优先次序为： 关系表达式是一种最简单的逻辑表达式其结果类型为bool，值只能为true或false. 关系运算 关系运算的结果true或false是逻辑值 关系运算在C++中，0表示假，任意一个非0的数都表示真 关系运算注意不要将=和==用错 ","date":"2024-03-09","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/:14:0","tags":["面向对象程序设计"],"title":"c++(two)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/"},{"categories":["面向对象程序设计"],"content":"逻辑运算与逻辑表达式 逻辑运算符 !(非) \u0026\u0026(与) ||(或) 优先次序：高$\\rightarrow$ 低 逻辑表达式 其结果类型为bool，值只能为true或false. ","date":"2024-03-09","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/:15:0","tags":["面向对象程序设计"],"title":"c++(two)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/"},{"categories":["面向对象程序设计"],"content":"条件运算符与条件表达式 一般形式 表达式1?表达式2:表达式3 表达式1必须是bool类型 执行顺序 先求解表达式1 若表达式1的值为true，则求解表达式2，表达式2的值为最终结果 若表达式1的值为false，则求解表达式3，表达式3的值为最终结果 ","date":"2024-03-09","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/:16:0","tags":["面向对象程序设计"],"title":"c++(two)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/"},{"categories":["面向对象程序设计"],"content":"sizeof操作符 语法形式 sizeof(类型名)或sizeof(表达式) 结果值 “类型名”所指定的类型或“表达式”的结果类型所占的字节数 注意不用对括号中的表达式本身求值 ","date":"2024-03-09","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/:17:0","tags":["面向对象程序设计"],"title":"c++(two)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/"},{"categories":["面向对象程序设计"],"content":"位运算(按位与(\u0026)) 运算规则 将两个运算量的每一个位进行逻辑与操作 用途 将某一位置0，其它位不变。例如： 将char型变量a的最低位置0：a=a\u00260376; 取指定位。例如： ","date":"2024-03-09","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/:18:0","tags":["面向对象程序设计"],"title":"c++(two)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/"},{"categories":["面向对象程序设计"],"content":"位运算(按位或(|)) 运算规则 将两个运算量的每一个位进行逻辑或操作 用途 将某些位置1，其它位不变。 例如：将int型变量a的低字节位置1： a=a|0xff; ","date":"2024-03-09","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/:19:0","tags":["面向对象程序设计"],"title":"c++(two)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/"},{"categories":["面向对象程序设计"],"content":"位运算(按位异或(^)) 运算规则 两个操作数进行异或： 若对应位相同，则结果该位为0 若对应位不同，则结果该位为1 用途 使特定位翻转(与0异或保持原值，与1异或取反) 例如： ","date":"2024-03-09","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/:20:0","tags":["面向对象程序设计"],"title":"c++(two)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/"},{"categories":["面向对象程序设计"],"content":"位运算(取反(~)) 单目运算符 对一个二进制数按位取反 ","date":"2024-03-09","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/:21:0","tags":["面向对象程序设计"],"title":"c++(two)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/"},{"categories":["面向对象程序设计"],"content":"位运算(移位) ","date":"2024-03-09","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/:22:0","tags":["面向对象程序设计"],"title":"c++(two)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/"},{"categories":["面向对象程序设计"],"content":"左移运算(«) 左移后，低位补0，高位舍弃 ","date":"2024-03-09","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/:22:1","tags":["面向对象程序设计"],"title":"c++(two)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/"},{"categories":["面向对象程序设计"],"content":"右移运算 右移后，低位：舍弃； 高位： 无符号数：补0 有符号数：补“符号数” ","date":"2024-03-09","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/:22:2","tags":["面向对象程序设计"],"title":"c++(two)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/"},{"categories":["面向对象程序设计"],"content":"运算符优先级 ","date":"2024-03-09","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/:23:0","tags":["面向对象程序设计"],"title":"c++(two)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/"},{"categories":["面向对象程序设计"],"content":"混合运算时数据类型的转换(隐含转换) 一些二元运算符(算符运算符，关系运算符，逻辑运算符，位运算符和赋值运算符)要求两个操作数的类型一致 在算数运算和关系运算中如果参与运算的操作数类型不一致，编译系统会自动对数据进行转换(即隐含转换)，基本原则是将低类型数据转换为高类型数据。 类型转换的规则举例 ","date":"2024-03-09","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/:24:0","tags":["面向对象程序设计"],"title":"c++(two)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/"},{"categories":["面向对象程序设计"],"content":"混合运算时数据类型的转换(强制类型转换) 语法形式： 类型说明符(表达式)或(类型说明符)表达式 强制类型转换的作用是将表达式的结果类型转换为类型说明符所指定的类型 强制类型转换的规则举例 ","date":"2024-03-09","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/:25:0","tags":["面向对象程序设计"],"title":"c++(two)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/"},{"categories":["面向对象程序设计"],"content":"语句 ","date":"2024-03-09","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/:26:0","tags":["面向对象程序设计"],"title":"c++(two)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/"},{"categories":["面向对象程序设计"],"content":"C++语言的语句 声明语句，表达式语句，选择语句，循环语句，跳转语句，复合语句，标号语句几类。 ","date":"2024-03-09","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/:26:1","tags":["面向对象程序设计"],"title":"c++(two)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/"},{"categories":["面向对象程序设计"],"content":"表达式与表达式语句的区别 表达式可以包含在其它表达式中，而语句不能。 注意 C++语言没有赋值语句也没有函数调用语句，赋值与函数调用功能都是通过表达式来实现的。 如果在赋值表达式后面加上分号，便成了语句。 数据的输入与输出 ","date":"2024-03-09","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/:26:2","tags":["面向对象程序设计"],"title":"c++(two)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/"},{"categories":["面向对象程序设计"],"content":"I/O流 ","date":"2024-03-09","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/:27:0","tags":["面向对象程序设计"],"title":"c++(two)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/"},{"categories":["面向对象程序设计"],"content":"流 在C++中，将数据从一个对象到另一个对象的流动抽象为“流” ","date":"2024-03-09","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/:27:1","tags":["面向对象程序设计"],"title":"c++(two)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/"},{"categories":["面向对象程序设计"],"content":"提取操作 从流中获取数据的操作称为提取操作 ","date":"2024-03-09","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/:27:2","tags":["面向对象程序设计"],"title":"c++(two)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/"},{"categories":["面向对象程序设计"],"content":"插入操作 向流中添加数据的操作称为插入操作 ","date":"2024-03-09","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/:27:3","tags":["面向对象程序设计"],"title":"c++(two)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/"},{"categories":["面向对象程序设计"],"content":"预定义的插入符和提取符 数据的输入和输出通过I/O流(stream)来实现 插入操作符“«” 预定义的流类对象cout cout用来处理标准输出，即屏幕输出格式：cout«表达式«表达式… 提取操作符“»” 预定义的流类对象：cin cin用来处理标准输入，即键盘输入 **格式：cin»表达式»表达式… ** 例： int x,y; cin\u003e\u003ex\u003e\u003ey; 从键盘上输入两个int型数，两数之间以空格分隔。 ","date":"2024-03-09","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/:28:0","tags":["面向对象程序设计"],"title":"c++(two)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/"},{"categories":["面向对象程序设计"],"content":"I/O标准流类 ","date":"2024-03-09","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/:29:0","tags":["面向对象程序设计"],"title":"c++(two)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/"},{"categories":["面向对象程序设计"],"content":"标准流的设备名 ","date":"2024-03-09","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/:29:1","tags":["面向对象程序设计"],"title":"c++(two)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/"},{"categories":["面向对象程序设计"],"content":"cout原理 cout是iostream流类的对象，它在iostream头文件中作为全局对象定义： ostream cout(stdout) 标准设备名作为其构造时的参数 ","date":"2024-03-09","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/:29:2","tags":["面向对象程序设计"],"title":"c++(two)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/"},{"categories":["面向对象程序设计"],"content":"cin原理 cin是istream全局对象 除了标准输入输出设备，还有标准错误设备cerr ","date":"2024-03-09","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/:29:3","tags":["面向对象程序设计"],"title":"c++(two)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/"},{"categories":["面向对象程序设计"],"content":"简单的I/O格式控制 流的默认格式输出有时不能满足特殊要求 希望显示的是9.40，即保留两位小数，可是却显示了9.40007；默认显示6位有效位 用控制符(manipulators)可以对I/O流1的格式进行控制 ","date":"2024-03-09","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/:30:0","tags":["面向对象程序设计"],"title":"c++(two)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/"},{"categories":["面向对象程序设计"],"content":"I/O流的常用控制符 ","date":"2024-03-09","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/:30:1","tags":["面向对象程序设计"],"title":"c++(two)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/"},{"categories":["面向对象程序设计"],"content":"I/O流的常用控制符(举例) **例：控制浮点数值显示 ** 设置值的输出宽度 除了使用空格来强制输出间隔外，还可以用setw(n)控制符。 如果一个值需要比setw(n)确定的字符数更多的字符，则该值将用它所需要的所有字符 超过setw(4)将会原样输出 如果一个值的字符比setw(n)确定的字符个数少，则在数字字符前显示空白。 若要每个数值都有宽度8，则每个值都要设置 输出8进制和16进制 3个常用的控制符是hex,oct和dec 这3个控制符在iostream.h头文件中定义 设置填充字符 用setfill控制符可以确定一个非空格的别的字符 setfill在头文件iomanip.h中定义 左右对齐输出 默认时，I/O流左对齐显示的内容。 使用头文件iomanip.h中的setiosflags(ios::left)可输出左对齐 使用头文件iomanip.h中的setiosflags(ios::right)可输出右对齐 强制显示小数 使用头文件iomanip.h中的setiosflags(ios::showpoint)可强制显示小数(后六位，包括小数点)以及显示正负号 ","date":"2024-03-09","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/:30:2","tags":["面向对象程序设计"],"title":"c++(two)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/"},{"categories":["面向对象程序设计"],"content":"算法的基本控制结构 顺序结构，分支结构，循环结构 ","date":"2024-03-09","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/:31:0","tags":["面向对象程序设计"],"title":"c++(two)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/"},{"categories":["面向对象程序设计"],"content":"if语句(多种形式) if语句(空语句) 编译器必须在if条件表达式的后面找到一个作为语句结束的分号“;”，以标志if语句的结束。 例： if(条件表达式)：//空语句做if中的语句 语句; 则不管条件表达式为真为假，总是接着执行语句 else if 语句 if语句(嵌套) 一般形式 c++ if() if() 语句1 else 语句2 else if() 语句3 else 语句4 注意 语句1，2，3，4可以是复合语句，每层的if与else配对，或用{}来确定层次关系 ","date":"2024-03-09","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/:31:1","tags":["面向对象程序设计"],"title":"c++(two)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/"},{"categories":["面向对象程序设计"],"content":"switch语句(特殊的多分支结构) 一般形式 特殊的多分支结构 执行顺序 以case中的常量表达式值为入口标号，由此开始顺序执行。因此，每个case分支最后应该加break语句 例：输入一个0~6的整数，转换成星期输出 #include\u003ciostream\u003e void main(void){ int day; cin\u003e\u003eday; switch(day){ case0:cout\u003c\u003c\"Sunday\"\u003c\u003cendl;break; case1:cout\u003c\u003c\"Monday\"\u003c\u003cendl;break; case2:cout\u003c\u003c\"Tuesday\"\u003c\u003cendl;break; case3:cout\u003c\u003c\"Wednesday\"\u003c\u003cendl;break; case4:cout\u003c\u003c\"Thursday\"\u003c\u003cendl;break; case5:cout\u003c\u003c\"Friday\"\u003c\u003cendl;break; case6:cout\u003c\u003c\"Saturday\"\u003c\u003cendl;break; default: cout\u003c\u003c\"Day out of range Sunday...Saturday\"\u003c\u003cendl;break; } } 使用switch语句应注意的问题 case分支可包含多个语句，且不用{}. switch语句后面的表达式，可以是整型，字符型，枚举型 各个常量表达式的值不能相同，但次序不影响执行结果 每个case分支的最后应该加break语句，用来结束整个switch结构 当若干分支需要执行相同操作时，可以使多个case分支共用一组语句 ","date":"2024-03-09","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/:31:2","tags":["面向对象程序设计"],"title":"c++(two)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/"},{"categories":["面向对象程序设计"],"content":"循环语句(while) 形式： while(条件表达式) 循环体 //可以是复合语句，其中必须含有改变条件表达式值的语句 执行顺序 先判断表达式的值，为true时，再执行循环体 组成 while循环由四部分组成：循环变量初始化，继续条件，循环体，改变循环变量的值。 例： #include\u003ciostream\u003e void main(){ inti(1),sum(0); //循环变量初始化 while(i\u003c=10) //继续条件 { //循环体 sum+=i; i++; //改变循环体变量的值 } cout\u003c\u003c\"sum=\"\u003c\u003csum\u003c\u003cendl; } do-while语句 一般形式 do //语句(可以是复合语句，其中必须含有改变条件表达式值的语句) while(条件表达式) 例：用2-7用do-while语句编程，求自然数1~10之和 #include\u003ciostream\u003e void main(){ int i(1),sum(0); do { sum+=i; i++; }while(i\u003c=10); cout\u003c\u003c\"sum=\"\u003c\u003csum\u003c\u003cendl; } do-while循环在循环的底部进行继续条件的测试，所以它至少执行一次循环体 while循环在循环的顶部进行测试，有可能永远不执行循环体 do-while循环中，while(条件表达式)后面的分号不要遗忘 ","date":"2024-03-09","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/:31:3","tags":["面向对象程序设计"],"title":"c++(two)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/"},{"categories":["面向对象程序设计"],"content":"for语句 语法形式 for(表达式1;表达式2;表达式3)语句 表达式1：循环先求解； 表达式2：循环控制条件，根据表达式2的值判断是否执行循环体，如果表达式2的值为true，则执行一次循环体；如果为false，则退出循环 表达式3：每执行一次循环体后，计算表达式3的值，然后再计算表达式2，根据表达式2的值决定是否继续执行循环体 表达式1，2，3都可以省略，分号不能省略 例：for(;;)语句 //相当于while(true)语句 表达式1一般用于给循环变量赋初值 表达式1可以省略.此时应在for语句之前给循环变量赋初值。若省略表达式1，其后的分号不能省略。 例：求和运算 i=1; for(;i\u003c=100;i++) //分号不能省略 sum+=i; for语句的几点说明 表达式2是循环控制条件，如省略，循环将无终止地进行下去。 例：求和运算 for(i=1;;i++){ //分号不能省略 sum+=i; if(i\u003e=100) break; } //等价于 for(i=1;1;i++){ sum+=i; if(i\u003e=100) break; } 表达式3一般用于改变循环控制条件的值. 如果表达式3省略或者是其他与循环条件无关的表达式，则应该在循环体中另有语句改变循环条件，以保证循环能正常结束。 例：求和运算 for(i=1;i\u003c=100) //分号不能省略 sum+=i++ //同时改变循环变量 表达式1和表达式3可同时省略 i=1; for(;i\u003c=100;) //分号不能省略 sum+=i++; //同时改变循环变量 表达式1和表达式3都为逗号表达式； for(i=0,j=100,k=0;i\u003c=j;i++,j--) k+=i*j; 表达式2和表达式3可以为赋值或算术表达式的情况； for(i=1;i\u003c=100;sum+=i++); //循环为空语句 for(i=1;sum+=i++,i\u003c=100;); //表达式3省略，循环为空语句 ","date":"2024-03-09","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/:31:4","tags":["面向对象程序设计"],"title":"c++(two)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/"},{"categories":["面向对象程序设计"],"content":"循环结构的嵌套 #include\u003ciostream\u003e void mian(){ int i(1),a(0); for(;i\u003c=5;i++){ do{ i++; a++; }while(i\u003c3); i++; } cout\u003c\u003ca\u003c\u003c\",\"\u003c\u003ci\u003c\u003cendl; } 循环结构与选择结构相互嵌套 #include\u003ciostream\u003e void main(){ int n; for(n=100;n\u003c=200;n++){ if(n%3!=0) printf(\"%d\",n); } } ","date":"2024-03-09","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/:31:5","tags":["面向对象程序设计"],"title":"c++(two)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/"},{"categories":["面向对象程序设计"],"content":"break和continue语句 break语句: 用在while,do-while,for和switch结构中在switch语句中，break使流程跳出switch语句中，break使流程跳出switch语句，继续执行switch后的语句在循环语句中，break用来从最近的封闭循环体中跳出 continue语句： 结束本次循环，接着判断是否执行下一次循环 区别 continue语句只结束本次循环；而不是终止整个循环的执行 break语句则是结束本次循环，不再进行条件判断。在循环语句中，break用来从最近的封闭循环体中跳出 ","date":"2024-03-09","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/:31:6","tags":["面向对象程序设计"],"title":"c++(two)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/"},{"categories":["面向对象程序设计"],"content":"自定义数据类型(typedef声明) 为一个已有的数据类型另外命名 语法形式 typedef 已有类型名 新类型名表; 例如： typedef double area,volume; typedef int natural; natural i1,i2; area a; volume v; ","date":"2024-03-09","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/:32:0","tags":["面向对象程序设计"],"title":"c++(two)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/"},{"categories":["面向对象程序设计"],"content":"枚举类型 只要将需要的变量值一一列举出来便构成了一个枚举类型 枚举类型的声明形式： enum 枚举类型名 {变量值列表}; 例如： enum weekday {sun,mon,tue,wed,thu,fri,sat}; 注：整数值不能直接赋给枚举变量，如需要将整数赋值给枚举变量，应进行强制类型转换 #include\u003ciostream\u003e using namespace std; enum game_result{WIN,LOSE,TIE,CANCEL}; void main(){ game_result result; //声明变量时，可以不写关键字enum enum game_result omit=CANCEL; //也可以在类型名前写enum int count; for(count=WIN;count\u003c=CANCEL;count++){ result=(game_result)count; //强制类型转换，小类型可以转大类型，大类型转小类型必须要强制转换 if(result==omit){ cout\u003c\u003c\"The game was cancelled\\n\"; } else{ cout\u003c\u003c\"The game was played\"; if(result==WIN) cout\u003c\u003c\"and we won\"; if(result==LOSE) cout\u003c\u003c\"and we lose\"; cout\u003c\u003c\"\\n\"; } } } ","date":"2024-03-09","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/:32:1","tags":["面向对象程序设计"],"title":"c++(two)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/"},{"categories":["面向对象程序设计"],"content":"结构体(结构体的声明) 概念：结构是由不同的数据类型的数据组成的 声明结构体类型 struct 结构名{ 数据类型 成员名1； 数据类型 成员名2； . . 数据类型 成员名3； }; 例：结构体变量的初始化和使用 #include\u003ciostream\u003e #include\u003ciomanip\u003e struct student{ //学生信息结构体 int num; char name[20]; char sex; int age; }stu={97001,\"LinLin\",'F',19}; //在定义结构体的同时，生命结构类型的变量stu void main(){ cout\u003c\u003csetw(7)\u003c\u003cstu,num\u003c\u003csetw(10)\u003c\u003cstu.name\u003c\u003cset(3)\u003c\u003cstu.sex \u003c\u003csetw(3)\u003c\u003cstu.age\u003c\u003cendl; } ","date":"2024-03-09","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/:33:0","tags":["面向对象程序设计"],"title":"c++(two)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/"},{"categories":["面向对象程序设计"],"content":"结构体(结构变量说明) 变量说明形式 结构名 结构变量名； 注意： 结构变量的存储类型概念，它的寿命，可见性及使用范围与普通变量完全一致 结构变量说明在结构类型声明之后，二者也可同时进行 结构变量占用内存大小可用sizeof运算求出：sizeof(类型名) 说明结构变量的同时可以直接设置初值 在定义结构体类型的同时声明变量 struct student{ //学生信息结构体 int num; char name[20]; char sex; int age; float score; char addr[30]; }stu1,stu2; 直接定义变量 struct //省略结构体名称 { int num; char name[20]; char sex; int age; float score; char addr[30]; }stu1,stu2; 用typedef关键字给结构体取个别名 typedef struct student //学生信息结构 { int num; char name[20]; char sex; int age; float score; char addr[30]; }postgraduate; 定义2个struct student 类型的变量 postgraduate stu1,stu2 可以先定义结构体类型，然后取别名 struct student //学生信息结构 { ..... } typedef struct student postgraduate; 也可以省略结构体名称student typedef struct //学生信息结构体 { ..... }postgraduate; 下面几种情况要分清楚 struct student //student是类型名 { ..... }; typedef struct { ..... }postgraduate; //postgraduate是类型名 typedef student postgraduate //postgraduate是类型名 struct{ .... }stu; //stu是变量名 struct student //student是类型名 { ..... }stu; //stu是变量名 struct student stu; //stu是变量名 typedef struct student{ //student是类型名 ... }STUDENT; //STUDENT是类型名，是student的别名 ","date":"2024-03-09","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/:33:1","tags":["面向对象程序设计"],"title":"c++(two)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/"},{"categories":["面向对象程序设计"],"content":"结构体(结构变量的初始化和使用) 初始化 说明结构变量的同时可以直接设置初值。 struct student stu={97001,\"李明\",'M',16,92,\"北京市\"} 但一定要注意，不能在定义结构体类型的时候，进行赋初值 struct student //下面的做法是错误的 { int num =97001; char name[20] = “Li Lin”; char sex= “M”; int age = 16; float score = 92; char addr[30] = “123 Bejing Road”; }stu 使用(访问结构成员) 结构体成员的引用形式 结构变量名.成员名 例如： cout\u003c\u003cstu.num\u003c\u003c\",\"\u003c\u003cstu.name\u003c\u003c\",\"\u003c\u003cstu.sex\u003c\u003c\",\"\u003c\u003cstu.age \u003c\u003c\",\"\u003c\u003cstu.score\u003c\u003c\",\"\u003c\u003cstu.addr; 下面这些写法都是错误的 1.strcpy(student.name,\"wangli\"); //student是结构体类型名，不是结构体变量 2.stu.book=6 //结构体student中没有定义\"book\"这个成员 初始化结构体部分成员 使用赋值语句对它们进行初始化了。 例如： stu . Num = 97001; strcpy(stu . name, “李明”); stu . sex = ‘M’; stu . age = 16; stu . score = 91; strcpy(stu . addr, “北京”); 当然，使用输入语句也可以实现部分结构体成员的初始化 例： cin\u003e\u003estu.Age; 把结构体变量当作整体赋值 结构体变量整体赋值 例： stu2 = stu1; //通过这种模式，可以直接完成结构体之间的赋值 去结构体变量地址 例： cout\u003c\u003c\u0026stu1; //输出stu1的地址 cin\u003e\u003estu1.Age; //输入stu1的年龄 需要注意，不能把结构体变量整体输入进来 例： cin\u003e\u003estu1; //错误 逐级访问成员 #include\u003ciostream\u003e struct student //学生信息结构体 { int num; char name[20]; char sex; struct date { int month; int day; int year; }birthday; float score; char addr[30]; }stu; //对成员进行逐级访问 void main(){ stu.birthday.month=9; stu.birthday . day = 20; stu.birthday . year = 1996; cout\u003c\u003cstu.birthday .month\u003c\u003c\"/ \" \u003c\u003cstu.birthday . day\u003c\u003c\"/ \" \u003c\u003cstu.birthday . year\u003c\u003cendl; } 说明结构变量的同时可以直接设置初值 #include \u003ciostream.h\u003e #include \u003ciomanip.h\u003e struct student //学生信息结构体 { int num; //学号 char name[20]; //姓名 char sex; //性别 int age; //年龄 float score; //成绩 char addr[30]; //住址 }stu={97001,“李明”,‘F’,19, “北京“}; void main() { cout\u003c\u003csetw(7)\u003c\u003cstu.num\u003c\u003csetw(20) \u003c\u003cstu.name\u003c\u003csetw(3)\u003c\u003cstu.sex\u003c\u003csetw(3) \u003c\u003cstu.age \u003c\u003csetw(7) \u003c\u003cstu.addr\u003c\u003cendl; } ","date":"2024-03-09","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/:33:2","tags":["面向对象程序设计"],"title":"c++(two)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/"},{"categories":["面向对象程序设计"],"content":"联合体 声明形式 union 联合名 { 数据类型 成员名1; 数据类型 成员名2; . . 数据类型 成员名n; }; 联合体类型变量说明的语法形式 联合名 联合名变量; 引用形式 联合变量名.成员名 例： union uarea { char c_data; short s_data; long l_data; } 联合体可以不声明名称 例：声明无名联合体 union{ int i; float f; } 无名联合体通常作结构体的内嵌成员 例：适用于描述战斗机，轰炸机，运输机的结构体 # include \u003ciostream.h\u003e struct aircraft { int wingspan ; //翼幅 int passengers ; //乘客 union //无名联合作为结构体的内嵌成员 { float fuel _load; //战斗机装载的燃料 float bomb _load; //轰炸机装载的燃料 int pallets ; //运输机的货盘 }; } fighter,bomber,transport ; int main( ) { fighter . wingspan = 40 ; fighter . passengers = 1; fighter . fuel_load = 12000.0 ; bomber . wingspan = 90 ; bomber . passengers = 12; bomber . bomb_load = 14000.0 ; transport . wingspan = 106 ; transport . passengers = 4; transport .pallets = 42 ; transport . fuel_load = 18000.0 ; fighter . pallets = 4 ; cout\u003c\u003c“The fighter carries”\u003c\u003cfighter . Pallets\u003c\u003c“pallets.\\n”; cout\u003c\u003c“The bomber bomb load is”\u003c\u003cbomber . bomb_load\u003c\u003c“\\n”; return 0 ; } 运行结果 The fighter carries 4 pallets. The bomber bomb load is 14000 ","date":"2024-03-09","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/:34:0","tags":["面向对象程序设计"],"title":"c++(two)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/"},{"categories":["面向对象程序设计"],"content":"联合体类型的特点 从同一地址开始，将几个不同类型的变量存放到同一段内存单元中 同一个内存段可以用来存放几种不同类型的成员，但在每一瞬间只能存放其中一种，而不是同时存放几种。即每一瞬时只有一个成员起作用，其他成员不起作用 联合体变量中起作用的成员是最后一次存放的成员，在存入一个新的成员后原成员就失去作用。 ","date":"2024-03-09","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/:34:1","tags":["面向对象程序设计"],"title":"c++(two)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/"},{"categories":["hugo"],"content":"用Hugo配合Algolia实现高效美观的站内搜索 ","date":"2024-03-09","objectID":"/posts/%E7%94%A8hugo%E9%85%8D%E5%90%88algolia%E5%AE%9E%E7%8E%B0%E9%AB%98%E6%95%88%E7%BE%8E%E8%A7%82%E7%9A%84%E7%AB%99%E5%86%85%E6%90%9C%E7%B4%A2/:0:0","tags":["hugo"],"title":"用Hugo配合Algolia实现高效美观的站内搜索","uri":"/posts/%E7%94%A8hugo%E9%85%8D%E5%90%88algolia%E5%AE%9E%E7%8E%B0%E9%AB%98%E6%95%88%E7%BE%8E%E8%A7%82%E7%9A%84%E7%AB%99%E5%86%85%E6%90%9C%E7%B4%A2/"},{"categories":["hugo"],"content":"前言 很多的 Hugo 主题是没有自带搜索功能的，但是们为了方便用户浏览和查找内容是需要在网站上提供搜索功能。大家可以查看 Hugo 官方推荐的搜索方案，这里我选择的是 Algolia ， 折腾了很久，主题也从EVEN更新到了现在的LOVEIT，发现也并非很繁琐，以下是折腾后的成果。 ","date":"2024-03-09","objectID":"/posts/%E7%94%A8hugo%E9%85%8D%E5%90%88algolia%E5%AE%9E%E7%8E%B0%E9%AB%98%E6%95%88%E7%BE%8E%E8%A7%82%E7%9A%84%E7%AB%99%E5%86%85%E6%90%9C%E7%B4%A2/:1:0","tags":["hugo"],"title":"用Hugo配合Algolia实现高效美观的站内搜索","uri":"/posts/%E7%94%A8hugo%E9%85%8D%E5%90%88algolia%E5%AE%9E%E7%8E%B0%E9%AB%98%E6%95%88%E7%BE%8E%E8%A7%82%E7%9A%84%E7%AB%99%E5%86%85%E6%90%9C%E7%B4%A2/"},{"categories":["hugo"],"content":"在Algolia 端创建应用和索引 ","date":"2024-03-09","objectID":"/posts/%E7%94%A8hugo%E9%85%8D%E5%90%88algolia%E5%AE%9E%E7%8E%B0%E9%AB%98%E6%95%88%E7%BE%8E%E8%A7%82%E7%9A%84%E7%AB%99%E5%86%85%E6%90%9C%E7%B4%A2/:2:0","tags":["hugo"],"title":"用Hugo配合Algolia实现高效美观的站内搜索","uri":"/posts/%E7%94%A8hugo%E9%85%8D%E5%90%88algolia%E5%AE%9E%E7%8E%B0%E9%AB%98%E6%95%88%E7%BE%8E%E8%A7%82%E7%9A%84%E7%AB%99%E5%86%85%E6%90%9C%E7%B4%A2/"},{"categories":["hugo"],"content":"Application 点击NEW APPLICATION，Name可选，方案选择FREE，然后创建，随后的地区选择邻近地区即可； ","date":"2024-03-09","objectID":"/posts/%E7%94%A8hugo%E9%85%8D%E5%90%88algolia%E5%AE%9E%E7%8E%B0%E9%AB%98%E6%95%88%E7%BE%8E%E8%A7%82%E7%9A%84%E7%AB%99%E5%86%85%E6%90%9C%E7%B4%A2/:2:1","tags":["hugo"],"title":"用Hugo配合Algolia实现高效美观的站内搜索","uri":"/posts/%E7%94%A8hugo%E9%85%8D%E5%90%88algolia%E5%AE%9E%E7%8E%B0%E9%AB%98%E6%95%88%E7%BE%8E%E8%A7%82%E7%9A%84%E7%AB%99%E5%86%85%E6%90%9C%E7%B4%A2/"},{"categories":["hugo"],"content":"Indices \u0026 Index 点击侧栏的Indices，然后点击Create Index，Index name自定义（例如自己的域名） ","date":"2024-03-09","objectID":"/posts/%E7%94%A8hugo%E9%85%8D%E5%90%88algolia%E5%AE%9E%E7%8E%B0%E9%AB%98%E6%95%88%E7%BE%8E%E8%A7%82%E7%9A%84%E7%AB%99%E5%86%85%E6%90%9C%E7%B4%A2/:2:2","tags":["hugo"],"title":"用Hugo配合Algolia实现高效美观的站内搜索","uri":"/posts/%E7%94%A8hugo%E9%85%8D%E5%90%88algolia%E5%AE%9E%E7%8E%B0%E9%AB%98%E6%95%88%E7%BE%8E%E8%A7%82%E7%9A%84%E7%AB%99%E5%86%85%E6%90%9C%E7%B4%A2/"},{"categories":["hugo"],"content":"API Keys 点击侧栏API Keys，记住以下的 Keys，之后都会用到； ","date":"2024-03-09","objectID":"/posts/%E7%94%A8hugo%E9%85%8D%E5%90%88algolia%E5%AE%9E%E7%8E%B0%E9%AB%98%E6%95%88%E7%BE%8E%E8%A7%82%E7%9A%84%E7%AB%99%E5%86%85%E6%90%9C%E7%B4%A2/:2:3","tags":["hugo"],"title":"用Hugo配合Algolia实现高效美观的站内搜索","uri":"/posts/%E7%94%A8hugo%E9%85%8D%E5%90%88algolia%E5%AE%9E%E7%8E%B0%E9%AB%98%E6%95%88%E7%BE%8E%E8%A7%82%E7%9A%84%E7%AB%99%E5%86%85%E6%90%9C%E7%B4%A2/"},{"categories":["hugo"],"content":"在本地生成索引 ","date":"2024-03-09","objectID":"/posts/%E7%94%A8hugo%E9%85%8D%E5%90%88algolia%E5%AE%9E%E7%8E%B0%E9%AB%98%E6%95%88%E7%BE%8E%E8%A7%82%E7%9A%84%E7%AB%99%E5%86%85%E6%90%9C%E7%B4%A2/:3:0","tags":["hugo"],"title":"用Hugo配合Algolia实现高效美观的站内搜索","uri":"/posts/%E7%94%A8hugo%E9%85%8D%E5%90%88algolia%E5%AE%9E%E7%8E%B0%E9%AB%98%E6%95%88%E7%BE%8E%E8%A7%82%E7%9A%84%E7%AB%99%E5%86%85%E6%90%9C%E7%B4%A2/"},{"categories":["hugo"],"content":"config.yaml 在themes同级添加config.yaml文件,注意这里的key是Admin API Key。 --- baseurl: \"https://www.adan-ning.github.io\" DefaultContentLanguage: \"zh-cn\" hasCJKLanguage: true languageCode: \"zh-cn\" title: \"lqx's blog\" theme: \"loveit\" metaDataFormat: \"yaml\" algolia: index: \"**blogloveit\" key: \"*****9748e4cf6b\" appID: \"***KWB5\" --- ","date":"2024-03-09","objectID":"/posts/%E7%94%A8hugo%E9%85%8D%E5%90%88algolia%E5%AE%9E%E7%8E%B0%E9%AB%98%E6%95%88%E7%BE%8E%E8%A7%82%E7%9A%84%E7%AB%99%E5%86%85%E6%90%9C%E7%B4%A2/:3:1","tags":["hugo"],"title":"用Hugo配合Algolia实现高效美观的站内搜索","uri":"/posts/%E7%94%A8hugo%E9%85%8D%E5%90%88algolia%E5%AE%9E%E7%8E%B0%E9%AB%98%E6%95%88%E7%BE%8E%E8%A7%82%E7%9A%84%E7%AB%99%E5%86%85%E6%90%9C%E7%B4%A2/"},{"categories":["hugo"],"content":"hugo-aligolia 我们这里使用一个hugo-algolia的插件来完成我们的数据同步工作,要安装hugo-aligolia我们需要先确保我们已经安装了 npm 或者 yarn 包管理工具。 使用下面的命令安装即可： $ npm install hugo-algolia -g 配置完成以后，在根目录下面执行下面的命令： $ hugo-algolia -s JSON index file was created in public/algolia.json { updatedAt: '2020-01-23T02:36:09.480Z', taskID: 249063848950 } 这个时候我们在 dashboard 中打开 Indices，可以看到已经有几十条数据了。 如果某篇文章不想被索引的话，我们只需要在文件的最前面设置 index 参数为 false 即可。 ","date":"2024-03-09","objectID":"/posts/%E7%94%A8hugo%E9%85%8D%E5%90%88algolia%E5%AE%9E%E7%8E%B0%E9%AB%98%E6%95%88%E7%BE%8E%E8%A7%82%E7%9A%84%E7%AB%99%E5%86%85%E6%90%9C%E7%B4%A2/:3:2","tags":["hugo"],"title":"用Hugo配合Algolia实现高效美观的站内搜索","uri":"/posts/%E7%94%A8hugo%E9%85%8D%E5%90%88algolia%E5%AE%9E%E7%8E%B0%E9%AB%98%E6%95%88%E7%BE%8E%E8%A7%82%E7%9A%84%E7%AB%99%E5%86%85%E6%90%9C%E7%B4%A2/"},{"categories":["hugo"],"content":"hugo.toml文件配置 配置结束后，就可以使用Algolia 的搜索功能 ","date":"2024-03-09","objectID":"/posts/%E7%94%A8hugo%E9%85%8D%E5%90%88algolia%E5%AE%9E%E7%8E%B0%E9%AB%98%E6%95%88%E7%BE%8E%E8%A7%82%E7%9A%84%E7%AB%99%E5%86%85%E6%90%9C%E7%B4%A2/:4:0","tags":["hugo"],"title":"用Hugo配合Algolia实现高效美观的站内搜索","uri":"/posts/%E7%94%A8hugo%E9%85%8D%E5%90%88algolia%E5%AE%9E%E7%8E%B0%E9%AB%98%E6%95%88%E7%BE%8E%E8%A7%82%E7%9A%84%E7%AB%99%E5%86%85%E6%90%9C%E7%B4%A2/"},{"categories":["计算机组成原理"],"content":"计算机组成部分 运算器，控制器，存储器，输入/输出设备 概念 计算机是一种以电子器件为基础的，不需人的直接干预，能够对各种数字化信息，进行算术和逻辑运算的快速工具 层次 ","date":"2024-03-09","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/:0:0","tags":["计算机组成原理"],"title":"计算机组成(第一章)","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"},{"categories":["计算机组成原理"],"content":"电子数字计算机 以电子器件为物质基础 ","date":"2024-03-09","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/:1:0","tags":["计算机组成原理"],"title":"计算机组成(第一章)","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"},{"categories":["计算机组成原理"],"content":"自动化 不需要人的直接干预 ","date":"2024-03-09","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/:2:0","tags":["计算机组成原理"],"title":"计算机组成(第一章)","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"},{"categories":["计算机组成原理"],"content":"数字化信息 二进制 ","date":"2024-03-09","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/:3:0","tags":["计算机组成原理"],"title":"计算机组成(第一章)","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"},{"categories":["计算机组成原理"],"content":"算逻运算 基本运算操作是算术和逻辑运算 ","date":"2024-03-09","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/:4:0","tags":["计算机组成原理"],"title":"计算机组成(第一章)","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"},{"categories":["计算机组成原理"],"content":"快速工具 电子器件 存储程序 特征 ","date":"2024-03-09","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/:5:0","tags":["计算机组成原理"],"title":"计算机组成(第一章)","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"},{"categories":["计算机组成原理"],"content":"内部特征 高速高集成开关元件 数字化信息编码 逻辑判断和处理能力 存储程序 ","date":"2024-03-09","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/:6:0","tags":["计算机组成原理"],"title":"计算机组成(第一章)","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"},{"categories":["计算机组成原理"],"content":"外部特征 快速性(由内部特征中1，4决定) 准确性(由内部特征中2，4决定) 逻辑性(由内部特征中1，3，4决定) 通用性(由内部特征中1，2，3，4决定) 分类 模拟计算机和数字计算机 ","date":"2024-03-09","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/:7:0","tags":["计算机组成原理"],"title":"计算机组成(第一章)","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"},{"categories":["计算机组成原理"],"content":"各自特点 ","date":"2024-03-09","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/:8:0","tags":["计算机组成原理"],"title":"计算机组成(第一章)","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"},{"categories":["计算机组成原理"],"content":"区别(图) 应用 科学计算 教育和卫生 自动控制和测量 家用电器 信息处理 人工智能 计算机的硬件系统组成 指令字和数据字，指令流和数据流 指令字 某字为一条指令 数据字 某字代表要处理的数据 指令流 在取指周期中从内存读出的信息，它流向控制器 数据流 而执行周期中从内存读出的信息，它由内存流向运算器 ","date":"2024-03-09","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/:9:0","tags":["计算机组成原理"],"title":"计算机组成(第一章)","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"},{"categories":["计算机组成原理"],"content":"时间上 在取指周期中，CPU从内存读出的信息一定是指令；而执行周期中从内存读出或写入的信息一定是数据 ","date":"2024-03-09","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/:10:0","tags":["计算机组成原理"],"title":"计算机组成(第一章)","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"},{"categories":["计算机组成原理"],"content":"空间上 指令一定流向控制器；而数据则是在内存(或寄存器)与运算器之间流动 系统总线 总线 传递信息的一组公用导线，信息通道 系统总线 微机系统中信息交换的主要公共通道 地址总线 单向输出主存单元或I/O端口的地址信息 数据总线 读(Read)操作数据输入微处理器；写(Write)操作数据输出到外界(主存或外设) 控制总线 有些控制信号或状态信号；有些请求或联络信号输入 微机系统采用总线结构，总线连接使得微机组合灵活，扩展方便 ","date":"2024-03-09","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/:11:0","tags":["计算机组成原理"],"title":"计算机组成(第一章)","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"},{"categories":["面向对象程序设计"],"content":"计算机程序 ","date":"2024-03-08","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/:0:0","tags":["面向对象程序设计"],"title":"c++(one)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"},{"categories":["面向对象程序设计"],"content":"面向对象的方法 抽象 分类所依据的原则 忽略事物的非本质特征，从而找出事物的共性，把具有共同性质的事物划分为一类，得出一个抽象的概念 封装 把对象的属性和行为结合成一个独立的系统单位 尽可能隐藏对象的内部细节。对外形成一个边界(或屏障)，只保留有限的对外接口使之与外部发生联系 继承(多继承) 特殊类的对象拥有其一般类的全部属性与行为 多态 在一般类中定义的属性或行为，被特殊类继承之后，可以具有不同的数据类型或表现出不同的行为。这使得同一个属性或行为在一般类及其各个特殊类中具有不同的语义 ","date":"2024-03-08","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/:1:0","tags":["面向对象程序设计"],"title":"c++(one)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"},{"categories":["面向对象程序设计"],"content":"类和对象 对象：将数据及对数据的操作方法封装在一起，做为一个互相依存，不可分离的整体 对象与对象之间通过消息通讯 类：对同类型对象抽象出其共性 类通过一个简单的外部接口，与外界发生关系 一般意义上的对象 是现实世界中一个实际存在的事物，可以是有形的(如：一辆汽车)，也可以是无形的(如：一项计划) 是构成世界的一个独立单位，具有： **静态特征:**可以用某种数据描述 **动态特征:**对象所表现的行为或具有的功能 类与对象的关系 就如模具与铸件之间的关系，一个属于某类的对象称为该类的一个实例 ","date":"2024-03-08","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/:2:0","tags":["面向对象程序设计"],"title":"c++(one)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"},{"categories":["编译原理"],"content":"高级语言的定义 ","date":"2024-03-06","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%862/:0:0","tags":["编译原理"],"title":"编译引论(第二章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%862/"},{"categories":["编译原理"],"content":"语法 任何高级语言程序都可以看成是一个特定字母表(即元素的非空有穷集合)上的一个字符串(有穷序列) ","date":"2024-03-06","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%862/:1:0","tags":["编译原理"],"title":"编译引论(第二章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%862/"},{"categories":["编译原理"],"content":"词法规则 指单词符号的形成规则，它确定语言的单词符号，单词符号一般包括：标识符，保留字，界符，算符等 ","date":"2024-03-06","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%862/:2:0","tags":["编译原理"],"title":"编译引论(第二章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%862/"},{"categories":["编译原理"],"content":"语法规则 从单词符号形成更大的结构(即语法单位)，它是语法单位的形成规则，一般语法单位有：表达式，语句，函数，程序等 ","date":"2024-03-06","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%862/:3:0","tags":["编译原理"],"title":"编译引论(第二章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%862/"},{"categories":["编译原理"],"content":"语义 定义它的单词符号和语法单位的意义 所谓一个语言的语义是指这样的一组规则，使用它可以定义一个程序的意义 文法和语言 ","date":"2024-03-06","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%862/:4:0","tags":["编译原理"],"title":"编译引论(第二章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%862/"},{"categories":["编译原理"],"content":"基本概念 ","date":"2024-03-06","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%862/:5:0","tags":["编译原理"],"title":"编译引论(第二章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%862/"},{"categories":["编译原理"],"content":"字母表 字母表：元素的非空有穷集合，习惯上用大写字母表示，如 ∑ ={a,b} 符号:字母表中的每一个元素，如a,b; ","date":"2024-03-06","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%862/:5:1","tags":["编译原理"],"title":"编译引论(第二章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%862/"},{"categories":["编译原理"],"content":"符号串 符号串:字母表中的符号的有穷序列，如 a,b,aa,bb….。 空符号串：不含任何符号的符号串，记为ε 符号串集合：字母表∑上的符号串组成的集合。 ","date":"2024-03-06","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%862/:5:2","tags":["编译原理"],"title":"编译引论(第二章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%862/"},{"categories":["编译原理"],"content":"符号串运算 符号串长度：符号串中所包含的符号个数。设符号串为x,则其长度记为|x|。 符号串连接:设有符号串x和y，把y的所有符号相继写在x的符号串之后所得到的符号串即称为x和y的连接，记为xy 例：εx=xε=x 符号串的方幂：设x的符号串，则x的n次连接称为n次方幂，记为xn。 例：$x^0$=ε 符号串的前缀，后缀，子串 假设x是一个符号串，则有： 符号串x的前缀是指：从符号串x的尾部删除若干(含0个)符号后得到的符号串； 符号串x的后缀是指：从符号串x的头部删除若干(含0个)符号后得到的符号串： 符号串x的子串是指：删除了x前缀(或删除x的后缀或删除x的前缀和后缀)后得到的符号串； 对任意的符号串x，x的前缀，后缀都是x的子串，但x的子串不一定是x的前缀或后缀。 对任意的符号串x，x和ε都是符号串x的前缀，后缀，也是x的子串。 ","date":"2024-03-06","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%862/:5:3","tags":["编译原理"],"title":"编译引论(第二章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%862/"},{"categories":["编译原理"],"content":"符号串集合的运算 符号串的集合的乘积 设A，B为符号串集合，则符号串集合的乘积表示为AB={xy|x∈A,y∈B},即A中的任意符号串和B中的任意符号串的连接所构成的集合。 以为有 xε=εx=x,所以有{ε}A={ε}A=A 注：∅A= A∅ =∅ 符号串集合的方幂：即同一个符号串集合的乘积。 例：设A为符号串集合，则 $A^0$={ε} , $A^1$=A, $A^2$=AA,….. ","date":"2024-03-06","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%862/:6:0","tags":["编译原理"],"title":"编译引论(第二章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%862/"},{"categories":["编译原理"],"content":"符号串集合的闭包 ","date":"2024-03-06","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%862/:7:0","tags":["编译原理"],"title":"编译引论(第二章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%862/"},{"categories":["编译原理"],"content":"星闭包 设A为符号串集合，则$A^*$为符号串集合A的星闭包。具体定义如下： $A^*=A^0\\bigcup$$A^1$$\\bigcup$$A^2$$\\bigcup$$A^3$$\\bigcup$….. ","date":"2024-03-06","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%862/:7:1","tags":["编译原理"],"title":"编译引论(第二章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%862/"},{"categories":["编译原理"],"content":"正闭包 设A为符号串集合，则$A^+$为符号串集合A的正闭包。具体定义如下： $A^+=A^0\\bigcup$$A^1$$\\bigcup$$A^2$$\\bigcup$$A^3$$\\bigcup$….. **由上述两个定义，显然有 :$A^+$ $=$ $AA^*$ ** ","date":"2024-03-06","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%862/:7:2","tags":["编译原理"],"title":"编译引论(第二章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%862/"},{"categories":["编译原理"],"content":"文法及文法的BNF表示 ","date":"2024-03-06","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%862/:8:0","tags":["编译原理"],"title":"编译引论(第二章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%862/"},{"categories":["编译原理"],"content":"规则 即产生式，是一有序对(U，ⅹ)，通常记为： U→x(或U::x) ","date":"2024-03-06","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%862/:8:1","tags":["编译原理"],"title":"编译引论(第二章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%862/"},{"categories":["编译原理"],"content":"文法和字汇表 文法可以定义成一个四元组G=($V_N$,$V_T$,S,P) $V_N$:一个非空有限的非终结符号集合 $V_T$:一个非空有限的终结符号集合 S:文法的开始符号，它是一个特殊的非终结符号 P:产生式的有限集合 例如： ","date":"2024-03-06","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%862/:9:0","tags":["编译原理"],"title":"编译引论(第二章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%862/"},{"categories":["编译原理"],"content":"文法的BNF(巴科斯范式)表示 为了书写简洁，常常把左部相同的规则缩写在一起，使其结构更加紧凑，在规则中引入符号\"|\",以表示“或者”。形如$S\\rightarrow$$a_1$,$S\\rightarrow$$a_2$,….,$S\\rightarrow$$a_n$,缩写为$S\\rightarrow$$a_1$|$a_2$|….|$a_n$,每个$a_i$被称为S的一个候选式 因此，上述例子的文法还可以写成： ","date":"2024-03-06","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%862/:9:1","tags":["编译原理"],"title":"编译引论(第二章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%862/"},{"categories":["编译原理"],"content":"递归规则及递归文法 ","date":"2024-03-06","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%862/:10:0","tags":["编译原理"],"title":"编译引论(第二章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%862/"},{"categories":["编译原理"],"content":"递归规则 指那些在规则的右部含有与规则左部相同符号的规则，例如，$U\\rightarrow$$xUy$,右部含有与规则左部相同部分符号U，这就是递归规则 如果这个相同符号出现在右部的最左端，则为左递归规则，例如:$U\\rightarrow$$Uy$ 如果这个相同符号出现在左部的最右端，则为右递归规则，例如:$U\\rightarrow$$xU$ ","date":"2024-03-06","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%862/:10:1","tags":["编译原理"],"title":"编译引论(第二章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%862/"},{"categories":["编译原理"],"content":"递归文法 若文法中至少包含一条递归规则，则称文法是直接递归的 例如： 算术表达式G[E]: $E\\rightarrow$$E+T|T$ $T\\rightarrow$$T*F|F$ $F\\rightarrow$$(E)|i$ 显然，该文法就是一个直接递归文法 ","date":"2024-03-06","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%862/:10:2","tags":["编译原理"],"title":"编译引论(第二章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%862/"},{"categories":["编译原理"],"content":"推导和归约 ","date":"2024-03-06","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%862/:11:0","tags":["编译原理"],"title":"编译引论(第二章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%862/"},{"categories":["编译原理"],"content":"直接推导 设$\\alpha\\rightarrow$$\\beta$是文法$G=(V_N,V_T,S,P)$的产生式，$\\gamma$和$\\delta \\in (V_N \\bigcup V_T)^*$,若有符号串v,w满足： $v=\\gamma\\alpha\\delta$，$w=\\gamma\\beta\\delta$ 则称v(利用规则$\\alpha\\rightarrow\\beta$)直接推出w，或则说w是v的直接推导，记作:$v\\Rightarrow w$. 归约是推导的逆过程，若$v\\Rightarrow w$,也可以说w直接规约到v ","date":"2024-03-06","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%862/:11:1","tags":["编译原理"],"title":"编译引论(第二章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%862/"},{"categories":["编译原理"],"content":"长度为n的推导 如果存在直接推导的序列:$v=w_0\\Rightarrow w_1\\Rightarrow …. \\Rightarrow w_n = w (n\\geq1)$，则说v经过n步(n\u003e0)推导出w，记作：$v\\stackrel{+}\\Rightarrow w$。“$\\stackrel{+}\\Rightarrow$”表示多步直接推导。 若有$v\\stackrel{+}\\Rightarrow w$,或v=w(n=0),则说v经过n($n\\geq 0$)步推导出w，记作：$v\\stackrel{}\\Rightarrow w$。“$\\stackrel{}\\Rightarrow$”表示0步或多步直接推导。 ","date":"2024-03-06","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%862/:11:2","tags":["编译原理"],"title":"编译引论(第二章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%862/"},{"categories":["编译原理"],"content":"最左推导和最右推导 若在推导过程中，每一步总是对当前符号串最左(右)边的非终结符号进行替换，称为最左(右)推导。如果文法G是无二义的，那么最右推导的逆过程为最左归约，最有推导为规范推导，最左规约为规范归约。 ","date":"2024-03-06","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%862/:11:3","tags":["编译原理"],"title":"编译引论(第二章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%862/"},{"categories":["编译原理"],"content":"句型，句子和语言 ","date":"2024-03-06","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%862/:12:0","tags":["编译原理"],"title":"编译引论(第二章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%862/"},{"categories":["编译原理"],"content":"句型，句子 定义 设G[S]是文字表V上的一个文法，如果符号串u是由文法的开始符号推导出来的，则称u是文法G[S]的句型。如果u仅由终结符号组成，则称u是文法G[S]的句子 即： 若$S\\stackrel{}\\Rightarrow u$，$u\\in V^$，则称u是文法G[S]的句型； 若$S\\stackrel{+}\\Rightarrow u$，$u \\in V_T^*$，则称u是文法G[S]的句子； ","date":"2024-03-06","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%862/:12:1","tags":["编译原理"],"title":"编译引论(第二章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%862/"},{"categories":["编译原理"],"content":"语言 定义 文法G[S]所产生的所有句子的集合，称为该文法所定义的语言，记为L(G[S])。 即： L(G)={u|$S\\stackrel{+}\\Rightarrow u$，且$u\\in V_T^*$} 文法和语言的关系 对于一给定的文法，可以唯一地确定它所产生的语言 对于一给定的语言，可以找到若干不同的文法定义它 ","date":"2024-03-06","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%862/:12:2","tags":["编译原理"],"title":"编译引论(第二章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%862/"},{"categories":["编译原理"],"content":"短语，简单短语，句柄 ","date":"2024-03-06","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%862/:13:0","tags":["编译原理"],"title":"编译引论(第二章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%862/"},{"categories":["编译原理"],"content":"定义 设G是一个文法，S是文法G的开始符号，$\\alpha\\beta\\delta$是该文法的一个句型，如果有： $S\\stackrel{*}\\Rightarrow \\alpha A \\delta$并且 $A\\stackrel{+}\\Rightarrow\\beta$ 则称$\\beta$ 是句型$\\alpha\\beta\\delta$相对于非终结符号A的短语。特别的，如果$A\\stackrel{+}\\Rightarrow\\beta$ 是通过1步推导来完成的，则称$\\beta$是句型$\\alpha\\beta\\delta$相对于非终结符号A的简单短语，也称为直接短语。一个句型的最左边的简单短语称为句柄 ","date":"2024-03-06","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%862/:13:1","tags":["编译原理"],"title":"编译引论(第二章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%862/"},{"categories":["编译原理"],"content":"语法树与文法的二义性 ","date":"2024-03-06","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%862/:14:0","tags":["编译原理"],"title":"编译引论(第二章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%862/"},{"categories":["编译原理"],"content":"语法树 用一张图来表示一个句型的推导过程 设文法G=($V_N,V_T,P,S$)，对于文法G的任意一个句型都存在一个相应的语法树： 树中每个结点都有一个标记，该标记是$V_NV_T$中的一个符号； 树的根节点标记文法的识别符号S； 若树的一个结点至少有一个叶子结点，则该结点的标记一定是一个非终结符； 若树的一个结点有多个结点，该结点的标记为A，这些叶子结点的标记从左到右分别是$B_1,B_2,…,B_n$，则($A\\rightarrow B_1B_2…B_n$)$\\in P$ ","date":"2024-03-06","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%862/:14:1","tags":["编译原理"],"title":"编译引论(第二章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%862/"},{"categories":["编译原理"],"content":"二义性 定义 一个文法，如果它的一个句子由两颗或两颗以上的语法树，则称此句子具有二义性。如果一个文法含有二义性的句子，则该文法具有二义性。 注意 文法的二义性和语言的二义性是两个不同的概念。如果产生上下文无关语言的每一个文法都是二义性的，则说该语言是二义性的。并非文法的二义性就说其描述的语言是二义性的。通常可能有两个不同的文法G1和G2，其中一个文法是二义性的，另外一个是没有二义性的，但是却有L(G1) = L(G2)，即两个文法产生的语言是等价的 ","date":"2024-03-06","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%862/:14:2","tags":["编译原理"],"title":"编译引论(第二章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%862/"},{"categories":["编译原理"],"content":"文法的实用限制 ","date":"2024-03-06","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%862/:15:0","tags":["编译原理"],"title":"编译引论(第二章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%862/"},{"categories":["编译原理"],"content":"有害规则 定义： 文法中形如$U \\rightarrow U$的规则就称为有害规则 如果文法中含有有害规则，它除了造成文法的二义性以外，对定义语言则是没有任何意义。 例如： ","date":"2024-03-06","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%862/:15:1","tags":["编译原理"],"title":"编译引论(第二章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%862/"},{"categories":["编译原理"],"content":"多余规则 多余规则则指文法中任何句子的推导都不会用到的规则，多余规则在文法中以两种形式出现，即不可到达的非终结符和不可终止的非终止符 文法中某些非终结符(除去文法开始符号)不出现任何其他规则的右部，该非终结符称为不可到达。 文法中某些非终结符，由它不能推出终结符号串，该非终结符称为不可终止。 例如： G[S]: $S\\rightarrow Be$ $B\\rightarrow Ce$ $B\\rightarrow Af$ $A\\rightarrow Ae$ $A\\rightarrow e$ $C\\rightarrow Cf$ $D\\rightarrow f$ 根据有害规则和多余规则的定义，显然文法不包含有有害规则，而由于非终结符号C为不可终止，非终结符号D为不可到达，因此产生式2，6，7为多余规则应去掉 一般所讨论的文法均假定不包含有有害规则和多余规则 ","date":"2024-03-06","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%862/:15:2","tags":["编译原理"],"title":"编译引论(第二章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%862/"},{"categories":["编译原理"],"content":"文法的等价变换 ","date":"2024-03-06","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%862/:16:0","tags":["编译原理"],"title":"编译引论(第二章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%862/"},{"categories":["编译原理"],"content":"文法直接左递归的消除 假定关于非终结符U的产生式为：$U\\rightarrow U\\alpha|\\beta$ 其中$\\alpha ,\\beta \\in (V_N\\bigcup V_T)^*$，$\\beta$补以U开头，那么，可以把U的产生式改写成如下的非直接左递归形式： $U\\rightarrow \\beta U^,$ $U^, \\rightarrow \\alpha U^,|\\epsilon$ 引入新的非终结符号消去文法中的直接左递归: 形如$U \\rightarrow Ux_1 | Ux_2 |…| Ux_m|y_1|y_2|…|y_m$的规则，可引入一个新的非终结符号$U^,$,则得到等价的规则： $U \\rightarrow y_1U^,|y_2U^,|…|y_mU^,$ $U^, \\rightarrow x_1U^,|x_2U^,|…|x_mU^,|\\epsilon$ ","date":"2024-03-06","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%862/:16:1","tags":["编译原理"],"title":"编译引论(第二章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%862/"},{"categories":["编译原理"],"content":"文法一般左递归的消除 如果一个文法不含有形如$U \\stackrel{+}\\Rightarrow U$的推导，也不含有以$\\epsilon$为右部的产生式，那执行下面的算法将保证消除文法中的所有左递归 消除间接左递归的算法如下 例： ","date":"2024-03-06","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%862/:16:2","tags":["编译原理"],"title":"编译引论(第二章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%862/"},{"categories":["编译原理"],"content":"提取左因子 假设A的产生式为： $A \\rightarrow \\delta\\beta_1|\\delta\\beta_2|…|\\delta\\beta_n|\\gamma_1|\\gamma_2|…|\\gamma_n$（其中，每个$\\gamma$不以$\\delta$开头） 可将这些产生式改写成： $A \\rightarrow A^,|\\gamma_1|\\gamma_2|…|\\gamma_n$ $A^,\\rightarrow \\beta_1|\\beta_2|…|\\beta_n$ 经过反复提取左因子，就能够把每个非终结符(包括新引进者)的所有候选式的公共左因子消除掉，则改变后的文法便于自上而下的语法分析，如LL(1)预测分析法。相应付出的代价是，大量引进新的非终结符和$\\epsilon -$产生式。 例： ","date":"2024-03-06","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%862/:16:3","tags":["编译原理"],"title":"编译引论(第二章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%862/"},{"categories":["编译原理"],"content":"文法 ","date":"2024-03-06","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%862/:17:0","tags":["编译原理"],"title":"编译引论(第二章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%862/"},{"categories":["编译原理"],"content":"0型文法 0型文法(无限制的文法)，其产生式具有以下形式： $\\alpha \\rightarrow \\beta$ 其中，$\\alpha \\in V^+$，且至少含有一个非终结符；$\\beta \\in V^*$ ","date":"2024-03-06","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%862/:17:1","tags":["编译原理"],"title":"编译引论(第二章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%862/"},{"categories":["编译原理"],"content":"1型文法(上下文有关文法) 定义：1型文法G的产生式具有以下形式： $xUy \\rightarrow \\xuy$ 其中$x,y \\in V^*;U \\in V_N;u \\in V^+$ ","date":"2024-03-06","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%862/:17:2","tags":["编译原理"],"title":"编译引论(第二章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%862/"},{"categories":["编译原理"],"content":"2型文法(上下文无关文法) 定义：在1型文法的产生式中上下文x和y用空符号串$\\epsilon$代替，则有以下形式的产生式称为2型文法： $U \\rightarrow u$ 其中，$U \\in V_N,u \\in V^*$ ","date":"2024-03-06","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%862/:17:3","tags":["编译原理"],"title":"编译引论(第二章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%862/"},{"categories":["编译原理"],"content":"3型文法(正规文法) 定义1：如果文法的产生式只含有下面的两种形式： $U \\rightarrow a$或$U \\rightarrow aB$ 其中U，$B \\in V_N,a \\in V_T^*$，则称该文法为右线性文法； 定义2：如果文法的产生式只含有下面的两种形式： $U \\rightarrow a$或$U \\rightarrow Ba$ 其中U，$B \\in V_N,a \\in V_T^*$，则称该文法为左线性文法； 例： ","date":"2024-03-06","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%862/:17:4","tags":["编译原理"],"title":"编译引论(第二章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%862/"},{"categories":["操作系统"],"content":"进程管理(引入) ","date":"2024-03-05","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F2/:0:0","tags":["操作系统"],"title":"操作系统(第二章)","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F2/"},{"categories":["操作系统"],"content":"前趋图(也称为：有向无循环图) 条件：有向，无循环 O(圆圈)：节点，代表指令，程序，进程… →：有向边，代表前趋/后继关系 ","date":"2024-03-05","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F2/:1:0","tags":["操作系统"],"title":"操作系统(第二章)","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F2/"},{"categories":["操作系统"],"content":"程序的执行 ","date":"2024-03-05","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F2/:2:0","tags":["操作系统"],"title":"操作系统(第二章)","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F2/"},{"categories":["操作系统"],"content":"顺序执行及特征 特征：顺序性，封闭性，可再现性 顺序→并发(可能性分析图) 例题： 引起不可再现性是因为没有临界资源(每一个缓冲区)没有访问(互斥访问) 进程的相关概念 ","date":"2024-03-05","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F2/:2:1","tags":["操作系统"],"title":"操作系统(第二章)","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F2/"},{"categories":["操作系统"],"content":"定义 程序的一次执行过程 ","date":"2024-03-05","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F2/:3:0","tags":["操作系统"],"title":"操作系统(第二章)","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F2/"},{"categories":["操作系统"],"content":"结构 进程映像：PCB+程序段+数据段 (中断返回地址存放在PCB中) ","date":"2024-03-05","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F2/:4:0","tags":["操作系统"],"title":"操作系统(第二章)","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F2/"},{"categories":["操作系统"],"content":"动态 由\"创建\"而产生，由\"调度\"而执行，由\"撤消\"而消亡(而程序是静态的) ","date":"2024-03-05","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F2/:5:0","tags":["操作系统"],"title":"操作系统(第二章)","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F2/"},{"categories":["操作系统"],"content":"状态 ","date":"2024-03-05","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F2/:6:0","tags":["操作系统"],"title":"操作系统(第二章)","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F2/"},{"categories":["操作系统"],"content":"三态结构(图) 就绪状态： 条件：获得除CPU以外的所有资源 一个就绪队列 执行状态： 条件：已获得CPU，程序正在执行的状态 在单处理机系统中，只有一个进程处于执行状态；而在多处理机系统中，则有多个进程处于执行状态 阻塞状态： 条件：进程的执行受到阻塞 一个阻塞队列 实事上，在较大的系统中，为了减少队列操作的开销，提高系统效率，根据阻塞原因不同，会设置多个阻塞队列。 ","date":"2024-03-05","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F2/:6:1","tags":["操作系统"],"title":"操作系统(第二章)","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F2/"},{"categories":["操作系统"],"content":"转换关系 经常发生：4个，就绪→执行，执行→就绪，执行→阻塞，阻塞→执行 绝对不会发生：就绪→阻塞 有可能会发生：阻塞→执行 挂起状态 ","date":"2024-03-05","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F2/:6:2","tags":["操作系统"],"title":"操作系统(第二章)","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F2/"},{"categories":["操作系统"],"content":"引入原因 减少内存当中进程的数量(从内存调到外存) ","date":"2024-03-05","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F2/:7:0","tags":["操作系统"],"title":"操作系统(第二章)","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F2/"},{"categories":["操作系统"],"content":"状态分类 静止→活动 被激活(执行激活函数) 话动→静止 被挂起(执行挂起函数) ","date":"2024-03-05","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F2/:8:0","tags":["操作系统"],"title":"操作系统(第二章)","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F2/"},{"categories":["操作系统"],"content":"具有挂起状态的进程状态图(五态结构) 进程控制块(PCB) ","date":"2024-03-05","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F2/:9:0","tags":["操作系统"],"title":"操作系统(第二章)","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F2/"},{"categories":["操作系统"],"content":"作用 进程存在的唯一标志 ","date":"2024-03-05","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F2/:10:0","tags":["操作系统"],"title":"操作系统(第二章)","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F2/"},{"categories":["操作系统"],"content":"进程控制块中的信息(图) 标识，处理机状态，进程调度信息，进程控制信息 优先数：一般为整数 ","date":"2024-03-05","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F2/:11:0","tags":["操作系统"],"title":"操作系统(第二章)","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F2/"},{"categories":["操作系统"],"content":"PCB的组织 链接 索引 进程控制(三对操作) 创建与终止 阻塞与唤醒 挂起与激活 进程同步 ","date":"2024-03-05","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F2/:12:0","tags":["操作系统"],"title":"操作系统(第二章)","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F2/"},{"categories":["操作系统"],"content":"概念 并发进程在执行次序上的协调，以达到有效的资源共享和相互合作，使程序的执行具有可再现性 ","date":"2024-03-05","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F2/:13:0","tags":["操作系统"],"title":"操作系统(第二章)","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F2/"},{"categories":["操作系统"],"content":"关系 间接制约：互斥共享资源 直接制约：相互合作 ","date":"2024-03-05","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F2/:14:0","tags":["操作系统"],"title":"操作系统(第二章)","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F2/"},{"categories":["操作系统"],"content":"临界资源 一次只允许一个进程访问的资源 引起不可再现性是因为没有临界资源(每一个缓冲区)没有访问(互斥访问) ","date":"2024-03-05","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F2/:15:0","tags":["操作系统"],"title":"操作系统(第二章)","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F2/"},{"categories":["操作系统"],"content":"临界区 ","date":"2024-03-05","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F2/:16:0","tags":["操作系统"],"title":"操作系统(第二章)","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F2/"},{"categories":["操作系统"],"content":"定义 进程访问临界资源的那段代码 ","date":"2024-03-05","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F2/:16:1","tags":["操作系统"],"title":"操作系统(第二章)","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F2/"},{"categories":["操作系统"],"content":"描述 进入区：检查有无进程进入 临界区： 退出区：将访问标志复位 ","date":"2024-03-05","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F2/:16:2","tags":["操作系统"],"title":"操作系统(第二章)","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F2/"},{"categories":["操作系统"],"content":"信号量机制 ","date":"2024-03-05","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F2/:17:0","tags":["操作系统"],"title":"操作系统(第二章)","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F2/"},{"categories":["操作系统"],"content":"整型信号量(S) 是一个整型量，通过2个原子操作wait (s)和signal (s)来访问 含义：表示资源，$S_{初始值}≥0$ 变化： –1：wait(s) p(s) 表示申请资源 +1：signal(s) v(s) 表示释放资源 注：wait(s)和signal(s)是成对出现 问题：当S≤0，不能分配资源，进程阻塞(队列) 记录型(S) S.value：代表资源，s.value≥0 S.L：阻塞进程的队列 操作 wait(s) 分析 ： S.value=1→(p(s))1-1=0 S.value=0→(p(s))0-1=-1 signal(s) 分析 S.value=-1→(v(s))-1+1=0 S.value=-2→(v(s))-2+1=-1 小结： 实现进程关系的描述 wait(s)和signal(s)是成对出现 同一个进程或两个进程之间出现 在记录型信号量机制中 S.value初值：表示系统中某类资源的数目 S.value\u003c0：表示信号量链表中已阻塞进程的数目 ","date":"2024-03-05","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F2/:17:1","tags":["操作系统"],"title":"操作系统(第二章)","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F2/"},{"categories":["操作系统"],"content":"信号量的应用 ","date":"2024-03-05","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F2/:18:0","tags":["操作系统"],"title":"操作系统(第二章)","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F2/"},{"categories":["操作系统"],"content":"利用信号量实现互斥 一个进程执行，另一个进程不执行，则成互斥关系 步骤 共享临界资源(mutex)=1 wait(mutex) signal(mutex) 设置临界区 进入：wait(mutex) CS 退出：signal(mutex) 同一个进程当中，成对出现 总结 mutex实现临界区的设置(2个) mutex实现两个进程的互斥 ","date":"2024-03-05","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F2/:18:1","tags":["操作系统"],"title":"操作系统(第二章)","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F2/"},{"categories":["操作系统"],"content":"同步(直接制约) 同步的模型 前趋图 S1(被等待)signal(a)→S2(等待)wait(a) 代码框架描述如下 ","date":"2024-03-05","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F2/:18:2","tags":["操作系统"],"title":"操作系统(第二章)","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F2/"},{"categories":["操作系统"],"content":"经典进程的同步问题 ","date":"2024-03-05","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F2/:19:0","tags":["操作系统"],"title":"操作系统(第二章)","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F2/"},{"categories":["操作系统"],"content":"生产者–消费者问题 设置信号量 每个缓冲区：mutex(初值为：1) empty:空(初值为：n) full:满(初值为：0) 结论 当有多个信号量时，注意wait的顺序 临界区的设置，主要是实现变量的修改 代码描述如下： int in=0,out=0; item buffer[n]; semaphore mutex=1,empty=n;full=0; void proceducer(){ do{ proceducer an item nextp; ... wait(empty); wait(mutex); buffer[in]=nextp; in:=(in+1)%n; signal(mutex); signal(full); }while(TRUE) } void consumer(){ do{ wait(full); wait(mutex); nextc=buffer[out]; out:=(out+1)%n; signal(mutex); signal(empty); consumer the item in nextc; ... }while(TRUE) } void main(){ cobegin proceducer(); consumer(); coend } 注意 在每个程序中的多个wait操作顺序不能颠倒。应先执行对信号资源量的wait操作，然后再执行对互斥信号量的wait操作，否则可能引起死锁 ","date":"2024-03-05","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F2/:19:1","tags":["操作系统"],"title":"操作系统(第二章)","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F2/"},{"categories":["操作系统"],"content":"哲学家进餐问题 经分析可知，放在桌子上的筷子是临界资源，在一段时间只允许一位哲学家使用。为了实现对筷子的互斥使用，可以用一个信号量表示一只筷子，由这五个信号量构成信号量数组，描述如下： semaphore chopstick[5]={1,1,1,1,1}; 所有信号量均被初始化为1，第i位哲学家的活动可描述为： do{ wait(chopstick[i]); wait(chopstick[(i+1)%5]); ... //eat ... signal(chopstick[i]); signal(chopstick[(i+1)%5]); ... //think ... }while[TRUE]; 解决漏洞 假设五位哲学家同时饥饿而各自拿起左边的筷子时，就会使五个信号量chopstick均为0；当他们再试图去拿右边的筷子时，都将因无筷子可拿而无限期等待。从而出现死锁。 对于这样的死锁问题，可采取以下几种解决办法： 至多只允许有四位哲学家同时去拿左边的筷子，最终能保证至少有一位哲学家能够进餐，并在用毕时能释放出他用过的两只筷子，从而使更多的哲学家能够进餐 仅当哲学家的左，右两只筷子均可用时，才允许他拿起筷子进餐 规定奇数号哲学家先拿起他左边的筷子，然后再去拿右边的筷子；而偶数号哲学家则相反。按此规定，将是1，2号哲学家竞争1号筷子；3，4号哲学家竞争3号筷子，即五位哲学家都先竞争奇数号筷子，获得后，再去竞争偶数号筷子，最后总会有一位哲学家能获得两只筷子而进餐。 ","date":"2024-03-05","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F2/:19:2","tags":["操作系统"],"title":"操作系统(第二章)","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F2/"},{"categories":["操作系统"],"content":"读者–写者问题 两者呈互斥关系 特点：读进程可共享同一对象，写进程不可共享同一对象。 为实现Reader与Writer进程间在读或写时的互斥而设置了一个互斥信号量Wmutex.另外再设置一个整型变量Readcount表示正在读的进程数目。又因为Readcount是一个可被多个Reader进程访问的临界资源，因此，也因该为它设置一个互斥信号量rmutex 读者–写着问题可描述如下： semaphore rmutex=1,wmutex=1; int readcount=0; void reader(){ do{ wait(rmutex); if(readcount==0) wait(wmutex); readcount++; signal(rmutex); ... perform read operation; ... wait(rmutex); readcount--; if(readcount==0) signal(wmutex); signal(rmutex); }while(TRUE); } void writer(){ do{ wait(wmutex); perform write operation; signal(wmutex); }while(TRUE); } void main(){ cobegin reader(); writer(); coend } ","date":"2024-03-05","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F2/:19:3","tags":["操作系统"],"title":"操作系统(第二章)","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F2/"},{"categories":["操作系统"],"content":"思考题 ","date":"2024-03-05","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F2/:20:0","tags":["操作系统"],"title":"操作系统(第二章)","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F2/"},{"categories":["计算机算法设计与分析"],"content":"算法与程序 ","date":"2024-03-05","objectID":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%8A%98%E4%B8%8E%E8%AE%BE%E8%AE%A1/:0:0","tags":["计算机算法设计与分析"],"title":"算法与程序(第一章)","uri":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%8A%98%E4%B8%8E%E8%AE%BE%E8%AE%A1/"},{"categories":["计算机算法设计与分析"],"content":"算法 是满足下述性质的指令序列: 输入:有零个或多个外部量作为算法的输入 输出:算法产生至少一个量作为输出 确定性:组成算法的每条指令是清晰的，无歧义的 有限性:算法中每条指令的执行次数是有限的，执行每条指令的时间也是有限的 ","date":"2024-03-05","objectID":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%8A%98%E4%B8%8E%E8%AE%BE%E8%AE%A1/:1:0","tags":["计算机算法设计与分析"],"title":"算法与程序(第一章)","uri":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%8A%98%E4%B8%8E%E8%AE%BE%E8%AE%A1/"},{"categories":["计算机算法设计与分析"],"content":"程序 与算法不同。程序是算法用某种程序设计语言的具体实现，程序可以不满足算法的性质 问题求解(图) 算法复杂性分析 ","date":"2024-03-05","objectID":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%8A%98%E4%B8%8E%E8%AE%BE%E8%AE%A1/:2:0","tags":["计算机算法设计与分析"],"title":"算法与程序(第一章)","uri":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%8A%98%E4%B8%8E%E8%AE%BE%E8%AE%A1/"},{"categories":["计算机算法设计与分析"],"content":"时间复杂性 输入为ⅰ时的跟规模n相关的算法运行时间增长率 ","date":"2024-03-05","objectID":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%8A%98%E4%B8%8E%E8%AE%BE%E8%AE%A1/:3:0","tags":["计算机算法设计与分析"],"title":"算法与程序(第一章)","uri":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%8A%98%E4%B8%8E%E8%AE%BE%E8%AE%A1/"},{"categories":["计算机算法设计与分析"],"content":"空间复杂性 输入为ⅰ时的跟规模n相关的算法辅助空间增长率 ","date":"2024-03-05","objectID":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%8A%98%E4%B8%8E%E8%AE%BE%E8%AE%A1/:4:0","tags":["计算机算法设计与分析"],"title":"算法与程序(第一章)","uri":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%8A%98%E4%B8%8E%E8%AE%BE%E8%AE%A1/"},{"categories":["计算机算法设计与分析"],"content":"分析 算法复杂性分析→算法的能行性 n！，2n，n较大时 同一问题不同算法的算法复杂性分析→算法的优劣 时间复杂性与空间复杂性的分析方法类同，主要讨论时间复杂性 ","date":"2024-03-05","objectID":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%8A%98%E4%B8%8E%E8%AE%BE%E8%AE%A1/:5:0","tags":["计算机算法设计与分析"],"title":"算法与程序(第一章)","uri":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%8A%98%E4%B8%8E%E8%AE%BE%E8%AE%A1/"},{"categories":["计算机算法设计与分析"],"content":"时间复杂性分析方法 ","date":"2024-03-05","objectID":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%8A%98%E4%B8%8E%E8%AE%BE%E8%AE%A1/:6:0","tags":["计算机算法设计与分析"],"title":"算法与程序(第一章)","uri":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%8A%98%E4%B8%8E%E8%AE%BE%E8%AE%A1/"},{"categories":["计算机算法设计与分析"],"content":"分类 非递归算法的时间复杂性分析 递归算法的时间复杂性分析 ","date":"2024-03-05","objectID":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%8A%98%E4%B8%8E%E8%AE%BE%E8%AE%A1/:7:0","tags":["计算机算法设计与分析"],"title":"算法与程序(第一章)","uri":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%8A%98%E4%B8%8E%E8%AE%BE%E8%AE%A1/"},{"categories":["计算机算法设计与分析"],"content":"算法复杂性在渐近意义下的阶 渐近意义下的记号：O，Ω，θ，o，ω g(n)是定义在正数集上的正函数。T(n)为算法的时间复杂性 ","date":"2024-03-05","objectID":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%8A%98%E4%B8%8E%E8%AE%BE%E8%AE%A1/:8:0","tags":["计算机算法设计与分析"],"title":"算法与程序(第一章)","uri":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%8A%98%E4%B8%8E%E8%AE%BE%E8%AE%A1/"},{"categories":["计算机算法设计与分析"],"content":"渐近上界记号O 若T(n) = O(g(n)) 含义：算法在任何实例情况下，其时间复杂度的阶不超过g(n)的阶 即：$\\lim_{n\\rightarrow\\infty}\\frac{T_max(n)}{g(n)}=c\\neq0$,c为常数 上例中 $\\lim_{n\\rightarrow\\infty}\\frac{T_max(n)}{n^2}=\\frac{c4+c5+c6}{2}$为常数，故T(n)=O(n2) ","date":"2024-03-05","objectID":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%8A%98%E4%B8%8E%E8%AE%BE%E8%AE%A1/:8:1","tags":["计算机算法设计与分析"],"title":"算法与程序(第一章)","uri":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%8A%98%E4%B8%8E%E8%AE%BE%E8%AE%A1/"},{"categories":["计算机算法设计与分析"],"content":"记号θ 举例有一个算法A： 最坏情况：Tmax=c1n2+n+4 最好情况：Tmin=c2n2 存在g(n)=n2,有T(n) = Ω(g(n)) 和 T(n) = O(g(n)) 因此 T(n) = θ(g(n)) ","date":"2024-03-05","objectID":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%8A%98%E4%B8%8E%E8%AE%BE%E8%AE%A1/:8:2","tags":["计算机算法设计与分析"],"title":"算法与程序(第一章)","uri":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%8A%98%E4%B8%8E%E8%AE%BE%E8%AE%A1/"},{"categories":["计算机算法设计与分析"],"content":"非紧渐近上界记号 o 若T(n) = o(g(n)) 含义：算法在任何实例情况下，其算法时间复杂性的阶小于g(n)的阶 即 $\\lim_{n\\rightarrow\\infty}\\frac{T_max(n)}{g(n)}=0$ 举例：g(n) = n2,Tmax(n)=c2nlogn —\u003e o(n2) ","date":"2024-03-05","objectID":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%8A%98%E4%B8%8E%E8%AE%BE%E8%AE%A1/:8:3","tags":["计算机算法设计与分析"],"title":"算法与程序(第一章)","uri":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%8A%98%E4%B8%8E%E8%AE%BE%E8%AE%A1/"},{"categories":["计算机算法设计与分析"],"content":"非紧渐近上界记号 ω 若T(n) = ω(g(n)) 含义：算法在任何实例情况下，其算法时间复杂性的阶大于g(n)的阶 即 $\\lim_{n\\rightarrow\\infty}\\frac{T_min(n)}{g(n)}=\\infty$ 举例：g(n)=n,Tmin=c1nlogn—\u003eω(n) ","date":"2024-03-05","objectID":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%8A%98%E4%B8%8E%E8%AE%BE%E8%AE%A1/:8:4","tags":["计算机算法设计与分析"],"title":"算法与程序(第一章)","uri":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%8A%98%E4%B8%8E%E8%AE%BE%E8%AE%A1/"},{"categories":["计算机算法设计与分析"],"content":"简便分析方法 最优算法 Master定理方法求递归算法时间复杂性 ","date":"2024-03-05","objectID":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%8A%98%E4%B8%8E%E8%AE%BE%E8%AE%A1/:9:0","tags":["计算机算法设计与分析"],"title":"算法与程序(第一章)","uri":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%8A%98%E4%B8%8E%E8%AE%BE%E8%AE%A1/"},{"categories":["计算机算法设计与分析"],"content":"第二章分治策略中，通常设计为递归算法 时间复杂性的递归定义一般有如下形式 ","date":"2024-03-05","objectID":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%8A%98%E4%B8%8E%E8%AE%BE%E8%AE%A1/:10:0","tags":["计算机算法设计与分析"],"title":"算法与程序(第一章)","uri":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%8A%98%E4%B8%8E%E8%AE%BE%E8%AE%A1/"},{"categories":["计算机算法设计与分析"],"content":"例题 第二章棋盘覆盖的时间复杂性 ","date":"2024-03-05","objectID":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%8A%98%E4%B8%8E%E8%AE%BE%E8%AE%A1/:11:0","tags":["计算机算法设计与分析"],"title":"算法与程序(第一章)","uri":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%8A%98%E4%B8%8E%E8%AE%BE%E8%AE%A1/"},{"categories":["编译原理"],"content":"编译程序(图) 某一种语言等价地转换成另外一种语言程序(称为目标语言程序) 解释程序(图) 将源程序按动态顺序逐句分晰解释执行，根据语句的含义执行，最终得到运行结果 编译器在语言处理系统中的位置(图) 编译过程 1. 词法分析 任务：输入源程序，对构成源程序的字符串进行扫描和分解，识别一个个单词符号。 依循的原则：构词规则 描述工具：正规式，有限自动机 FOR(保留字) I(标识符) :=(算符) 1(常整数) TO(保留字) 100(常整数) DO(保留字) 2. 语法分析 任务： 在词法分析的基础上，根据语言的语法规则把单词符号串分解成各类语法单位。 依循的原则：语法分析 描述工具：上下文无关文法 i(标识符)=5(无符号整数)+3(无符号整数)j(标识符) 3. 中间代码生成 任务：对语法分析所识别出的各类语法单位，分析其含义，并产生中间代码 依循的原则：语义规则 描述工具：属性文法 中间代码是一种独立于硬件的记号系统。常见的中间代码形式有逆波兰表达式，三元式，四元式等 (i+j)(x-y)翻译为四元式 (+,i,j,T1) (-,x,y,T2) (,T1,T2,T3) 4. 优化 任务：对当前阶段产生的中间代码进行等价加工变换，以期最终生成的目标代码更加高效 依循的原则：等价变换原则 常见的优化种类有公共子表达式删除，复制传播，无用代码删除和常量合并 (*,5.3,2,T1) (=,T1, ,x) 优化后： ( =,10.6, ,x) 5. 目标代码产生 任务：把中间代码变换成特定机器上的低级语言代码 该阶段的工作非常复杂，涉及机器指令的选择，寄存器的调度，以及各种数据类型变量的存储空间分配等。 6. 表格管理程序 完成编译过程中的建表，查表，更新数据等有关表格操作 **7. 错误处理程序 ** 编译程序不仅能对书写正确的程序进行翻译，而且还能对出现在源程序中的错误进行处理 编译程序的结构 ","date":"2024-03-05","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/:0:0","tags":["编译原理"],"title":"编译引论(第一章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"},{"categories":["编译原理"],"content":"编译程序的总体结构(图) 相关概念 ","date":"2024-03-05","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/:1:0","tags":["编译原理"],"title":"编译引论(第一章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"},{"categories":["编译原理"],"content":"“遍\"的概念 所谓\"一遍\"是指，对源程序或中间程序从头到尾扫描一次，并作相关加工处理，生成新的中间程序或相关代码 ","date":"2024-03-05","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/:2:0","tags":["编译原理"],"title":"编译引论(第一章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"},{"categories":["编译原理"],"content":"多遍编译程序 把编译的5个阶段应完成的工作分遍来做，每一遍完成一个或相连几个阶段的工作 ","date":"2024-03-05","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/:3:0","tags":["编译原理"],"title":"编译引论(第一章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"},{"categories":["编译原理"],"content":"前端 通常包括词法分析，语法分析，语义分析及中间代码生成，有的优化工作也可以包括在前端，前端依赖于源程序 ","date":"2024-03-05","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/:3:1","tags":["编译原理"],"title":"编译引论(第一章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"},{"categories":["编译原理"],"content":"后端 通常包括有关代码优化和目标代码生成，依赖于中间代码，计算机的硬件系统和机器指令系统 编译程序开发 ","date":"2024-03-05","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/:3:2","tags":["编译原理"],"title":"编译引论(第一章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"},{"categories":["编译原理"],"content":"自展技术(图) 按照自展技术，需要把源语言L分解成一个核心部分L0与扩充部分L1,L2,….,Ln。分解源语言之后，先用汇编语言或机器语言编写L0的编译程序，然后再用L0编写L1的编译程序，用Li编写Li+n的编译程序(i=1,2,…,n-1),像滚雪球一样，愈滚愈大，最后得到源语言L的编译程序 ","date":"2024-03-05","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/:4:0","tags":["编译原理"],"title":"编译引论(第一章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"},{"categories":["编译原理"],"content":"移植技术 即利用A机器上已有的高级语言L编写一个能够在B机器上运行的高级语言L的编译程序 假设A机器上已经有用A机器代码实现的高级语言L的编译程序，移植实现的具体做法是： 首先用L语言编写出在A机器上运行的产生B机器代码的L语言的编译程序源程序 然后把该编译程序源程序经过A机器上的L编译程序编译后，得到能在A机器上运行产生B机器代码的编译程序 最后用这个编译程序再一次编译第1步编写的编译程序源程序，得到了能在B机器上运行的产生B机器代码的编译程序 ","date":"2024-03-05","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/:5:0","tags":["编译原理"],"title":"编译引论(第一章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"},{"categories":["编译原理"],"content":"自动生成技术 利用工具，编译程序自动生成 LEX：词法分析程序产生器 YACC：语法分析程序产生器 ","date":"2024-03-05","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/:6:0","tags":["编译原理"],"title":"编译引论(第一章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"},{"categories":["操作系统"],"content":"os的定义 ","date":"2024-03-04","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/:0:0","tags":["操作系统"],"title":"操作系统(第一章)","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"categories":["操作系统"],"content":"管理资源 ","date":"2024-03-04","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/:1:0","tags":["操作系统"],"title":"操作系统(第一章)","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"categories":["操作系统"],"content":"硬件 进程，存储器，外部设备 ","date":"2024-03-04","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/:1:1","tags":["操作系统"],"title":"操作系统(第一章)","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"categories":["操作系统"],"content":"软件 文件 ","date":"2024-03-04","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/:1:2","tags":["操作系统"],"title":"操作系统(第一章)","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"categories":["操作系统"],"content":"分配资源 以作业/进程为单位进行调度(cpu算法) ","date":"2024-03-04","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/:2:0","tags":["操作系统"],"title":"操作系统(第一章)","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"categories":["操作系统"],"content":"程序 ","date":"2024-03-04","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/:3:0","tags":["操作系统"],"title":"操作系统(第一章)","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"categories":["操作系统"],"content":"进程 执行的程序(内存) ","date":"2024-03-04","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/:3:1","tags":["操作系统"],"title":"操作系统(第一章)","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"categories":["操作系统"],"content":"作业 暂时不执行的程序(外存) 操作系统概念 一组控制和管理计算机硬件和软件资源，合理地对各类作业进行调度以及方便用户的程序集合。 用户(方便) 作为扩充机器 把覆盖了软件的机器称为扩充机或虚拟机 发展 ","date":"2024-03-04","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/:3:2","tags":["操作系统"],"title":"操作系统(第一章)","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"categories":["操作系统"],"content":"脱机(spooLing(假脱机)) ","date":"2024-03-04","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/:4:0","tags":["操作系统"],"title":"操作系统(第一章)","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"categories":["操作系统"],"content":"外围机 用于管理输入/输出设备 ","date":"2024-03-04","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/:4:1","tags":["操作系统"],"title":"操作系统(第一章)","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"categories":["操作系统"],"content":"磁盘 优点:容量大 ","date":"2024-03-04","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/:4:2","tags":["操作系统"],"title":"操作系统(第一章)","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"categories":["操作系统"],"content":"批处理 ","date":"2024-03-04","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/:5:0","tags":["操作系统"],"title":"操作系统(第一章)","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"categories":["操作系统"],"content":"单道 两种硬件 cpu, i/o 串行工作 ","date":"2024-03-04","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/:5:1","tags":["操作系统"],"title":"操作系统(第一章)","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"categories":["操作系统"],"content":"多道(图) 两种硬件 cpu, i/o 并行工作 分时操作系统 实现人机交互，满足用户需要 实时系统 系统能实时响应外部事件的请求，在规定时间内完成对该事件的处理，并控制所有任务协调一致地运行 操作系统的特征 ","date":"2024-03-04","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/:5:2","tags":["操作系统"],"title":"操作系统(第一章)","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"categories":["操作系统"],"content":"并发性 ","date":"2024-03-04","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/:6:0","tags":["操作系统"],"title":"操作系统(第一章)","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"categories":["操作系统"],"content":"并发 同一个时间间隔发生 ","date":"2024-03-04","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/:6:1","tags":["操作系统"],"title":"操作系统(第一章)","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"categories":["操作系统"],"content":"并行 同一个时刻发生 ","date":"2024-03-04","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/:6:2","tags":["操作系统"],"title":"操作系统(第一章)","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"categories":["操作系统"],"content":"进程和线程 线程也被称为轻型进程 ","date":"2024-03-04","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/:6:3","tags":["操作系统"],"title":"操作系统(第一章)","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"categories":["操作系统"],"content":"共享 系统中资源可供内存中多个并发执行的进程共同使用 ","date":"2024-03-04","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/:7:0","tags":["操作系统"],"title":"操作系统(第一章)","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"categories":["操作系统"],"content":"互斥共享 一段时间内只允许一个进程访问该资源 ","date":"2024-03-04","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/:7:1","tags":["操作系统"],"title":"操作系统(第一章)","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"categories":["操作系统"],"content":"同时访问 微观上仍是互斥的 ","date":"2024-03-04","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/:7:2","tags":["操作系统"],"title":"操作系统(第一章)","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"categories":["操作系统"],"content":"虚拟(逻辑\u003c–\u003e物理) 通过某种技术把一个物理实体变为若干个逻辑上的对应物 ","date":"2024-03-04","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/:8:0","tags":["操作系统"],"title":"操作系统(第一章)","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"categories":["操作系统"],"content":"存储器 逻辑地址→(重定向)物理地址 ","date":"2024-03-04","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/:8:1","tags":["操作系统"],"title":"操作系统(第一章)","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"categories":["操作系统"],"content":"I/O设备 逻辑设备→物理设备 ","date":"2024-03-04","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/:8:2","tags":["操作系统"],"title":"操作系统(第一章)","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"categories":["操作系统"],"content":"异步 运行进度不可预知 了解常见的os的性能(建议ppt) ","date":"2024-03-04","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/:9:0","tags":["操作系统"],"title":"操作系统(第一章)","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"categories":["操作系统"],"content":"优点 ","date":"2024-03-04","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/:10:0","tags":["操作系统"],"title":"操作系统(第一章)","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"categories":["操作系统"],"content":"缺点 ","date":"2024-03-04","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/:11:0","tags":["操作系统"],"title":"操作系统(第一章)","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"categories":["hugo"],"content":"使用Hugo+Github搭建自己的个人博客 一、前言介绍 Hugo是一个个人博客静态框架，相比于Hexo更加轻量生成更加快速。结合GitHub.io可以快速的搭建生成属于自己的博客，并且有丰富的主题和插件支持。 二、搭建过程 ","date":"2024-03-01","objectID":"/posts/%E6%90%AD%E5%BB%BAhugo%E5%8D%9A%E5%AE%A2buildblog/:0:0","tags":["hugo"],"title":"搭建hugo博客(buildblog)","uri":"/posts/%E6%90%AD%E5%BB%BAhugo%E5%8D%9A%E5%AE%A2buildblog/"},{"categories":["hugo"],"content":"一.安装Hugo和Git 查阅 Hugo 安装指南：Install Hugo | Hugo，找到对应系统的安装操作。 基本上都是使用各个包工具安装，本人 Win11，比较嫌麻烦就直接下载使用。 打开 Github 中的 Hugo 库，打开右侧的 Realeases，下载最新的版本，本次下载为：hugo_extended_0.82.0_Windows-64bit.zip 解压后，将其中的 hugo.exe 放到指定的安装目录，比如 D:\\softwares\\Hugo\\bin，然后将该目录添加到系统环境变量（win+R → sysdm.cpl → 高级 → 环境变量 → 系统变量 Path）的 Path 下。 打开命令行，输入 hugo version，显示版本号即为安装成功 本地下载 Git ，Win11直接下载 exe ，点击下一步就好了 https://registry.npmmirror.com/binary.html?path=git-for-windows/ 因为官方地址下载可能会缓慢所以这里建议使用镜像地址下载。镜像地址离包含的是Git的所有历史版本，因此要选择一个最新的版本，这里可以对比一下官方地址的版本号，然后去镜像地址找到对应的文件下载下来就可以了。比如我下载的是2.39.2 64bit的版本： 那么镜像地址中就找到对应的版本即可： 三.搭建Hugo网站 新建一个目录，用于存放 Hugo 网站的文件，比如：H:\\HugoWebsite 打开命令行，切换到该目录，执行命令新建一个 Hugo 网站 #blog 是网站文件夹名 hugo new site blog\r四.选择 Hugo 主题 打开 hugo theme 的网站，选择合适的主题，以LoveIt 举例。 Hugo Themes: https://themes.gohugo.io 将选中的主题下载到本地 #进入网站目录 blog cd blog #进入 themes 目录，一般默认有，如果没有自行创建 cd themes #下载主题到 themes 文件夹下 git clone https://github.com/dillonzq/LoveIt.git themes/LoveIt 此处建议选择的这个主题相较适合第一次尝试，配置文件比较详细明了。待熟悉后，可以自行选择主题。 Hugo主题库：https://themes.gohugo.io 个人推荐主题：https://github.com/dillonzq/LoveIt.git 在 Hugo 网站的根目录下（上文提及的 HugoWebsite）配置 config.toml(也有可能是hugo.toml) 详细配置参考: https://hugoloveit.com/zh-cn/theme-documentation-basics/ 在本地启动网站 hugo serve –buildDrafts 打开网址 http://localhost:1313/ 可以进行预览 如果发现预览效果不满意，可以 编辑 config.toml(hugo.toml) 文件 五.部署到 Github 构建 Hugo 网站 在 Hugo 网站文件夹的根目录（H:\\HugoWebsite\\blog）下执行 hugo 命令构建 Hugo 会将构建的网站内容默认保存至网站根目录下的 public/ 文件夹下。 将网站文件夹与 GitHub 建立联系**（仅第一次运行需要）** 进入 H:\\HugoWebsite\\blog\\public 目录，初始化 Git 库 生成的 HTML 文件保存在 “public” 目录中，“public” 文件夹会被转换为 Git 库。 git init 将 Git 本地库关联至远程库 在 H:\\HugoWebsite\\blog\\public 目录下，为 Git 本地库添加远程库，“https://github.com/adan-ning/adan-ning.github.io.git” git remote add origin https://github.com/adan-ning/adan-ning.github.io.git 提交修改 在 H:\\HugoWebsite\\blog\\public 目录下，通过如下命令提交： 查看当前修改状态 git status 添加修改过得文件， . 表示所有，也可以指定文件 git add . ““里面的内容就是提交内容的说明信息 git commit -m “first commit” 提交修改至远程库 在 H:\\HugoWebsite\\blog\\public 目录下，通过如下命令提交： git push -u origin master 然后如果按照博客顺序操作，第一次应该失败的。 因为本地的 git 库和远程的库并不是一致的，需要进行一次 pull 操作才能继续 push。 解决办法：先把除 .git 文件夹外的所有文件复制到其他目录备份，然后 git pull 当前库下的文件下来，然后把这些文件和自己需要的文件结合处理好（本次就是删除这些文件，再把原文件复制回来），重新提交即可。日常推荐这种方法，养成好习惯。 1.移动除 .git 外的文件到另一个目录下 2.pull 该库当前文件，最后的参数是因为合并两个不相关的项目（即，不知道彼此存在并且提交历史不匹配的项目）时，会发生Git错误：fatal: refusing to merge unrelated histories，此时出现记录文件，先按住 ctrl+:，再输入 wq 即可。 git pull origin master –allow-unrelated-histories 3.合并这些文件和第一次移动出去的文件，本次就是删除这些文件，把那些文件移动回来就好了 4.提交本地 git add . git commit -m “first commit” 5.提交远程 git push -u origin master 好了，第一次初始化配置也就成功完成了！输入：https://github用户名.github.io/ 就可以访问部署的网站了。 六.其他 新建文章 1.新建一篇文章，在网站根目录：H:\\HugoWebsite\\blog hugo new post/第二篇测试博客.md 2.在目录 H:\\HugoWebsite\\blog\\content\\post 下找到对应文件进行修改 3.本地预览, http://localhost:1313/ hugo server -D 4.构建 Hugo 网站 hugo 5.切换到目录 H:\\HugoWebsite\\blog\\public ，提交修改至本地库 git add . git commit -m ‘commit info’ 6.将修改推至远程库 git push -u origin master 修改文章 1.当前工作目录：H:\\HugoWebsite\\blog 2.在目录 H:\\HugoWebsite\\blog\\content\\post 下找到对应文件 进行修改 3.本地预览, http://localhost:1313/ hugo server -D 4.构建 Hugo 网站 hugo 5.切换到目录 H:\\HugoWebsite\\blog\\public ，提交修改至本地库 git add . git commit -m ‘commit info’ 6.将修改推至远程库 git push -u origin master 删除文章 1.当前工作目录：H:\\HugoWebsite\\blog 2.删除两处文件 在目录H:\\HugoWebsite\\blog\\content\\post ,H:\\HugoWebsite\\blog\\public 下找到对应文件进行删除 其中 public 下文件不删除也不影响显示，只是该文件就会一直存在，另外该目录下即便文件（除.git)删错或者全部删除也是不影响的，应为 hugo 命令会全部重建 3.本地预览, http://localhost:1313/ hugo server -D 4.构建 Hugo 网站 hugo 5.切换到目录 H:\\HugoWebsite\\blog\\public ，提交修改至本地库 git add . git commit -m ‘commit info’ 6.将修改推至远程库 git push -u origin master 添加图片 可参考：【博客写作指南】GitHub+jsDelivr+PicGo搭建博客图床 - 知乎 (zhihu.com) https://zhuanlan.zhihu.com/p/653131492 七.总结 可以将主题下相关文件复制到 blog 网站根目录下，因为这样可以直接渲染网站效果，而又不影响主题本身的内容。 主要是 themes\\LoveIt\\exampleSite 目录下文件 发布文章如果有参数 draft ，记得将值设为 false，或者删除 draft，不然会被认定为草稿只能本地运行而不能运行到网站上。 基本上就是安装 Hugo ，建站，下载主题，配置主题参数，然后部署就是了。 ","date":"2024-03-01","objectID":"/posts/%E6%90%AD%E5%BB%BAhugo%E5%8D%9A%E5%AE%A2buildblog/:1:0","tags":["hugo"],"title":"搭建hugo博客(buildblog)","uri":"/posts/%E6%90%AD%E5%BB%BAhugo%E5%8D%9A%E5%AE%A2buildblog/"},{"categories":["编程技术"],"content":"代码生成器 ","date":"2024-02-29","objectID":"/posts/%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E5%99%A8/:0:0","tags":["java"],"title":"CodeCreate(代码生成器)","uri":"/posts/%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E5%99%A8/"},{"categories":["编程技术"],"content":"前言 我们在编写一些由Springboot框架的系统时，会有很多类似的结构，而代码生成器则会帮我们自动生成这些结构，从而减少我们的代码量，是我们的编程效率得到大幅提高 ","date":"2024-02-29","objectID":"/posts/%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E5%99%A8/:1:0","tags":["java"],"title":"CodeCreate(代码生成器)","uri":"/posts/%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E5%99%A8/"},{"categories":["编程技术"],"content":"代码展示 import com.baomidou.mybatisplus.core.exceptions.MybatisPlusException; import com.baomidou.mybatisplus.core.toolkit.StringPool; import com.baomidou.mybatisplus.core.toolkit.StringUtils; import com.baomidou.mybatisplus.generator.AutoGenerator; import com.baomidou.mybatisplus.generator.InjectionConfig; import com.baomidou.mybatisplus.generator.config.*; import com.baomidou.mybatisplus.generator.config.po.TableInfo; import com.baomidou.mybatisplus.generator.config.rules.NamingStrategy; import com.baomidou.mybatisplus.generator.engine.FreemarkerTemplateEngine; import java.util.ArrayList; import java.util.List; import java.util.Scanner; public class CodeGenerator { /** * * @param tip * @return * 读取控制台内容 */ public static String scanner(String tip){ Scanner scanner = new Scanner(System.in); StringBuilder help = new StringBuilder(); help.append(\"请输入\"+tip+\":\"); System.out.println(help.toString()); if (scanner.hasNext()){ String ipt = scanner.next(); if (StringUtils.isNotBlank(ipt)){ return ipt; } } throw new MybatisPlusException(\"请输入正确的\"+tip+\"!\"); } /** * 操作步骤 * 1.修改数据源包括地址密码信息，对应代码标记：-，下同 * 2.模块配置，可以修改包名 * 3.修改模板，（这步可忽略） * @param args */ public static void main(String[] args){ //代码生成器 AutoGenerator mpg = new AutoGenerator(); //全局配置 GlobalConfig gc = new GlobalConfig(); String projectPath = System.getProperty(\"user.dir\"); gc.setOutputDir(projectPath+\"/src/main/java\"); gc.setAuthor(\"lqx\"); gc.setOpen(false); gc.setSwagger2(true);//实体属性 Swagger2注解 gc.setBaseResultMap(true);//XML ResultMap gc.setBaseColumnList(true);//XML ColumnList //去掉service接口首字母的I，如D0为UserService gc.setServiceName(\"%sService\"); mpg.setGlobalConfig(gc); //数据源配置 DataSourceConfig dsc = new DataSourceConfig(); //一，修改数据源 dsc.setUrl(\"jdbc:mysql://localhost:3306/db?serverTimezone=UTC\"); dsc.setDriverName(\"com.mysql.cj.jdbc.Driver\"); dsc.setUsername(\"root\"); dsc.setPassword(\"1234\"); mpg.setDataSource(dsc); //包配置 PackageConfig pc = new PackageConfig(); //二，模块配置 pc.setParent(\"com.lqx\") .setEntity(\"entity\") .setMapper(\"mapper\") .setService(\"service\") .setServiceImpl(\"service.impl\") .setController(\"controller\"); mpg.setPackageInfo(pc); //自定义配置 InjectionConfig cfg = new InjectionConfig() { @Override public void initMap() { // to do nothing } }; // 如果模板引擎是 freemarker String templatePath = \"/templates/mapper.xml.ftl\"; // 如果模板引擎是 velocity // String templatePath = \"/templates/mapper.xml.vm\"; // 自定义输出配置 List\u003cFileOutConfig\u003e focList = new ArrayList\u003c\u003e(); // 自定义配置会被优先输出 focList.add(new FileOutConfig(templatePath) { @Override public String outputFile(TableInfo tableInfo) { // 自定义输出文件名 ， 如果你 Entity 设置了前后缀、此处注意 xml 的名称会跟着发生变化！！ return projectPath + \"/src/main/resources/mapper/\" + pc.getModuleName() + \"/\" + tableInfo.getEntityName() + \"Mapper\" + StringPool.DOT_XML; } }); /* cfg.setFileCreate(new IFileCreate() { @Override public boolean isCreate(ConfigBuilder configBuilder, FileType fileType, String filePath) { // 判断自定义文件夹是否需要创建 checkDir(\"调用默认方法创建的目录，自定义目录用\"); if (fileType == FileType.MAPPER) { // 已经生成 mapper 文件判断存在，不想重新生成返回 false return !new File(filePath).exists(); } // 允许生成模板文件 return true; } }); */ cfg.setFileOutConfigList(focList); mpg.setCfg(cfg); // 配置模板 TemplateConfig templateConfig = new TemplateConfig(); // 配置自定义输出模板 //指定自定义模板路径，注意不要带上.ftl/.vm, 会根据使用的模板引擎自动识别 //三，修改模板 // templateConfig.setEntity(\"templates/entity2.java\"); // templateConfig.setService(); // templateConfig.setController(); templateConfig.setXml(null); mpg.setTemplate(templateConfig); // 策略配置 StrategyConfig strategy = new StrategyConfig(); strategy.setNaming(NamingStrategy.underline_to_camel); strategy.setColumnNaming(NamingStrategy.underline_to_camel); // strategy.setSuperEntityClass(\"你自己的父类实体,没有就不用设置!\"); strategy.setEntityLombokModel(true); strategy.setRestControllerStyle(true); // 公共父类 // strategy.setSuperControllerClass(\"你自己的父类控制器,没有就不用设置!\"); // 写于父类中的公共字段 // strategy.setSuperEntityColumns(\"id\"); strategy.setInclude(scanner(\"表名，多个英文逗号分割\").split(\",\")); strategy.setControllerMappingHyphenStyle(true); // strategy.se","date":"2024-02-29","objectID":"/posts/%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E5%99%A8/:2:0","tags":["java"],"title":"CodeCreate(代码生成器)","uri":"/posts/%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E5%99%A8/"},{"categories":["编程技术"],"content":"运行效果 ","date":"2024-02-29","objectID":"/posts/%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E5%99%A8/:3:0","tags":["java"],"title":"CodeCreate(代码生成器)","uri":"/posts/%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E5%99%A8/"},{"categories":["编程技术"],"content":"运行操作 ","date":"2024-02-29","objectID":"/posts/%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E5%99%A8/:3:1","tags":["java"],"title":"CodeCreate(代码生成器)","uri":"/posts/%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E5%99%A8/"},{"categories":["编程技术"],"content":"运行结果 ","date":"2024-02-29","objectID":"/posts/%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E5%99%A8/:3:2","tags":["java"],"title":"CodeCreate(代码生成器)","uri":"/posts/%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E5%99%A8/"},{"categories":["hugo"],"content":"每次更新hugo博客的操作 ","date":"2024-02-18","objectID":"/posts/%E6%AF%8F%E6%AC%A1%E6%9B%B4%E6%96%B0hugo%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%93%8D%E4%BD%9C/:0:0","tags":["hugo"],"title":"每次更新hugo博客的操作","uri":"/posts/%E6%AF%8F%E6%AC%A1%E6%9B%B4%E6%96%B0hugo%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%93%8D%E4%BD%9C/"},{"categories":["hugo"],"content":"每次更新hugo博客所需的操作 打开 PowerShell / cmd 终端，打开最初用 hugo 搭建的博客所在的文件夹，以我为例： cd e:\\myblog ","date":"2024-02-18","objectID":"/posts/%E6%AF%8F%E6%AC%A1%E6%9B%B4%E6%96%B0hugo%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%93%8D%E4%BD%9C/:1:0","tags":["hugo"],"title":"每次更新hugo博客的操作","uri":"/posts/%E6%AF%8F%E6%AC%A1%E6%9B%B4%E6%96%B0hugo%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%93%8D%E4%BD%9C/"},{"categories":["hugo"],"content":"第一步 新建一个 markdown(.md) 格式的文件(如果要修改原来的文件可不需要新建) hugo new post/FileName.md 其中 FileName 为自定义的文件名 ","date":"2024-02-18","objectID":"/posts/%E6%AF%8F%E6%AC%A1%E6%9B%B4%E6%96%B0hugo%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%93%8D%E4%BD%9C/:1:1","tags":["hugo"],"title":"每次更新hugo博客的操作","uri":"/posts/%E6%AF%8F%E6%AC%A1%E6%9B%B4%E6%96%B0hugo%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%93%8D%E4%BD%9C/"},{"categories":["hugo"],"content":"第二步 输入命令： hugo —theme=hugo-tranquilpeak-theme —baseUrl=\"https://tzq0301.github.io\" —buildDrafts 其中，hugo-tranquilpeak-theme 是我所应用的主题，https://tzq0301.github.io 是我的GitHub中为hugo博客配置的仓库 ","date":"2024-02-18","objectID":"/posts/%E6%AF%8F%E6%AC%A1%E6%9B%B4%E6%96%B0hugo%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%93%8D%E4%BD%9C/:1:2","tags":["hugo"],"title":"每次更新hugo博客的操作","uri":"/posts/%E6%AF%8F%E6%AC%A1%E6%9B%B4%E6%96%B0hugo%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%93%8D%E4%BD%9C/"},{"categories":["hugo"],"content":"第三步 把博客部署到远程GitHub仓库 首先切换到 public 文件夹： cd public 此时，正处于 e:\\myblog\\public 中 接下来输入以下指令： git add . git commit -m “yyyy/mm/dd-hh:mm” git push -u origin master 其中 yyyy/mm/dd-hh:mm 为每次提交的名称，引号内可以随意更改，yyyy/mm/dd-hh:mm 是我个人采用的格式，以时间做标记可保证不会重复 最后现在刷新GitHub，登陆个人博客查看即可 ","date":"2024-02-18","objectID":"/posts/%E6%AF%8F%E6%AC%A1%E6%9B%B4%E6%96%B0hugo%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%93%8D%E4%BD%9C/:1:3","tags":["hugo"],"title":"每次更新hugo博客的操作","uri":"/posts/%E6%AF%8F%E6%AC%A1%E6%9B%B4%E6%96%B0hugo%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%93%8D%E4%BD%9C/"}]