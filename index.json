[{"categories":["数据结构"],"content":"概念 相互之间存在一种或多种特定关系的数据元素的集合 逻辑结构，存储结构，运算合称为三要素 ","date":"2024-03-10","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:0:0","tags":["数据结构"],"title":"数据结构(第一章)","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["数据结构"],"content":"数据结构形式定义 数据结构是一个二元组 Data_Structure = (D,S) D是数据元素的有限集，S是D上关系的有限集 基本术语 ","date":"2024-03-10","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:1:0","tags":["数据结构"],"title":"数据结构(第一章)","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["数据结构"],"content":"数据 所有能被计算机识别，存储和处理的符号的集合 ","date":"2024-03-10","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:2:0","tags":["数据结构"],"title":"数据结构(第一章)","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["数据结构"],"content":"数据元素 是数据的基本单位，具有完整的实际意义。一个数据元素可由若干个数据项组成 ","date":"2024-03-10","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:3:0","tags":["数据结构"],"title":"数据结构(第一章)","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["数据结构"],"content":"数据项 构成数据元素的项目。是数据不可分割的最小单位 ","date":"2024-03-10","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:4:0","tags":["数据结构"],"title":"数据结构(第一章)","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["数据结构"],"content":"数据类型 指一个类型和定义在这个类型上的操作集合。 ","date":"2024-03-10","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:5:0","tags":["数据结构"],"title":"数据结构(第一章)","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["数据结构"],"content":"抽象数据元素 抽象定义的，没有实际含义的数据元素 ","date":"2024-03-10","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:6:0","tags":["数据结构"],"title":"数据结构(第一章)","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["数据结构"],"content":"抽象数据类型 用户自己定义的数据类型 数据结构涵盖的内客 ","date":"2024-03-10","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:7:0","tags":["数据结构"],"title":"数据结构(第一章)","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["数据结构"],"content":"逻辑结构 ","date":"2024-03-10","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:8:0","tags":["数据结构"],"title":"数据结构(第一章)","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["数据结构"],"content":"线性结构 线性表，栈，队，串，数组 ","date":"2024-03-10","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:8:1","tags":["数据结构"],"title":"数据结构(第一章)","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["数据结构"],"content":"非线性结构 树结构，图结构，集合结构 ","date":"2024-03-10","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:8:2","tags":["数据结构"],"title":"数据结构(第一章)","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["数据结构"],"content":"物理结构(存储结构) 是数据的逻辑结构在计算机存储器内的表示(或映像)。它依赖于计算机 ","date":"2024-03-10","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:9:0","tags":["数据结构"],"title":"数据结构(第一章)","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["数据结构"],"content":"分类 顺序结构，链式结构，索引结构，散列结构 ","date":"2024-03-10","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:9:1","tags":["数据结构"],"title":"数据结构(第一章)","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["数据结构"],"content":"数据运算 在数据的逻辑结构上定义的操作算法 ","date":"2024-03-10","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:10:0","tags":["数据结构"],"title":"数据结构(第一章)","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["数据结构"],"content":"分类 插入运算，删除运算，修改运算，查找运算，排序运算 数据类型与抽象数据类型的区别 ","date":"2024-03-10","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:10:1","tags":["数据结构"],"title":"数据结构(第一章)","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["数据结构"],"content":"数据类型 是一个值的集合和定义在该值上的一组操作的总称 ","date":"2024-03-10","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:11:0","tags":["数据结构"],"title":"数据结构(第一章)","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["数据结构"],"content":"抽象数据类型 由用户定义，用以表示应用问题的数据类型。它由基本的数据类型构成，并包括一组相关的服务(或称操作) 它与数据类犁实质上是一个概念，但其特征是使用与实现相分离，实行数据封装和信息隐蔽(独立于计算机) ","date":"2024-03-10","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:12:0","tags":["数据结构"],"title":"数据结构(第一章)","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["数据结构"],"content":"抽象数据类型用三元组表示 ADT = (D,S,P) D:数据对象 S:D上的关系集 P:D上的操作集 ","date":"2024-03-10","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:13:0","tags":["数据结构"],"title":"数据结构(第一章)","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["数据结构"],"content":"ADT常用定义格式 算法和算法分析 ","date":"2024-03-10","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:14:0","tags":["数据结构"],"title":"数据结构(第一章)","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["数据结构"],"content":"算法 是对特定问题求解步骤的一种描述，是指令的有限序列，输入转换输出的计算步骤 好的程序设计：好算法+好结构 ","date":"2024-03-10","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:15:0","tags":["数据结构"],"title":"数据结构(第一章)","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["数据结构"],"content":"基本特性 有穷性，确定性，可行性，必有输出 ","date":"2024-03-10","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:15:1","tags":["数据结构"],"title":"数据结构(第一章)","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["数据结构"],"content":"评价指标 正确性，可读性，健状性，高效率(常用时间复杂度衡量)与低存储量(常用空间复杂度衡量)需求 ","date":"2024-03-10","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:15:2","tags":["数据结构"],"title":"数据结构(第一章)","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["数据结构"],"content":"算法描述方式 自然语言，程序设计语言，流程图，类高级语言(类C语言，类Pascal语言等) ","date":"2024-03-10","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:15:3","tags":["数据结构"],"title":"数据结构(第一章)","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["数据结构"],"content":"类C语言描述语法 类C语言精选了C语言的一个核心子集，也做了若干扩充，以利于描述 ","date":"2024-03-10","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:15:4","tags":["数据结构"],"title":"数据结构(第一章)","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["数据结构"],"content":"时间复杂度 若存在两个正常数c,n0，对于所有的n\u003e=n0，有| f(n) |\u003c= c| g(n) |， 则记作f(n)=O(g(n)) 频度：是指该语句重复执行的次数 定理：若A(n)=amnm+am-1nm-1+…+a1n+a0是一个m次多项式，则A(n)=0(nm) ","date":"2024-03-10","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:16:0","tags":["数据结构"],"title":"数据结构(第一章)","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["数据结构"],"content":"空间复杂度 算法所需存储空间的量度 记作：S(n)=O(f(n)) 其中n为问题的规模(或大小) ","date":"2024-03-10","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:17:0","tags":["数据结构"],"title":"数据结构(第一章)","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["数据结构"],"content":"线性表定义 一个线性表是n个数据元素的有限序列 ","date":"2024-03-10","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%842/:0:0","tags":["数据结构"],"title":"数据结构(第二章)","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%842/"},{"categories":["数据结构"],"content":"数据元素类型 原子型 整数，字符 结构类型 表示学生的数据元素 ","date":"2024-03-10","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%842/:1:0","tags":["数据结构"],"title":"数据结构(第二章)","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%842/"},{"categories":["数据结构"],"content":"线性表中的元素之间的关系是线性关系 存在惟一的第一个元素 存在惟一的最后一个元素 除第一个元素之外，每个元素均只有一个直接前驱 除最后一个元素之外，每个元素均只有一个直接后继 ","date":"2024-03-10","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%842/:2:0","tags":["数据结构"],"title":"数据结构(第二章)","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%842/"},{"categories":["数据结构"],"content":"顺序表 线性表的顺序存储 ","date":"2024-03-10","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%842/:3:0","tags":["数据结构"],"title":"数据结构(第二章)","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%842/"},{"categories":["数据结构"],"content":"内涵 指用一组地址连续的存储单元依次存储线性表的数据元素。 ","date":"2024-03-10","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%842/:3:1","tags":["数据结构"],"title":"数据结构(第二章)","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%842/"},{"categories":["数据结构"],"content":"特点 存储单元地址连续(需要一段连续空间)逻辑上相邻的数据元素其物理位置也相邻存储密度大(100%) 随机存取 元素序号与存储位置存在如下关系： *Loc(ai) = Loc(ai)+(i-1)d (1\u003c=i\u003c=n) 线性表的动态分配顺序存储结构 在上述定义中，数组指针elem指示线性表的基地址，length指示线性表的当前长度。顺序表的初始化操作就是为顺序表分配一个预定义大小的数组空间，并将线性表的当前长度设为“0”.listsize指示顺序表当前分配的存储空间大小，一旦因插入元素而空间不足时，可再进行分配，即为顺序表增加一个大小为存储LISTINCREMENT个数据元素的空间 ","date":"2024-03-10","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%842/:3:2","tags":["数据结构"],"title":"数据结构(第二章)","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%842/"},{"categories":["面向对象程序设计"],"content":"c++的产生 c++是从c语言发展演变而来的，引入了类的机制，最初也被称为\"带类的C\" 特点 保持c的简洁，高效和接近汇编语言等特点 对c的类型系统进行改革和扩充 c++也支持面向过程的程序设计，不是一个纯正的面向对象的语言 支持面向对象的方法 实例 c++ #include using namespace std; int main(){ ​ cout«“Hello\\n”; ​ cout«“Welcome to c++!\\n”; } 结果 Hello! Welcome to c++! 实例说明 在新的c++标准程序库中，所有标识符都声明在命名空间std中，且头文件不使用扩展名 头文件使用旧版(带扩展名)和新版(不带扩展名)皆可，但不可以混用 名字空间防止命名冲突 c++ 命名空间声明： namespace NS{ ​ class File; ​ void fun(); } 命名空间内标识符使用： NS::File obj; NS::Fun(); 简洁方法: using namespace NS; 函数 把相关的语句组织在一起，注明相应的名称，利用这种方法把程序分块，这种形式的组合就叫做函数 一个c++程序由一个主函数(main)和若干个函数构成 ","date":"2024-03-09","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/:0:0","tags":["面向对象程序设计"],"title":"c++(two)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/"},{"categories":["面向对象程序设计"],"content":"分类 标准库函数和用户自定义函数 由主函数调用其他函数，其他函数也可以相互调用 函数驱动机制 c++字符集 大小写的英文字母：A~Z,a~z 数字字符:0~9 特殊字符： 空格 ! # % ^ \u0026 * __(下划线) + = -(减号) ~ \u003c \u003e / \\ ’ \" ; . , () [ ] {} 关键字 https://blog.csdn.net/wuxinliulei/article/details/9787901 ","date":"2024-03-09","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/:1:0","tags":["面向对象程序设计"],"title":"c++(two)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/"},{"categories":["hugo"],"content":"用Hugo配合Algolia实现高效美观的站内搜索 ","date":"2024-03-09","objectID":"/posts/%E7%94%A8hugo%E9%85%8D%E5%90%88algolia%E5%AE%9E%E7%8E%B0%E9%AB%98%E6%95%88%E7%BE%8E%E8%A7%82%E7%9A%84%E7%AB%99%E5%86%85%E6%90%9C%E7%B4%A2/:0:0","tags":["hugo"],"title":"用Hugo配合Algolia实现高效美观的站内搜索","uri":"/posts/%E7%94%A8hugo%E9%85%8D%E5%90%88algolia%E5%AE%9E%E7%8E%B0%E9%AB%98%E6%95%88%E7%BE%8E%E8%A7%82%E7%9A%84%E7%AB%99%E5%86%85%E6%90%9C%E7%B4%A2/"},{"categories":["hugo"],"content":"前言 很多的 Hugo 主题是没有自带搜索功能的，但是们为了方便用户浏览和查找内容是需要在网站上提供搜索功能。大家可以查看 Hugo 官方推荐的搜索方案，这里我选择的是 Algolia ， 折腾了很久，主题也从EVEN更新到了现在的LOVEIT，发现也并非很繁琐，以下是折腾后的成果。 ","date":"2024-03-09","objectID":"/posts/%E7%94%A8hugo%E9%85%8D%E5%90%88algolia%E5%AE%9E%E7%8E%B0%E9%AB%98%E6%95%88%E7%BE%8E%E8%A7%82%E7%9A%84%E7%AB%99%E5%86%85%E6%90%9C%E7%B4%A2/:1:0","tags":["hugo"],"title":"用Hugo配合Algolia实现高效美观的站内搜索","uri":"/posts/%E7%94%A8hugo%E9%85%8D%E5%90%88algolia%E5%AE%9E%E7%8E%B0%E9%AB%98%E6%95%88%E7%BE%8E%E8%A7%82%E7%9A%84%E7%AB%99%E5%86%85%E6%90%9C%E7%B4%A2/"},{"categories":["hugo"],"content":"在Algolia 端创建应用和索引 ","date":"2024-03-09","objectID":"/posts/%E7%94%A8hugo%E9%85%8D%E5%90%88algolia%E5%AE%9E%E7%8E%B0%E9%AB%98%E6%95%88%E7%BE%8E%E8%A7%82%E7%9A%84%E7%AB%99%E5%86%85%E6%90%9C%E7%B4%A2/:2:0","tags":["hugo"],"title":"用Hugo配合Algolia实现高效美观的站内搜索","uri":"/posts/%E7%94%A8hugo%E9%85%8D%E5%90%88algolia%E5%AE%9E%E7%8E%B0%E9%AB%98%E6%95%88%E7%BE%8E%E8%A7%82%E7%9A%84%E7%AB%99%E5%86%85%E6%90%9C%E7%B4%A2/"},{"categories":["hugo"],"content":"Application 点击NEW APPLICATION，Name可选，方案选择FREE，然后创建，随后的地区选择邻近地区即可； ","date":"2024-03-09","objectID":"/posts/%E7%94%A8hugo%E9%85%8D%E5%90%88algolia%E5%AE%9E%E7%8E%B0%E9%AB%98%E6%95%88%E7%BE%8E%E8%A7%82%E7%9A%84%E7%AB%99%E5%86%85%E6%90%9C%E7%B4%A2/:2:1","tags":["hugo"],"title":"用Hugo配合Algolia实现高效美观的站内搜索","uri":"/posts/%E7%94%A8hugo%E9%85%8D%E5%90%88algolia%E5%AE%9E%E7%8E%B0%E9%AB%98%E6%95%88%E7%BE%8E%E8%A7%82%E7%9A%84%E7%AB%99%E5%86%85%E6%90%9C%E7%B4%A2/"},{"categories":["hugo"],"content":"Indices \u0026 Index 点击侧栏的Indices，然后点击Create Index，Index name自定义（例如自己的域名） ","date":"2024-03-09","objectID":"/posts/%E7%94%A8hugo%E9%85%8D%E5%90%88algolia%E5%AE%9E%E7%8E%B0%E9%AB%98%E6%95%88%E7%BE%8E%E8%A7%82%E7%9A%84%E7%AB%99%E5%86%85%E6%90%9C%E7%B4%A2/:2:2","tags":["hugo"],"title":"用Hugo配合Algolia实现高效美观的站内搜索","uri":"/posts/%E7%94%A8hugo%E9%85%8D%E5%90%88algolia%E5%AE%9E%E7%8E%B0%E9%AB%98%E6%95%88%E7%BE%8E%E8%A7%82%E7%9A%84%E7%AB%99%E5%86%85%E6%90%9C%E7%B4%A2/"},{"categories":["hugo"],"content":"API Keys 点击侧栏API Keys，记住以下的 Keys，之后都会用到； ","date":"2024-03-09","objectID":"/posts/%E7%94%A8hugo%E9%85%8D%E5%90%88algolia%E5%AE%9E%E7%8E%B0%E9%AB%98%E6%95%88%E7%BE%8E%E8%A7%82%E7%9A%84%E7%AB%99%E5%86%85%E6%90%9C%E7%B4%A2/:2:3","tags":["hugo"],"title":"用Hugo配合Algolia实现高效美观的站内搜索","uri":"/posts/%E7%94%A8hugo%E9%85%8D%E5%90%88algolia%E5%AE%9E%E7%8E%B0%E9%AB%98%E6%95%88%E7%BE%8E%E8%A7%82%E7%9A%84%E7%AB%99%E5%86%85%E6%90%9C%E7%B4%A2/"},{"categories":["hugo"],"content":"在本地生成索引 ","date":"2024-03-09","objectID":"/posts/%E7%94%A8hugo%E9%85%8D%E5%90%88algolia%E5%AE%9E%E7%8E%B0%E9%AB%98%E6%95%88%E7%BE%8E%E8%A7%82%E7%9A%84%E7%AB%99%E5%86%85%E6%90%9C%E7%B4%A2/:3:0","tags":["hugo"],"title":"用Hugo配合Algolia实现高效美观的站内搜索","uri":"/posts/%E7%94%A8hugo%E9%85%8D%E5%90%88algolia%E5%AE%9E%E7%8E%B0%E9%AB%98%E6%95%88%E7%BE%8E%E8%A7%82%E7%9A%84%E7%AB%99%E5%86%85%E6%90%9C%E7%B4%A2/"},{"categories":["hugo"],"content":"config.yaml 在themes同级添加config.yaml文件,注意这里的key是Admin API Key。 --- baseurl: \"https://www.adan-ning.github.io\" DefaultContentLanguage: \"zh-cn\" hasCJKLanguage: true languageCode: \"zh-cn\" title: \"lqx's blog\" theme: \"loveit\" metaDataFormat: \"yaml\" algolia: index: \"**blogloveit\" key: \"*****9748e4cf6b\" appID: \"***KWB5\" --- ","date":"2024-03-09","objectID":"/posts/%E7%94%A8hugo%E9%85%8D%E5%90%88algolia%E5%AE%9E%E7%8E%B0%E9%AB%98%E6%95%88%E7%BE%8E%E8%A7%82%E7%9A%84%E7%AB%99%E5%86%85%E6%90%9C%E7%B4%A2/:3:1","tags":["hugo"],"title":"用Hugo配合Algolia实现高效美观的站内搜索","uri":"/posts/%E7%94%A8hugo%E9%85%8D%E5%90%88algolia%E5%AE%9E%E7%8E%B0%E9%AB%98%E6%95%88%E7%BE%8E%E8%A7%82%E7%9A%84%E7%AB%99%E5%86%85%E6%90%9C%E7%B4%A2/"},{"categories":["hugo"],"content":"hugo-aligolia 我们这里使用一个hugo-algolia的插件来完成我们的数据同步工作,要安装hugo-aligolia我们需要先确保我们已经安装了 npm 或者 yarn 包管理工具。 使用下面的命令安装即可： $ npm install hugo-algolia -g 配置完成以后，在根目录下面执行下面的命令： $ hugo-algolia -s JSON index file was created in public/algolia.json { updatedAt: '2020-01-23T02:36:09.480Z', taskID: 249063848950 } 这个时候我们在 dashboard 中打开 Indices，可以看到已经有几十条数据了。 如果某篇文章不想被索引的话，我们只需要在文件的最前面设置 index 参数为 false 即可。 ","date":"2024-03-09","objectID":"/posts/%E7%94%A8hugo%E9%85%8D%E5%90%88algolia%E5%AE%9E%E7%8E%B0%E9%AB%98%E6%95%88%E7%BE%8E%E8%A7%82%E7%9A%84%E7%AB%99%E5%86%85%E6%90%9C%E7%B4%A2/:3:2","tags":["hugo"],"title":"用Hugo配合Algolia实现高效美观的站内搜索","uri":"/posts/%E7%94%A8hugo%E9%85%8D%E5%90%88algolia%E5%AE%9E%E7%8E%B0%E9%AB%98%E6%95%88%E7%BE%8E%E8%A7%82%E7%9A%84%E7%AB%99%E5%86%85%E6%90%9C%E7%B4%A2/"},{"categories":["hugo"],"content":"hugo.toml文件配置 配置结束后，就可以使用Algolia 的搜索功能 ","date":"2024-03-09","objectID":"/posts/%E7%94%A8hugo%E9%85%8D%E5%90%88algolia%E5%AE%9E%E7%8E%B0%E9%AB%98%E6%95%88%E7%BE%8E%E8%A7%82%E7%9A%84%E7%AB%99%E5%86%85%E6%90%9C%E7%B4%A2/:4:0","tags":["hugo"],"title":"用Hugo配合Algolia实现高效美观的站内搜索","uri":"/posts/%E7%94%A8hugo%E9%85%8D%E5%90%88algolia%E5%AE%9E%E7%8E%B0%E9%AB%98%E6%95%88%E7%BE%8E%E8%A7%82%E7%9A%84%E7%AB%99%E5%86%85%E6%90%9C%E7%B4%A2/"},{"categories":["计算机组成原理"],"content":"计算机组成部分 运算器，控制器，存储器，输入/输出设备 概念 计算机是一种以电子器件为基础的，不需人的直接干预，能够对各种数字化信息，进行算术和逻辑运算的快速工具 层次 ","date":"2024-03-09","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/:0:0","tags":["计算机组成原理"],"title":"计算机组成(第一章)","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"},{"categories":["计算机组成原理"],"content":"电子数字计算机 以电子器件为物质基础 ","date":"2024-03-09","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/:1:0","tags":["计算机组成原理"],"title":"计算机组成(第一章)","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"},{"categories":["计算机组成原理"],"content":"自动化 不需要人的直接干预 ","date":"2024-03-09","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/:2:0","tags":["计算机组成原理"],"title":"计算机组成(第一章)","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"},{"categories":["计算机组成原理"],"content":"数字化信息 二进制 ","date":"2024-03-09","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/:3:0","tags":["计算机组成原理"],"title":"计算机组成(第一章)","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"},{"categories":["计算机组成原理"],"content":"算逻运算 基本运算操作是算术和逻辑运算 ","date":"2024-03-09","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/:4:0","tags":["计算机组成原理"],"title":"计算机组成(第一章)","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"},{"categories":["计算机组成原理"],"content":"快速工具 电子器件 存储程序 特征 ","date":"2024-03-09","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/:5:0","tags":["计算机组成原理"],"title":"计算机组成(第一章)","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"},{"categories":["计算机组成原理"],"content":"内部特征 高速高集成开关元件 数字化信息编码 逻辑判断和处理能力 存储程序 ","date":"2024-03-09","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/:6:0","tags":["计算机组成原理"],"title":"计算机组成(第一章)","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"},{"categories":["计算机组成原理"],"content":"外部特征 快速性(由内部特征中1，4决定) 准确性(由内部特征中2，4决定) 逻辑性(由内部特征中1，3，4决定) 通用性(由内部特征中1，2，3，4决定) 分类 模拟计算机和数字计算机 ","date":"2024-03-09","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/:7:0","tags":["计算机组成原理"],"title":"计算机组成(第一章)","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"},{"categories":["计算机组成原理"],"content":"各自特点 ","date":"2024-03-09","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/:8:0","tags":["计算机组成原理"],"title":"计算机组成(第一章)","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"},{"categories":["计算机组成原理"],"content":"区别(图) 应用 科学计算 教育和卫生 自动控制和测量 家用电器 信息处理 人工智能 计算机的硬件系统组成 指令字和数据字，指令流和数据流 指令字 某字为一条指令 数据字 某字代表要处理的数据 指令流 在取指周期中从内存读出的信息，它流向控制器 数据流 而执行周期中从内存读出的信息，它由内存流向运算器 ","date":"2024-03-09","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/:9:0","tags":["计算机组成原理"],"title":"计算机组成(第一章)","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"},{"categories":["计算机组成原理"],"content":"时间上 在取指周期中，CPU从内存读出的信息一定是指令；而执行周期中从内存读出或写入的信息一定是数据 ","date":"2024-03-09","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/:10:0","tags":["计算机组成原理"],"title":"计算机组成(第一章)","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"},{"categories":["计算机组成原理"],"content":"空间上 指令一定流向控制器；而数据则是在内存(或寄存器)与运算器之间流动 系统总线 总线 传递信息的一组公用导线，信息通道 系统总线 微机系统中信息交换的主要公共通道 地址总线 单向输出主存单元或I/O端口的地址信息 数据总线 读(Read)操作数据输入微处理器；写(Write)操作数据输出到外界(主存或外设) 控制总线 有些控制信号或状态信号；有些请求或联络信号输入 微机系统采用总线结构，总线连接使得微机组合灵活，扩展方便 ","date":"2024-03-09","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/:11:0","tags":["计算机组成原理"],"title":"计算机组成(第一章)","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"},{"categories":["面向对象程序设计"],"content":"计算机程序 ","date":"2024-03-08","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/:0:0","tags":["面向对象程序设计"],"title":"c++(one)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"},{"categories":["面向对象程序设计"],"content":"面向对象的方法 抽象 分类所依据的原则 忽略事物的非本质特征，从而找出事物的共性，把具有共同性质的事物划分为一类，得出一个抽象的概念 封装 把对象的属性和行为结合成一个独立的系统单位 尽可能隐藏对象的内部细节。对外形成一个边界(或屏障)，只保留有限的对外接口使之与外部发生联系 继承(多继承) 特殊类的对象拥有其一般类的全部属性与行为 多态 在一般类中定义的属性或行为，被特殊类继承之后，可以具有不同的数据类型或表现出不同的行为。这使得同一个属性或行为在一般类及其各个特殊类中具有不同的语义 ","date":"2024-03-08","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/:1:0","tags":["面向对象程序设计"],"title":"c++(one)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"},{"categories":["面向对象程序设计"],"content":"类和对象 对象：将数据及对数据的操作方法封装在一起，做为一个互相依存，不可分离的整体 对象与对象之间通过消息通讯 类：对同类型对象抽象出其共性 类通过一个简单的外部接口，与外界发生关系 一般意义上的对象 是现实世界中一个实际存在的事物，可以是有形的(如：一辆汽车)，也可以是无形的(如：一项计划) 是构成世界的一个独立单位，具有： **静态特征:**可以用某种数据描述 **动态特征:**对象所表现的行为或具有的功能 类与对象的关系 就如模具与铸件之间的关系，一个属于某类的对象称为该类的一个实例 ","date":"2024-03-08","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/:2:0","tags":["面向对象程序设计"],"title":"c++(one)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"},{"categories":["编译原理"],"content":"高级语言的定义 ","date":"2024-03-06","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%862/:0:0","tags":["编译原理"],"title":"编译引论(第二章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%862/"},{"categories":["编译原理"],"content":"语法 任何高级语言程序都可以看成是一个特定字母表(即元素的非空有穷集合)上的一个字符串(有穷序列) ","date":"2024-03-06","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%862/:1:0","tags":["编译原理"],"title":"编译引论(第二章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%862/"},{"categories":["编译原理"],"content":"词法规则 指单词符号的形成规则，它确定语言的单词符号，单词符号一般包括：标识符，保留字，界符，算符等 ","date":"2024-03-06","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%862/:2:0","tags":["编译原理"],"title":"编译引论(第二章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%862/"},{"categories":["编译原理"],"content":"语法规则 从单词符号形成更大的结构(即语法单位)，它是语法单位的形成规则，一般语法单位有：表达式，语句，函数，程序等 ","date":"2024-03-06","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%862/:3:0","tags":["编译原理"],"title":"编译引论(第二章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%862/"},{"categories":["编译原理"],"content":"语义 定义它的单词符号和语法单位的意义 所谓一个语言的语义是指这样的一组规则，使用它可以定义一个程序的意义 文法和语言 ","date":"2024-03-06","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%862/:4:0","tags":["编译原理"],"title":"编译引论(第二章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%862/"},{"categories":["编译原理"],"content":"基本概念 ","date":"2024-03-06","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%862/:5:0","tags":["编译原理"],"title":"编译引论(第二章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%862/"},{"categories":["编译原理"],"content":"字母表 字母表：元素的非空有穷集合，习惯上用大写字母表示，如 ∑ ={a,b} 符号:字母表中的每一个元素，如a,b; ","date":"2024-03-06","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%862/:5:1","tags":["编译原理"],"title":"编译引论(第二章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%862/"},{"categories":["编译原理"],"content":"符号串 符号串:字母表中的符号的有穷序列，如 a,b,aa,bb….。 空符号串：不含任何符号的符号串，记为ε 符号串集合：字母表∑上的符号串组成的集合。 ","date":"2024-03-06","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%862/:5:2","tags":["编译原理"],"title":"编译引论(第二章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%862/"},{"categories":["编译原理"],"content":"符号串运算 符号串长度：符号串中所包含的符号个数。设符号串为x,则其长度记为|x|。 符号串连接:设有符号串x和y，把y的所有符号相继写在x的符号串之后所得到的符号串即称为x和y的连接，记为xy 例：εx=xε=x 符号串的方幂：设x的符号串，则x的n次连接称为n次方幂，记为xn。 例：x0=ε 符号串的前缀，后缀，子串 假设x是一个符号串，则有： 符号串x的前缀是指：从符号串x的尾部删除若干(含0个)符号后得到的符号串； 符号串x的后缀是指：从符号串x的头部删除若干(含0个)符号后得到的符号串： 符号串x的子串是指：删除了x前缀(或删除x的后缀或删除x的前缀和后缀)后得到的符号串； 对任意的符号串x，x的前缀，后缀都是x的子串，但x的子串不一定是x的前缀或后缀。 对任意的符号串x，x和ε都是符号串x的前缀，后缀，也是x的子串。 ","date":"2024-03-06","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%862/:5:3","tags":["编译原理"],"title":"编译引论(第二章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%862/"},{"categories":["编译原理"],"content":"符号串集合的运算 符号串的集合的乘积 设A，B为符号串集合，则符号串集合的乘积表示为AB={xy|x∈A,y∈B},即A中的任意符号串和B中的任意符号串的连接所构成的集合。 以为有 xε=εx=x,所以有{ε}A={ε}A=A 注：∅A= A∅ =∅ 符号串集合的方幂：即同一个符号串集合的乘积。 例：设A为符号串集合，则 A0={ε} , A1=A, A2=AA,….. ","date":"2024-03-06","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%862/:6:0","tags":["编译原理"],"title":"编译引论(第二章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%862/"},{"categories":["操作系统"],"content":"进程管理(引入) ","date":"2024-03-05","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F2/:0:0","tags":["操作系统"],"title":"操作系统(第二章)","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F2/"},{"categories":["操作系统"],"content":"前趋图(也称为：有向无循环图) 条件：有向，无循环 O(圆圈)：节点，代表指令，程序，进程… →：有向边，代表前趋/后继关系 ","date":"2024-03-05","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F2/:1:0","tags":["操作系统"],"title":"操作系统(第二章)","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F2/"},{"categories":["操作系统"],"content":"程序的执行 ","date":"2024-03-05","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F2/:2:0","tags":["操作系统"],"title":"操作系统(第二章)","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F2/"},{"categories":["操作系统"],"content":"顺序执行及特征 特征：顺序性，封闭性，可再现性 顺序→并发(可能性分析图) 例题： 进程的相关概念 ","date":"2024-03-05","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F2/:2:1","tags":["操作系统"],"title":"操作系统(第二章)","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F2/"},{"categories":["操作系统"],"content":"定义 程序的一次执行过程 ","date":"2024-03-05","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F2/:3:0","tags":["操作系统"],"title":"操作系统(第二章)","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F2/"},{"categories":["操作系统"],"content":"结构 进程映像：PCB+程序段+数据段 (中断返回地址存放在PCB中) ","date":"2024-03-05","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F2/:4:0","tags":["操作系统"],"title":"操作系统(第二章)","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F2/"},{"categories":["操作系统"],"content":"动态 由\"创建\"而产生，由\"调度\"而执行，由\"撤消\"而消亡(而程序是静态的) ","date":"2024-03-05","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F2/:5:0","tags":["操作系统"],"title":"操作系统(第二章)","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F2/"},{"categories":["操作系统"],"content":"状态 ","date":"2024-03-05","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F2/:6:0","tags":["操作系统"],"title":"操作系统(第二章)","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F2/"},{"categories":["操作系统"],"content":"三态结构(图) 就绪状态： 条件：获得除CPU以外的所有资源 一个就绪队列 执行状态： 条件：已获得CPU，程序正在执行的状态 在单处理机系统中，只有一个进程处于执行状态；而在多处理机系统中，则有多个进程处于执行状态 阻塞状态： 条件：进程的执行受到阻塞 一个阻塞队列 实事上，在较大的系统中，为了减少队列操作的开销，提高系统效率，根据阻塞原因不同，会设置多个阻塞队列。 ","date":"2024-03-05","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F2/:6:1","tags":["操作系统"],"title":"操作系统(第二章)","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F2/"},{"categories":["计算机算法设计与分析"],"content":"算法与程序 ","date":"2024-03-05","objectID":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%8A%98%E4%B8%8E%E8%AE%BE%E8%AE%A1/:0:0","tags":["计算机算法设计与分析"],"title":"算法与程序(第一章)","uri":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%8A%98%E4%B8%8E%E8%AE%BE%E8%AE%A1/"},{"categories":["计算机算法设计与分析"],"content":"算法 是满足下述性质的指令序列: 输入:有零个或多个外部量作为算法的输入 输出:算法产生至少一个量作为输出 确定性:组成算法的每条指令是清晰的，无歧义的 有限性:算法中每条指令的执行次数是有限的，执行每条指令的时间也是有限的 ","date":"2024-03-05","objectID":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%8A%98%E4%B8%8E%E8%AE%BE%E8%AE%A1/:1:0","tags":["计算机算法设计与分析"],"title":"算法与程序(第一章)","uri":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%8A%98%E4%B8%8E%E8%AE%BE%E8%AE%A1/"},{"categories":["计算机算法设计与分析"],"content":"程序 与算法不同。程序是算法用某种程序设计语言的具体实现，程序可以不满足算法的性质 问题求解(图) 算法复杂性分析 ","date":"2024-03-05","objectID":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%8A%98%E4%B8%8E%E8%AE%BE%E8%AE%A1/:2:0","tags":["计算机算法设计与分析"],"title":"算法与程序(第一章)","uri":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%8A%98%E4%B8%8E%E8%AE%BE%E8%AE%A1/"},{"categories":["计算机算法设计与分析"],"content":"时间复杂性 输入为ⅰ时的跟规模n相关的算法运行时间增长率 ","date":"2024-03-05","objectID":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%8A%98%E4%B8%8E%E8%AE%BE%E8%AE%A1/:3:0","tags":["计算机算法设计与分析"],"title":"算法与程序(第一章)","uri":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%8A%98%E4%B8%8E%E8%AE%BE%E8%AE%A1/"},{"categories":["计算机算法设计与分析"],"content":"空间复杂性 输入为ⅰ时的跟规模n相关的算法辅助空间增长率 ","date":"2024-03-05","objectID":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%8A%98%E4%B8%8E%E8%AE%BE%E8%AE%A1/:4:0","tags":["计算机算法设计与分析"],"title":"算法与程序(第一章)","uri":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%8A%98%E4%B8%8E%E8%AE%BE%E8%AE%A1/"},{"categories":["计算机算法设计与分析"],"content":"分析 算法复杂性分析→算法的能行性 n！，2n，n较大时 同一问题不同算法的算法复杂性分析→算法的优劣 时间复杂性与空间复杂性的分析方法类同，主要讨论时间复杂性 ","date":"2024-03-05","objectID":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%8A%98%E4%B8%8E%E8%AE%BE%E8%AE%A1/:5:0","tags":["计算机算法设计与分析"],"title":"算法与程序(第一章)","uri":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%8A%98%E4%B8%8E%E8%AE%BE%E8%AE%A1/"},{"categories":["计算机算法设计与分析"],"content":"时间复杂性分析方法 ","date":"2024-03-05","objectID":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%8A%98%E4%B8%8E%E8%AE%BE%E8%AE%A1/:6:0","tags":["计算机算法设计与分析"],"title":"算法与程序(第一章)","uri":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%8A%98%E4%B8%8E%E8%AE%BE%E8%AE%A1/"},{"categories":["计算机算法设计与分析"],"content":"分类 非递归算法的时间复杂性分析 递归算法的时间复杂性分析 ","date":"2024-03-05","objectID":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%8A%98%E4%B8%8E%E8%AE%BE%E8%AE%A1/:7:0","tags":["计算机算法设计与分析"],"title":"算法与程序(第一章)","uri":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%8A%98%E4%B8%8E%E8%AE%BE%E8%AE%A1/"},{"categories":["计算机算法设计与分析"],"content":"算法复杂性在渐近意义下的阶 渐近意义下的记号：O，Ω，θ，o，ω g(n)是定义在正数集上的正函数。T(n)为算法的时间复杂性 ","date":"2024-03-05","objectID":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%8A%98%E4%B8%8E%E8%AE%BE%E8%AE%A1/:8:0","tags":["计算机算法设计与分析"],"title":"算法与程序(第一章)","uri":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%8A%98%E4%B8%8E%E8%AE%BE%E8%AE%A1/"},{"categories":["计算机算法设计与分析"],"content":"渐近上界记号O 若T(n) = O(g(n)) 含义：算法在任何实例情况下，其时间复杂度的阶不超过g(n)的阶 即：$\\lim_{n\\rightarrow\\infty}\\frac{T_max(n)}{g(n)}=c\\neq0$,c为常数 上例中 $\\lim_{n\\rightarrow\\infty}\\frac{T_max(n)}{n^2}=\\frac{c4+c5+c6}{2}$为常数，故T(n)=O(n2) ","date":"2024-03-05","objectID":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%8A%98%E4%B8%8E%E8%AE%BE%E8%AE%A1/:8:1","tags":["计算机算法设计与分析"],"title":"算法与程序(第一章)","uri":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%8A%98%E4%B8%8E%E8%AE%BE%E8%AE%A1/"},{"categories":["计算机算法设计与分析"],"content":"记号θ 举例有一个算法A： 最坏情况：Tmax=c1n2+n+4 最好情况：Tmin=c2n2 存在g(n)=n2,有T(n) = Ω(g(n)) 和 T(n) = O(g(n)) 因此 T(n) = θ(g(n)) ","date":"2024-03-05","objectID":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%8A%98%E4%B8%8E%E8%AE%BE%E8%AE%A1/:8:2","tags":["计算机算法设计与分析"],"title":"算法与程序(第一章)","uri":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%8A%98%E4%B8%8E%E8%AE%BE%E8%AE%A1/"},{"categories":["计算机算法设计与分析"],"content":"非紧渐近上界记号 o 若T(n) = o(g(n)) 含义：算法在任何实例情况下，其算法时间复杂性的阶小于g(n)的阶 即 $\\lim_{n\\rightarrow\\infty}\\frac{T_max(n)}{g(n)}=0$ 举例：g(n) = n2,Tmax(n)=c2nlogn —\u003e o(n2) ","date":"2024-03-05","objectID":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%8A%98%E4%B8%8E%E8%AE%BE%E8%AE%A1/:8:3","tags":["计算机算法设计与分析"],"title":"算法与程序(第一章)","uri":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%8A%98%E4%B8%8E%E8%AE%BE%E8%AE%A1/"},{"categories":["计算机算法设计与分析"],"content":"非紧渐近上界记号 ω 若T(n) = ω(g(n)) 含义：算法在任何实例情况下，其算法时间复杂性的阶大于g(n)的阶 即 $\\lim_{n\\rightarrow\\infty}\\frac{T_min(n)}{g(n)}=\\infty$ 举例：g(n)=n,Tmin=c1nlogn—\u003eω(n) ","date":"2024-03-05","objectID":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%8A%98%E4%B8%8E%E8%AE%BE%E8%AE%A1/:8:4","tags":["计算机算法设计与分析"],"title":"算法与程序(第一章)","uri":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%8A%98%E4%B8%8E%E8%AE%BE%E8%AE%A1/"},{"categories":["计算机算法设计与分析"],"content":"简便分析方法 最优算法 ","date":"2024-03-05","objectID":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%8A%98%E4%B8%8E%E8%AE%BE%E8%AE%A1/:9:0","tags":["计算机算法设计与分析"],"title":"算法与程序(第一章)","uri":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%8A%98%E4%B8%8E%E8%AE%BE%E8%AE%A1/"},{"categories":["编译原理"],"content":"编译程序(图) 某一种语言等价地转换成另外一种语言程序(称为目标语言程序) 解释程序(图) 将源程序按动态顺序逐句分晰解释执行，根据语句的含义执行，最终得到运行结果 编译器在语言处理系统中的位置(图) 编译过程 1. 词法分析 任务：输入源程序，对构成源程序的字符串进行扫描和分解，识别一个个单词符号。 依循的原则：构词规则 描述工具：正规式，有限自动机 FOR(保留字) I(标识符) :=(算符) 1(常整数) TO(保留字) 100(常整数) DO(保留字) 2. 语法分析 任务： 在词法分析的基础上，根据语言的语法规则把单词符号串分解成各类语法单位。 依循的原则：语法分析 描述工具：上下文无关文法 i(标识符)=5(无符号整数)+3(无符号整数)j(标识符) 3. 中间代码生成 任务：对语法分析所识别出的各类语法单位，分析其含义，并产生中间代码 依循的原则：语义规则 描述工具：属性文法 中间代码是一种独立于硬件的记号系统。常见的中间代码形式有逆波兰表达式，三元式，四元式等 (i+j)(x-y)翻译为四元式 (+,i,j,T1) (-,x,y,T2) (,T1,T2,T3) 4. 优化 任务：对当前阶段产生的中间代码进行等价加工变换，以期最终生成的目标代码更加高效 依循的原则：等价变换原则 常见的优化种类有公共子表达式删除，复制传播，无用代码删除和常量合并 (*,5.3,2,T1) (=,T1, ,x) 优化后： ( =,10.6, ,x) 5. 目标代码产生 任务：把中间代码变换成特定机器上的低级语言代码 该阶段的工作非常复杂，涉及机器指令的选择，寄存器的调度，以及各种数据类型变量的存储空间分配等。 6. 表格管理程序 完成编译过程中的建表，查表，更新数据等有关表格操作 **7. 错误处理程序 ** 编译程序不仅能对书写正确的程序进行翻译，而且还能对出现在源程序中的错误进行处理 编译程序的结构 ","date":"2024-03-05","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/:0:0","tags":["编译原理"],"title":"编译引论(第一章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"},{"categories":["编译原理"],"content":"编译程序的总体结构(图) 相关概念 ","date":"2024-03-05","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/:1:0","tags":["编译原理"],"title":"编译引论(第一章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"},{"categories":["编译原理"],"content":"“遍\"的概念 所谓\"一遍\"是指，对源程序或中间程序从头到尾扫描一次，并作相关加工处理，生成新的中间程序或相关代码 ","date":"2024-03-05","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/:2:0","tags":["编译原理"],"title":"编译引论(第一章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"},{"categories":["编译原理"],"content":"多遍编译程序 把编译的5个阶段应完成的工作分遍来做，每一遍完成一个或相连几个阶段的工作 ","date":"2024-03-05","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/:3:0","tags":["编译原理"],"title":"编译引论(第一章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"},{"categories":["编译原理"],"content":"前端 通常包括词法分析，语法分析，语义分析及中间代码生成，有的优化工作也可以包括在前端，前端依赖于源程序 ","date":"2024-03-05","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/:3:1","tags":["编译原理"],"title":"编译引论(第一章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"},{"categories":["编译原理"],"content":"后端 通常包括有关代码优化和目标代码生成，依赖于中间代码，计算机的硬件系统和机器指令系统 编译程序开发 ","date":"2024-03-05","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/:3:2","tags":["编译原理"],"title":"编译引论(第一章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"},{"categories":["编译原理"],"content":"自展技术(图) 按照自展技术，需要把源语言L分解成一个核心部分L0与扩充部分L1,L2,….,Ln。分解源语言之后，先用汇编语言或机器语言编写L0的编译程序，然后再用L0编写L1的编译程序，用Li编写Li+n的编译程序(i=1,2,…,n-1),像滚雪球一样，愈滚愈大，最后得到源语言L的编译程序 ","date":"2024-03-05","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/:4:0","tags":["编译原理"],"title":"编译引论(第一章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"},{"categories":["编译原理"],"content":"移植技术 即利用A机器上已有的高级语言L编写一个能够在B机器上运行的高级语言L的编译程序 假设A机器上已经有用A机器代码实现的高级语言L的编译程序，移植实现的具体做法是： 首先用L语言编写出在A机器上运行的产生B机器代码的L语言的编译程序源程序 然后把该编译程序源程序经过A机器上的L编译程序编译后，得到能在A机器上运行产生B机器代码的编译程序 最后用这个编译程序再一次编译第1步编写的编译程序源程序，得到了能在B机器上运行的产生B机器代码的编译程序 ","date":"2024-03-05","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/:5:0","tags":["编译原理"],"title":"编译引论(第一章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"},{"categories":["编译原理"],"content":"自动生成技术 利用工具，编译程序自动生成 LEX：词法分析程序产生器 YACC：语法分析程序产生器 ","date":"2024-03-05","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/:6:0","tags":["编译原理"],"title":"编译引论(第一章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"},{"categories":["操作系统"],"content":"os的定义 ","date":"2024-03-04","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/:0:0","tags":["操作系统"],"title":"操作系统(第一章)","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"categories":["操作系统"],"content":"管理资源 ","date":"2024-03-04","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/:1:0","tags":["操作系统"],"title":"操作系统(第一章)","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"categories":["操作系统"],"content":"硬件 进程，存储器，外部设备 ","date":"2024-03-04","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/:1:1","tags":["操作系统"],"title":"操作系统(第一章)","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"categories":["操作系统"],"content":"软件 文件 ","date":"2024-03-04","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/:1:2","tags":["操作系统"],"title":"操作系统(第一章)","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"categories":["操作系统"],"content":"分配资源 以作业/进程为单位进行调度(cpu算法) ","date":"2024-03-04","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/:2:0","tags":["操作系统"],"title":"操作系统(第一章)","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"categories":["操作系统"],"content":"程序 ","date":"2024-03-04","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/:3:0","tags":["操作系统"],"title":"操作系统(第一章)","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"categories":["操作系统"],"content":"进程 执行的程序(内存) ","date":"2024-03-04","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/:3:1","tags":["操作系统"],"title":"操作系统(第一章)","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"categories":["操作系统"],"content":"作业 暂时不执行的程序(外存) 操作系统概念 一组控制和管理计算机硬件和软件资源，合理地对各类作业进行调度以及方便用户的程序集合。 用户(方便) 作为扩充机器 把覆盖了软件的机器称为扩充机或虚拟机 发展 ","date":"2024-03-04","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/:3:2","tags":["操作系统"],"title":"操作系统(第一章)","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"categories":["操作系统"],"content":"脱机(spooLing(假脱机)) ","date":"2024-03-04","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/:4:0","tags":["操作系统"],"title":"操作系统(第一章)","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"categories":["操作系统"],"content":"外围机 用于管理输入/输出设备 ","date":"2024-03-04","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/:4:1","tags":["操作系统"],"title":"操作系统(第一章)","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"categories":["操作系统"],"content":"磁盘 优点:容量大 ","date":"2024-03-04","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/:4:2","tags":["操作系统"],"title":"操作系统(第一章)","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"categories":["操作系统"],"content":"批处理 ","date":"2024-03-04","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/:5:0","tags":["操作系统"],"title":"操作系统(第一章)","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"categories":["操作系统"],"content":"单道 两种硬件 cpu, i/o 串行工作 ","date":"2024-03-04","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/:5:1","tags":["操作系统"],"title":"操作系统(第一章)","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"categories":["操作系统"],"content":"多道(图) 两种硬件 cpu, i/o 并行工作 分时操作系统 实现人机交互，满足用户需要 实时系统 系统能实时响应外部事件的请求，在规定时间内完成对该事件的处理，并控制所有任务协调一致地运行 操作系统的特征 ","date":"2024-03-04","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/:5:2","tags":["操作系统"],"title":"操作系统(第一章)","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"categories":["操作系统"],"content":"并发性 ","date":"2024-03-04","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/:6:0","tags":["操作系统"],"title":"操作系统(第一章)","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"categories":["操作系统"],"content":"并发 同一个时间间隔发生 ","date":"2024-03-04","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/:6:1","tags":["操作系统"],"title":"操作系统(第一章)","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"categories":["操作系统"],"content":"并行 同一个时刻发生 ","date":"2024-03-04","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/:6:2","tags":["操作系统"],"title":"操作系统(第一章)","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"categories":["操作系统"],"content":"进程和线程 线程也被称为轻型进程 ","date":"2024-03-04","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/:6:3","tags":["操作系统"],"title":"操作系统(第一章)","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"categories":["操作系统"],"content":"共享 系统中资源可供内存中多个并发执行的进程共同使用 ","date":"2024-03-04","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/:7:0","tags":["操作系统"],"title":"操作系统(第一章)","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"categories":["操作系统"],"content":"互斥共享 一段时间内只允许一个进程访问该资源 ","date":"2024-03-04","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/:7:1","tags":["操作系统"],"title":"操作系统(第一章)","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"categories":["操作系统"],"content":"同时访问 微观上仍是互斥的 ","date":"2024-03-04","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/:7:2","tags":["操作系统"],"title":"操作系统(第一章)","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"categories":["操作系统"],"content":"虚拟(逻辑\u003c–\u003e物理) 通过某种技术把一个物理实体变为若干个逻辑上的对应物 ","date":"2024-03-04","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/:8:0","tags":["操作系统"],"title":"操作系统(第一章)","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"categories":["操作系统"],"content":"存储器 逻辑地址→(重定向)物理地址 ","date":"2024-03-04","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/:8:1","tags":["操作系统"],"title":"操作系统(第一章)","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"categories":["操作系统"],"content":"I/O设备 逻辑设备→物理设备 ","date":"2024-03-04","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/:8:2","tags":["操作系统"],"title":"操作系统(第一章)","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"categories":["操作系统"],"content":"异步 运行进度不可预知 了解常见的os的性能(建议ppt) ","date":"2024-03-04","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/:9:0","tags":["操作系统"],"title":"操作系统(第一章)","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"categories":["操作系统"],"content":"优点 ","date":"2024-03-04","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/:10:0","tags":["操作系统"],"title":"操作系统(第一章)","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"categories":["操作系统"],"content":"缺点 ","date":"2024-03-04","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/:11:0","tags":["操作系统"],"title":"操作系统(第一章)","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"categories":["hugo"],"content":"使用Hugo+Github搭建自己的个人博客 一、前言介绍 Hugo是一个个人博客静态框架，相比于Hexo更加轻量生成更加快速。结合GitHub.io可以快速的搭建生成属于自己的博客，并且有丰富的主题和插件支持。 二、搭建过程 ","date":"2024-03-01","objectID":"/posts/%E6%90%AD%E5%BB%BAhugo%E5%8D%9A%E5%AE%A2buildblog/:0:0","tags":["hugo"],"title":"搭建hugo博客(buildblog)","uri":"/posts/%E6%90%AD%E5%BB%BAhugo%E5%8D%9A%E5%AE%A2buildblog/"},{"categories":["hugo"],"content":"一.安装Hugo和Git 查阅 Hugo 安装指南：Install Hugo | Hugo，找到对应系统的安装操作。 基本上都是使用各个包工具安装，本人 Win11，比较嫌麻烦就直接下载使用。 打开 Github 中的 Hugo 库，打开右侧的 Realeases，下载最新的版本，本次下载为：hugo_extended_0.82.0_Windows-64bit.zip 解压后，将其中的 hugo.exe 放到指定的安装目录，比如 D:\\softwares\\Hugo\\bin，然后将该目录添加到系统环境变量（win+R → sysdm.cpl → 高级 → 环境变量 → 系统变量 Path）的 Path 下。 打开命令行，输入 hugo version，显示版本号即为安装成功 本地下载 Git ，Win11直接下载 exe ，点击下一步就好了 https://registry.npmmirror.com/binary.html?path=git-for-windows/ 因为官方地址下载可能会缓慢所以这里建议使用镜像地址下载。镜像地址离包含的是Git的所有历史版本，因此要选择一个最新的版本，这里可以对比一下官方地址的版本号，然后去镜像地址找到对应的文件下载下来就可以了。比如我下载的是2.39.2 64bit的版本： 那么镜像地址中就找到对应的版本即可： 三.搭建Hugo网站 新建一个目录，用于存放 Hugo 网站的文件，比如：H:\\HugoWebsite 打开命令行，切换到该目录，执行命令新建一个 Hugo 网站 #blog 是网站文件夹名 hugo new site blog\r四.选择 Hugo 主题 打开 hugo theme 的网站，选择合适的主题，以LoveIt 举例。 Hugo Themes: https://themes.gohugo.io 将选中的主题下载到本地 #进入网站目录 blog cd blog #进入 themes 目录，一般默认有，如果没有自行创建 cd themes #下载主题到 themes 文件夹下 git clone https://github.com/dillonzq/LoveIt.git themes/LoveIt 此处建议选择的这个主题相较适合第一次尝试，配置文件比较详细明了。待熟悉后，可以自行选择主题。 Hugo主题库：https://themes.gohugo.io 个人推荐主题：https://github.com/dillonzq/LoveIt.git 在 Hugo 网站的根目录下（上文提及的 HugoWebsite）配置 config.toml(也有可能是hugo.toml) 详细配置参考: https://hugoloveit.com/zh-cn/theme-documentation-basics/ 在本地启动网站 hugo serve –buildDrafts 打开网址 http://localhost:1313/ 可以进行预览 如果发现预览效果不满意，可以 编辑 config.toml(hugo.toml) 文件 五.部署到 Github 构建 Hugo 网站 在 Hugo 网站文件夹的根目录（H:\\HugoWebsite\\blog）下执行 hugo 命令构建 Hugo 会将构建的网站内容默认保存至网站根目录下的 public/ 文件夹下。 将网站文件夹与 GitHub 建立联系**（仅第一次运行需要）** 进入 H:\\HugoWebsite\\blog\\public 目录，初始化 Git 库 生成的 HTML 文件保存在 “public” 目录中，“public” 文件夹会被转换为 Git 库。 git init 将 Git 本地库关联至远程库 在 H:\\HugoWebsite\\blog\\public 目录下，为 Git 本地库添加远程库，“https://github.com/adan-ning/adan-ning.github.io.git” git remote add origin https://github.com/adan-ning/adan-ning.github.io.git 提交修改 在 H:\\HugoWebsite\\blog\\public 目录下，通过如下命令提交： 查看当前修改状态 git status 添加修改过得文件， . 表示所有，也可以指定文件 git add . ““里面的内容就是提交内容的说明信息 git commit -m “first commit” 提交修改至远程库 在 H:\\HugoWebsite\\blog\\public 目录下，通过如下命令提交： git push -u origin master 然后如果按照博客顺序操作，第一次应该失败的。 因为本地的 git 库和远程的库并不是一致的，需要进行一次 pull 操作才能继续 push。 解决办法：先把除 .git 文件夹外的所有文件复制到其他目录备份，然后 git pull 当前库下的文件下来，然后把这些文件和自己需要的文件结合处理好（本次就是删除这些文件，再把原文件复制回来），重新提交即可。日常推荐这种方法，养成好习惯。 1.移动除 .git 外的文件到另一个目录下 2.pull 该库当前文件，最后的参数是因为合并两个不相关的项目（即，不知道彼此存在并且提交历史不匹配的项目）时，会发生Git错误：fatal: refusing to merge unrelated histories，此时出现记录文件，先按住 ctrl+:，再输入 wq 即可。 git pull origin master –allow-unrelated-histories 3.合并这些文件和第一次移动出去的文件，本次就是删除这些文件，把那些文件移动回来就好了 4.提交本地 git add . git commit -m “first commit” 5.提交远程 git push -u origin master 好了，第一次初始化配置也就成功完成了！输入：https://github用户名.github.io/ 就可以访问部署的网站了。 六.其他 新建文章 1.新建一篇文章，在网站根目录：H:\\HugoWebsite\\blog hugo new post/第二篇测试博客.md 2.在目录 H:\\HugoWebsite\\blog\\content\\post 下找到对应文件进行修改 3.本地预览, http://localhost:1313/ hugo server -D 4.构建 Hugo 网站 hugo 5.切换到目录 H:\\HugoWebsite\\blog\\public ，提交修改至本地库 git add . git commit -m ‘commit info’ 6.将修改推至远程库 git push -u origin master 修改文章 1.当前工作目录：H:\\HugoWebsite\\blog 2.在目录 H:\\HugoWebsite\\blog\\content\\post 下找到对应文件 进行修改 3.本地预览, http://localhost:1313/ hugo server -D 4.构建 Hugo 网站 hugo 5.切换到目录 H:\\HugoWebsite\\blog\\public ，提交修改至本地库 git add . git commit -m ‘commit info’ 6.将修改推至远程库 git push -u origin master 删除文章 1.当前工作目录：H:\\HugoWebsite\\blog 2.删除两处文件 在目录H:\\HugoWebsite\\blog\\content\\post ,H:\\HugoWebsite\\blog\\public 下找到对应文件进行删除 其中 public 下文件不删除也不影响显示，只是该文件就会一直存在，另外该目录下即便文件（除.git)删错或者全部删除也是不影响的，应为 hugo 命令会全部重建 3.本地预览, http://localhost:1313/ hugo server -D 4.构建 Hugo 网站 hugo 5.切换到目录 H:\\HugoWebsite\\blog\\public ，提交修改至本地库 git add . git commit -m ‘commit info’ 6.将修改推至远程库 git push -u origin master 添加图片 可参考：【博客写作指南】GitHub+jsDelivr+PicGo搭建博客图床 - 知乎 (zhihu.com) https://zhuanlan.zhihu.com/p/653131492 七.总结 可以将主题下相关文件复制到 blog 网站根目录下，因为这样可以直接渲染网站效果，而又不影响主题本身的内容。 主要是 themes\\LoveIt\\exampleSite 目录下文件 发布文章如果有参数 draft ，记得将值设为 false，或者删除 draft，不然会被认定为草稿只能本地运行而不能运行到网站上。 基本上就是安装 Hugo ，建站，下载主题，配置主题参数，然后部署就是了。 ","date":"2024-03-01","objectID":"/posts/%E6%90%AD%E5%BB%BAhugo%E5%8D%9A%E5%AE%A2buildblog/:1:0","tags":["hugo"],"title":"搭建hugo博客(buildblog)","uri":"/posts/%E6%90%AD%E5%BB%BAhugo%E5%8D%9A%E5%AE%A2buildblog/"},{"categories":["编程技术"],"content":"代码生成器 ","date":"2024-02-29","objectID":"/posts/%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E5%99%A8/:0:0","tags":["java"],"title":"CodeCreate(代码生成器)","uri":"/posts/%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E5%99%A8/"},{"categories":["编程技术"],"content":"前言 我们在编写一些由Springboot框架的系统时，会有很多类似的结构，而代码生成器则会帮我们自动生成这些结构，从而减少我们的代码量，是我们的编程效率得到大幅提高 ","date":"2024-02-29","objectID":"/posts/%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E5%99%A8/:1:0","tags":["java"],"title":"CodeCreate(代码生成器)","uri":"/posts/%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E5%99%A8/"},{"categories":["编程技术"],"content":"代码展示 ```\\java import com.baomidou.mybatisplus.core.exceptions.MybatisPlusException;\rimport com.baomidou.mybatisplus.core.toolkit.StringPool;\rimport com.baomidou.mybatisplus.core.toolkit.StringUtils;\rimport com.baomidou.mybatisplus.generator.AutoGenerator;\rimport com.baomidou.mybatisplus.generator.InjectionConfig;\rimport com.baomidou.mybatisplus.generator.config.*;\rimport com.baomidou.mybatisplus.generator.config.po.TableInfo;\rimport com.baomidou.mybatisplus.generator.config.rules.NamingStrategy;\rimport com.baomidou.mybatisplus.generator.engine.FreemarkerTemplateEngine;\rimport java.util.ArrayList;\rimport java.util.List;\rimport java.util.Scanner;\rpublic class CodeGenerator {\r/**\r*\r* @param tip\r* @return\r* 读取控制台内容\r*/\rpublic static String scanner(String tip){\rScanner scanner = new Scanner(System.in);\rStringBuilder help = new StringBuilder();\rhelp.append(\"请输入\"+tip+\":\");\rSystem.out.println(help.toString());\rif (scanner.hasNext()){\rString ipt = scanner.next();\rif (StringUtils.isNotBlank(ipt)){\rreturn ipt;\r}\r}\rthrow new MybatisPlusException(\"请输入正确的\"+tip+\"!\");\r}\r/**\r* 操作步骤\r* 1.修改数据源包括地址密码信息，对应代码标记：-，下同\r* 2.模块配置，可以修改包名\r* 3.修改模板，（这步可忽略）\r* @param args\r*/\rpublic static void main(String[] args){\r//代码生成器\rAutoGenerator mpg = new AutoGenerator();\r//全局配置\rGlobalConfig gc = new GlobalConfig();\rString projectPath = System.getProperty(\"user.dir\");\rgc.setOutputDir(projectPath+\"/src/main/java\");\rgc.setAuthor(\"lqx\");\rgc.setOpen(false);\rgc.setSwagger2(true);//实体属性 Swagger2注解\rgc.setBaseResultMap(true);//XML ResultMap\rgc.setBaseColumnList(true);//XML ColumnList\r//去掉service接口首字母的I，如D0为UserService\rgc.setServiceName(\"%sService\");\rmpg.setGlobalConfig(gc);\r//数据源配置\rDataSourceConfig dsc = new DataSourceConfig();\r//一，修改数据源\rdsc.setUrl(\"jdbc:mysql://localhost:3306/db?serverTimezone=UTC\");\rdsc.setDriverName(\"com.mysql.cj.jdbc.Driver\");\rdsc.setUsername(\"root\");\rdsc.setPassword(\"1234\");\rmpg.setDataSource(dsc);\r//包配置\rPackageConfig pc = new PackageConfig();\r//二，模块配置\rpc.setParent(\"com.lqx\")\r.setEntity(\"entity\")\r.setMapper(\"mapper\")\r.setService(\"service\")\r.setServiceImpl(\"service.impl\")\r.setController(\"controller\");\rmpg.setPackageInfo(pc);\r//自定义配置\rInjectionConfig cfg = new InjectionConfig() {\r@Override\rpublic void initMap() {\r// to do nothing\r}\r};\r// 如果模板引擎是 freemarker\rString templatePath = \"/templates/mapper.xml.ftl\";\r// 如果模板引擎是 velocity\r// String templatePath = \"/templates/mapper.xml.vm\";\r// 自定义输出配置\rList\u003cFileOutConfig\u003e focList = new ArrayList\u003c\u003e();\r// 自定义配置会被优先输出\rfocList.add(new FileOutConfig(templatePath) {\r@Override\rpublic String outputFile(TableInfo tableInfo) {\r// 自定义输出文件名 ， 如果你 Entity 设置了前后缀、此处注意 xml 的名称会跟着发生变化！！\rreturn projectPath + \"/src/main/resources/mapper/\" + pc.getModuleName()\r+ \"/\" + tableInfo.getEntityName() + \"Mapper\" + StringPool.DOT_XML;\r}\r});\r/*\rcfg.setFileCreate(new IFileCreate() {\r@Override\rpublic boolean isCreate(ConfigBuilder configBuilder, FileType fileType, String filePath) {\r// 判断自定义文件夹是否需要创建\rcheckDir(\"调用默认方法创建的目录，自定义目录用\");\rif (fileType == FileType.MAPPER) {\r// 已经生成 mapper 文件判断存在，不想重新生成返回 false\rreturn !new File(filePath).exists();\r}\r// 允许生成模板文件\rreturn true;\r}\r});\r*/\rcfg.setFileOutConfigList(focList);\rmpg.setCfg(cfg);\r// 配置模板\rTemplateConfig templateConfig = new TemplateConfig();\r// 配置自定义输出模板\r//指定自定义模板路径，注意不要带上.ftl/.vm, 会根据使用的模板引擎自动识别\r//三，修改模板\r// templateConfig.setEntity(\"templates/entity2.java\");\r// templateConfig.setService();\r// templateConfig.setController();\rtemplateConfig.setXml(null);\rmpg.setTemplate(templateConfig);\r// 策略配置\rStrategyConfig strategy = new StrategyConfig();\rstrategy.setNaming(NamingStrategy.underline_to_camel);\rstrategy.setColumnNaming(NamingStrategy.underline_to_camel);\r// strategy.setSuperEntityClass(\"你自己的父类实体,没有就不用设置!\");\rstrategy.setEntityLombokModel(true);\rstrategy.setRestControllerStyle(true);\r// 公共父类\r// strategy.setSuperControllerClass(\"你自己的父类控制器,没有就不用设置!\");\r// 写于父类中的公共字段\r// strategy.setSuperEntityColumns(\"id\");\rstrategy.setInclude(scanner(\"表名，多个英文逗号分割\").split(\",\"));\rstrategy.setControllerMappingHyphenStyle(true);\r// st","date":"2024-02-29","objectID":"/posts/%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E5%99%A8/:2:0","tags":["java"],"title":"CodeCreate(代码生成器)","uri":"/posts/%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E5%99%A8/"},{"categories":["编程技术"],"content":"运行效果 ","date":"2024-02-29","objectID":"/posts/%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E5%99%A8/:3:0","tags":["java"],"title":"CodeCreate(代码生成器)","uri":"/posts/%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E5%99%A8/"},{"categories":["编程技术"],"content":"运行操作 ","date":"2024-02-29","objectID":"/posts/%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E5%99%A8/:3:1","tags":["java"],"title":"CodeCreate(代码生成器)","uri":"/posts/%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E5%99%A8/"},{"categories":["编程技术"],"content":"运行结果 ","date":"2024-02-29","objectID":"/posts/%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E5%99%A8/:3:2","tags":["java"],"title":"CodeCreate(代码生成器)","uri":"/posts/%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E5%99%A8/"},{"categories":["hugo"],"content":"每次更新hugo博客的操作 ","date":"2024-02-18","objectID":"/posts/%E6%AF%8F%E6%AC%A1%E6%9B%B4%E6%96%B0hugo%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%93%8D%E4%BD%9C/:0:0","tags":["hugo"],"title":"每次更新hugo博客的操作","uri":"/posts/%E6%AF%8F%E6%AC%A1%E6%9B%B4%E6%96%B0hugo%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%93%8D%E4%BD%9C/"},{"categories":["hugo"],"content":"每次更新hugo博客所需的操作 打开 PowerShell / cmd 终端，打开最初用 hugo 搭建的博客所在的文件夹，以我为例： cd e:\\myblog ","date":"2024-02-18","objectID":"/posts/%E6%AF%8F%E6%AC%A1%E6%9B%B4%E6%96%B0hugo%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%93%8D%E4%BD%9C/:1:0","tags":["hugo"],"title":"每次更新hugo博客的操作","uri":"/posts/%E6%AF%8F%E6%AC%A1%E6%9B%B4%E6%96%B0hugo%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%93%8D%E4%BD%9C/"},{"categories":["hugo"],"content":"第一步 新建一个 markdown(.md) 格式的文件(如果要修改原来的文件可不需要新建) hugo new post/FileName.md 其中 FileName 为自定义的文件名 ","date":"2024-02-18","objectID":"/posts/%E6%AF%8F%E6%AC%A1%E6%9B%B4%E6%96%B0hugo%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%93%8D%E4%BD%9C/:1:1","tags":["hugo"],"title":"每次更新hugo博客的操作","uri":"/posts/%E6%AF%8F%E6%AC%A1%E6%9B%B4%E6%96%B0hugo%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%93%8D%E4%BD%9C/"},{"categories":["hugo"],"content":"第二步 输入命令： hugo —theme=hugo-tranquilpeak-theme —baseUrl=\"https://tzq0301.github.io\" —buildDrafts 其中，hugo-tranquilpeak-theme 是我所应用的主题，https://tzq0301.github.io 是我的GitHub中为hugo博客配置的仓库 ","date":"2024-02-18","objectID":"/posts/%E6%AF%8F%E6%AC%A1%E6%9B%B4%E6%96%B0hugo%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%93%8D%E4%BD%9C/:1:2","tags":["hugo"],"title":"每次更新hugo博客的操作","uri":"/posts/%E6%AF%8F%E6%AC%A1%E6%9B%B4%E6%96%B0hugo%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%93%8D%E4%BD%9C/"},{"categories":["hugo"],"content":"第三步 把博客部署到远程GitHub仓库 首先切换到 public 文件夹： cd public 此时，正处于 e:\\myblog\\public 中 接下来输入以下指令： git add . git commit -m “yyyy/mm/dd-hh:mm” git push -u origin master 其中 yyyy/mm/dd-hh:mm 为每次提交的名称，引号内可以随意更改，yyyy/mm/dd-hh:mm 是我个人采用的格式，以时间做标记可保证不会重复 最后现在刷新GitHub，登陆个人博客查看即可 ","date":"2024-02-18","objectID":"/posts/%E6%AF%8F%E6%AC%A1%E6%9B%B4%E6%96%B0hugo%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%93%8D%E4%BD%9C/:1:3","tags":["hugo"],"title":"每次更新hugo博客的操作","uri":"/posts/%E6%AF%8F%E6%AC%A1%E6%9B%B4%E6%96%B0hugo%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%93%8D%E4%BD%9C/"}]