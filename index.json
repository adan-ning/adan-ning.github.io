[{"categories":["面向对象程序设计"],"content":"函数 ","date":"2024-03-21","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A13/:0:0","tags":["面向对象程序设计"],"title":"c++(three)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A13/"},{"categories":["面向对象程序设计"],"content":"函数的定义与使用 所有的高级语言都有子程序的概念，实现模块的划分 C和C++中的子程序体现为函数 一个C++程序由一个主函数和若干其他函数构成 函数分为：标准库函数和用户自定义函数 ","date":"2024-03-21","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A13/:1:0","tags":["面向对象程序设计"],"title":"c++(three)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A13/"},{"categories":["面向对象程序设计"],"content":"函数的定义 函数是面向对象设计中的基本抽象单元，是对功能的抽象 函数声明的语法形式 函数的定义(函数的类型和返回值) 形式参数表 函数的返回值 ​ C++语言把函数返回值的数据类型规定为该函数的数据类型。因此，函数返回值的类型一定要与函数的类型相同 由return语句给出，例如： return 0 无返回值的函数(void类型)，不必写return语句 函数的定义(说明) 所有函数都是平行的，即在定义函数时是相互独立的，C++和C不允许函数嵌套定义，即在函数体中在定义一个函数是非法的(与PASCAL不同) C++程序的执行从main函数开始，调用其他函数后回到main函数，在main函数中结束整个程序的运行。main函数是系统定义的 例： int main(){ float add(float x,float y); //函数声明 float a,b,c; cin\u003e\u003ea\u003e\u003eb; c=add(a,b); cout\u003c\u003cc\u003c\u003cendl; } float add(float x,float y){ //函数首部 float z; //函数体 z=x+y; return z; } //float add(float x,float y){}为函数定义 float add(float x,float y){ //函数首部 int z; //float改为int //函数体 z=x+y; return z; //出错 } 函数定义的一般形式 获取参数并返回值 int bigger(int a,int b){ return(a\u003eb)?a:b; } 获取参数但不返回值 void delay(long a){ for(int i=1;i\u003c=a;i++); } 没有获取参数但返回值 int geti(void){ //键盘获取一个整数 int x; cout\u003c\u003c\"please input a integer:\\n\"; cin\u003e\u003ex; return x; } 没有获取参数也不返回值 void message(void) //在屏幕上显示一个消息 { cout\u003c\u003c\"This is a message.\\n\"; } ","date":"2024-03-21","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A13/:1:1","tags":["面向对象程序设计"],"title":"c++(three)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A13/"},{"categories":["面向对象程序设计"],"content":"函数的调用 调用形式 函数名(实参列表) 调用的方式 函数语句： func(); //此时函数可以无返回值 函数表达式 if((x=func())==somevalue) //函数做参数 // func()必须有一个明确的返回值 函数参数 m=max(a,max(b,c)); 函数声明和函数原型 一个函数调用另一个函数(被调函数)的条件： 点用函数之前必须首先对被调函数进行声明 函数声明(declaration) 是一条程序语句，包含函数名，返回类型和形式参数列表 作用是把函数的名字、返回类型以及形参的类型、个数和顺序通知编译系统，以便在调用该函数时按此进行对照检查(例如函数名是否正确、实参和形参的类型和个数是否一致) 函数声明和函数原型(说明) 函数声明的形式： 1.类型标识符 函数名(参数类型1，参数类型2，... ...); 2.类型标识符 函数名(参数类型1 参数名1，参数类型2 参数名2，... ...); 函数声明的说明 第1种是基本形式，只包含参数的类型 为了阅读，也允许加上参数名 以下三种声明形式等价 float add(float,float); float add(float a,float b); float add(float x,float y); 函数原型(function prototype) 在C++和C中，函数声明就是函数原型 函数声明和函数定义的区别 “定义”指对函数功能的确定，包括指定函数名，返回类型，形参及其类型，函数体，它是一个完整，独立的函数单位 “声明”只是把函数的原型通知编译系统 注意：声明函数时，函数原型预定义函数时函数首部在写法上必须一致，既函数名，返回类型，参数个数，参数类型和参数顺序必须相同，否则产生编译错误。 函数原型的作用 在编译阶段对函数调用的合法性进行全面检查 main(){ //编译从上到下逐条进行 float add(float x,float y); //如果没有函数声明，当编译“c=add(a,b)”时，编译系统不知道add是不是函数名，也无法判断实参的类型和个数是否正确，无法进行正确性检查。有可能导致运行时则错误 //在函数调用之前声明了函数原型，编译系统就会根据函数原型对函数调用的合法性进行全面检查，和函数原型不匹配的函数调用就会导致编译出错 c=add(a,b); ... } float add(float x,float y){ ... } 函数声明的位置 char letter(char,char); float f(float,float); int i(int,int); //如果在所有函数定义之前，在函数的外部已做了函数声明，那么函数原型在本文件中任何地方有效，即在本文件中任何地方都可以按照函数原型调用相应的函数 main() {...} char letter(char c1,char c2) {...} float f(float x,float y) {...} int i(int x,int y) {...} 函数在被调用之前必须声明或定义，如同变量使用之前必须先定义 ","date":"2024-03-21","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A13/:1:2","tags":["面向对象程序设计"],"title":"c++(three)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A13/"},{"categories":["面向对象程序设计"],"content":"函数调用的执行过程 函数调用的图例 嵌套调用 ","date":"2024-03-21","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A13/:1:3","tags":["面向对象程序设计"],"title":"c++(three)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A13/"},{"categories":["面向对象程序设计"],"content":"函数调用的内部机制 函数调用的过程就是栈空间的操作过程 建立被调函数的栈空间 保护主调函数的运行状态和返回地址 传递参数 将控制转变为被调函数 栈 是一种数据结构 是后进先出(Last In First Out)的线性表 ","date":"2024-03-21","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A13/:1:4","tags":["面向对象程序设计"],"title":"c++(three)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A13/"},{"categories":["面向对象程序设计"],"content":"栈 只允许在一端插入和删除的顺序表，插入和删除的一端称为栈顶，另一端称为栈底 特点：后进先出 ","date":"2024-03-21","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A13/:2:0","tags":["面向对象程序设计"],"title":"c++(three)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A13/"},{"categories":["面向对象程序设计"],"content":"函数调用时栈的建立过程 ","date":"2024-03-21","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A13/:2:1","tags":["面向对象程序设计"],"title":"c++(three)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A13/"},{"categories":["面向对象程序设计"],"content":"函数调用的返回 ","date":"2024-03-21","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A13/:2:2","tags":["面向对象程序设计"],"title":"c++(three)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A13/"},{"categories":["面向对象程序设计"],"content":"递归调用 再调用一个子程序或函数的过程之中出现直接或间接调用该子程序或函数本身，称为过程的递归调用 递归调用的形式 直接递归 void fun1(void){ ... fun1(); ... } Long fib(int x){ if(x\u003e2) return(fib(x-1)+fib(x-1)); //直接递归 else return 1; } 间接递归 例: int fn1(int a){ int b; b=fn2(a+1); //间接递归 //... } int fn2(int s){ int c; c=fn1(s-1); //间接递归 //... } 递归过程的两个阶段 递推 回归 例：求n! 分析：计算n!的公式如下 $n!= \\begin{cases}1,(n=0)\\n(n-1)!,(n\u003e0)\\end{cases}$ 这是一个递归实现的公式，应该用递归函数实现 long Factorial(long n){ if(n==0) return 1; else return n*Factorial(n-1); } 求解阶乘n!的过程 ","date":"2024-03-21","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A13/:2:3","tags":["面向对象程序设计"],"title":"c++(three)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A13/"},{"categories":["面向对象程序设计"],"content":"三点认识 对于一个较为复杂的问题，如果能够分解成几个相对简单的且解法相同或类似的子问题时，只要解决了这些子问题，那么原问题就迎刃而解了，这就是递归求解。 例：4！=4*3！ 递归结束条件 当分解后的子问题可以直接解决时，就停止分解。可以直接求解的问题叫做递归结束条件 如：0！=1 定义的结构 递归定义的函数可以简单地用递归过程来编程求解。递归直接反映了定义的结构 ","date":"2024-03-21","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A13/:2:4","tags":["面向对象程序设计"],"title":"c++(three)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A13/"},{"categories":["面向对象程序设计"],"content":"递归的条件 须有完成函数任务的语句 #include\u003ciostream\u003e void count(int val) //递归函数可以没有返回值 { if(val\u003e1) count(val-1); cout\u003c\u003c\"ok:\"\u003c\u003cval\u003c\u003cendl; //此语句完成函数任务 } 一个确定是否能避免递归调用的测试 例：上例代码中，语句“if(val\u003e1)”便是一个测试 一个递归调用语句 例：上例代码中，“count(val-1);” 先测试，后递归调用 例： #include\u003ciostream\u003e void count(int val) { count(val-1); //无限递归下去 if(val\u003e1) //该语句无法达到 cout\u003c\u003c\"ok:\"\u003c\u003cval\u003c\u003cendl; } ","date":"2024-03-21","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A13/:2:5","tags":["面向对象程序设计"],"title":"c++(three)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A13/"},{"categories":["面向对象程序设计"],"content":"自学(汉诺塔问题) 有三根针A、B、C。A针上有N个盘子，大的在下，小的在上，要求把这N个盘子从A针移到C针，在移动过程中可以借助B针，每次只允许移动一个盘，且在移动过程中在三根针上都保持大盘在下，小盘在上。 分析：将n个盘子从A移到C针可以分解为下面三个步骤 将A上n-1个盘子移到B针上(借助C针) 把A针上剩下的一个盘子移到C针上 将n-1个盘子从B针移到C针上(借助A针) 事实上，上面是三个步骤包含两种操作： 将多个盘子从一个针移到另一个针上，这是一个递归的过程。hanoi函数实现 将1个盘子从一个针上移到另一个针上用move函数实现 如图： 代码实现： #include\u003ciostream\u003e #include\u003cstrcalss\u003e void Hanoi(int n,string A,string B,string C) //解决汉诺塔问题的算法 { if(n==1) cout\u003c\u003cA\u003c\u003c\"to\"\u003c\u003cC\u003c\u003cendl; else{ Hanoi(n-1,A,C,B); cout\u003c\u003c\"move\"\u003c\u003cA\u003c\u003c\"to\"\u003c\u003cC\u003c\u003cendl; Hanoi(n-1,B,A,C); } } 过程： ","date":"2024-03-21","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A13/:3:0","tags":["面向对象程序设计"],"title":"c++(three)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A13/"},{"categories":["面向对象程序设计"],"content":"函数的参数传递机制(传递参数值) 函数定义中指定的形参，在函数未被调用时，并不占有存储单元，在函数被调用时才在栈中为形参分配存储单元，并将实参与形参结合 实参可以是常量，变量，表达式 实参类型必须与形参相同 传递时是传递参数值(Call by value)，即单向传递，将实参的值传递给形参，形参值的改变对实参不起作用 举例： #include\u003ciostream\u003e void Swap(int a,int b); int main() { int x(5),y(10); cout\u003c\u003c\"x=\"\u003c\u003cx\u003c\u003c\"y=\"\u003c\u003cy\u003c\u003cendl; Swap(x,y); cout\u003c\u003c\"x=\"\u003c\u003cx\u003c\u003c\"y=\"\u003c\u003cy\u003c\u003cendl; return 0; } void Swap(int a,int b) { int t; t=a; a=b; b=t; } ","date":"2024-03-21","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A13/:3:1","tags":["面向对象程序设计"],"title":"c++(three)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A13/"},{"categories":["面向对象程序设计"],"content":"引用 概念 引用是一个变量或对象的别名 通过引用名与通过被引用的变量名访问变量的效果一样 声明一个引用时，必须同时对它进行初始化，使它指向一个已存在的对象 一旦一个引用被初始化后，就不能改为指向其它对象 一个引用，从它诞生之时起，就必须确定是那个变量的别名，而且始终只能作为这一变量的别名，不能另作他用 引用的建立 建立引用时，先写上目标类型，后跟引用运算符”\u0026“，然后是引用的名字。引用能使用任何合法的变量名 例：引用一个整型变量 int someInt; int\u0026 rInt = someInt; 程序的建立和使用引用 例： #include\u003ciostream\u003e void main(){ int intOne; int\u0026 rInt=intOne; intOne=5; cout\u003c\u003c\"intOne:\"\u003c\u003cintOne\u003c\u003cendl; cout\u003c\u003c\"rInt:\"\u003c\u003crInt\u003c\u003cendl; rInt=7; cout\u003c\u003c\"intOne:\"\u003c\u003cintOne\u003c\u003cendl; cout\u003c\u003c\"rInt:\"\u003c\u003crInt\u003c\u003cendl; } //运行结果 //intOne:5 //rInt:5 //intOne:7 //rInt:7 ","date":"2024-03-21","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A13/:4:0","tags":["面向对象程序设计"],"title":"c++(three)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A13/"},{"categories":["面向对象程序设计"],"content":"函数的参数传递(用引用做形参) 引用运算符只在声明的时候使用，它放在类型名后面 int\u0026 rInt=intOne; 任何其它”\u0026“的使用都是地址操作符： 例： int *ip=\u0026intOne; cout\u003c\u003c\u0026ip; 为了提高可读性，不应在同一行上同时声明引用，指针和变量 int \u0026rInt,sa; 与指针类似，下面三种声明引用的方法都是合法的。 int \u0026rInt; 引用可以作为形参 void swap(int \u0026a,int \u0026b) { ... } 引用作为形参时，用实参来初始化形参。引用类型的形参就通过形式结合，成为实参的别名，对形参的任何操作就会作用于实参。 例：输入两个整数交换后输出 #include\u003ciostream\u003e void Swap(int\u0026 a, int\u0026 b); int main（ ） { int x(5), y(10); cout\u003c\u003c\"x=\"\u003c\u003cx\u003c\u003c\" y=\"\u003c\u003cy\u003c\u003cendl; Swap(x,y); cout\u003c\u003c\"x=\"\u003c\u003cx\u003c\u003c\" y=\"\u003c\u003cy\u003c\u003cendl; return 0; } void Swap(int\u0026 a, int\u0026 b) { int t; t=a; a=b; b=t; } //运行结果 //x=5,y=10 //x=1-,y=5 注意： 引用不能绑定常量 引用一旦初始化，其值就不能修改 数组不能定义引用 ","date":"2024-03-21","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A13/:4:1","tags":["面向对象程序设计"],"title":"c++(three)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A13/"},{"categories":["面向对象程序设计"],"content":"小结 值调用和引用调用的比较 值调用是在发生函数调用时，给形参分配存储单元，并用实参来初始化形参（将实参的值直接传递给形参）。这一过程是参数值的单向传递过程，一旦形参获得了值，便与实参脱离关系。以后无论形参怎样改变，都不会影响到实参。 引用调用将引用作为形参，在发生函数调用时，实参初始化形参，形参就成为实参的一个别名，对形参的任何操作就直接作用于实参。 ","date":"2024-03-21","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A13/:4:2","tags":["面向对象程序设计"],"title":"c++(three)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A13/"},{"categories":["面向对象程序设计"],"content":"内联函数 为何使用内联函数(内嵌函数) 函数调用需要建立栈内存环境，进行参数传递，并产生程序执行转移，需要时间和空间的开销。如果有的函数被频繁调用，则耗时很长，降低执行效率 将规模较小又使用频繁的函数定义为内联函数，在编译时就会将函数体的代码嵌入到主调函数内的每一个调用语句处，节省了参数传递，控制转移等开销 例： #include\u003ciostream\u003e using namespace std; int isnumber(char); //函数声明 int main(){ char c; while((c=cin.get())!='\\n') //读入一个字符给变量并于’\\n‘作比较 { if(isnumber(c)) //调用一个小函数 cout\u003c\u003c\"You entered a digit \\n\"; else cout\u003c\u003c\"You entered a non-digit \\n\"; } } int isnumber(char ch) //函数定义 { return(ch\u003e='0'\u0026\u0026ch\u003c='9')?1:0; } 为了提高效率，可将程序改为： #include\u003ciostream\u003e void main(){ char c; while((c=cin.get())!='\\n'){ if((ch\u003e='0'\u0026\u0026ch\u003c='9')?1:0) cout\u003c\u003c\"You entered a digit \\n\"; else cout\u003c\u003c\"You entered a non-digit \\n\"; } } 解决办法 将isnumber()函数声明为inline inline int isnumber(char); inline int isnumber(char c){ return(ch\u003e='0'\u0026\u0026ch\u003c='9')?1:0; } 声明和定义时使用关键字inline inline 类型说明符 被调函数名 (含类型说明的形参表) 例： #include\u003ciostream\u003e inline int isnumber(char); //inline函数声明 void main() { char c; while((c=cin.getc())!='\\n') { if(isnumber(c)) //调用一个小函数 cout\u003c\u003c\"You entered a digit \\n\"; else cout\u003c\u003c\"You entered a non-digit \\n\"; } } int isnumber(char ch) //此处无inlinr,视为inline { return(ch\u003e='0'\u0026\u0026ch\u003c='9')?1:0; } 先声明后调用 内联函数的声明必须出现在内联函数第一次被调用之前 例：下面的代码不会像预计的那样被编译 #include\u003ciostream\u003e int isnumber(char); //此处无inline void main() { char c; while((c=cin.getc())!='\\n') { if(isnumber(c)) //调用一个小函数 cout\u003c\u003c\"You entered a digit \\n\"; else cout\u003c\u003c\"You entered a non-digit \\n\"; } } int isnumber(char ch) //此处为inline { return(ch\u003e='0'\u0026\u0026ch\u003c='9')?1:0; } ","date":"2024-03-21","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A13/:5:0","tags":["面向对象程序设计"],"title":"c++(three)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A13/"},{"categories":["面向对象程序设计"],"content":"内联函数声明与使用 内联函数的函数体限制 内联函数体内不能有循环语句和switch语句 递归函数(自己调用自己的函数)是不能被用来做内联函数的 内联函数体只适合只有1~5行的小函数 对内联函数不能进行异常接口声明 使用内按函数可以节省运行时间，但却增加了目标程序的长度 举例： #include\u003ciostream\u003e inline int max(int a,int b,intc){ if(b\u003ea) a=b; if(c\u003ea) a=c; return a; } void main(){ int i=7,j=10,k=25,m; m=max(i,j,k); //编译系统遇见函数调用max(i,j,k)时，就用max函数体的代码代替max(i,j,k),同时将实参代替形参。这样，max(i,j,k)就被置换成： // if ( j\u003ei ) i = j ; // if ( k\u003ei ) i = k; // m=i; cout\u003c\u003cm\u003c\u003cendl; } ","date":"2024-03-21","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A13/:5:1","tags":["面向对象程序设计"],"title":"c++(three)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A13/"},{"categories":["面向对象程序设计"],"content":"带默认形参值的函数(默认形参值的作用) 默认形参值 一般情况下，实参个数应该与形参个数相同。C++允许实参和形参个数不同，办法是在形参列表中对形参指定默认值。 调用时如给出实参，则用实参初始化形参，否则采用预先给出的默认形参值。 c++可以给函数定义默认参数值。 通常要为函数的每个参数给定对应的实参 例： void delay(int loops); //函数声明 void delay(int loops) //函数定义 { if(loops==0) return; for(int i=0;i\u003cloops;i++); } 有时需要用相同的实参反复调用delay()函数。c++可以给参数定义默认值。 例： void delay(int loops=1000); 默认形参值得说明次序 默认形参值必须按从右向左顺序声明，并且在默认形参值的右面不能有非缺省形参值的参数。因为调用时实参初始化形参是从左向右的顺序。 例： int add(int x,int y=5,int z=6); //正确 int add(int x=1,int y=5,int z); //错误 int add(int x=1,int y,int z=6); //错误 缺省形参值与函数的调用位置 默认形参值在函数声明中提供，当既有声明又有定义时，定义中不允许默认参数。如果函数只有定义，则默认形参值才可以在函数定义中提供。 缺省形参值得作用域 在相同的作用域内，缺省形参值的说明应保持唯一，但如果在不同的作用域内，允许说明不同的缺省形参。 注： 在相同的作用域内，即使前后定义的值相同也不行； 如果一个函数在定义之前又有原型声明，默认形参值需要在原型中给出，定义中不能再出现默认形参值。 例： int add(int x=1,int y=2); void main(void) { int add(int x=3,int y=4); add(); //使用局部缺省形参值（实现3+4） } void fun(void){ ... add(); //使用全局缺省形参值(实现1+2) } ","date":"2024-03-21","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A13/:6:0","tags":["面向对象程序设计"],"title":"c++(three)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A13/"},{"categories":["面向对象程序设计"],"content":"函数重载 如果没有重载机制，即使是完全相同的操作，但是针对不同的数据类型，就需要定义名称完全不同的函数。 例如定义加法函数，必须对整数加法和浮点数加法使用不同的函数名： int iadd(int x,int y) { int z; z=x+y; return z; } int fadd(float x,float y) { float z; z=x+y; return z; } C++允许功能相近的函数在相同的作用域内以相同函数名定义, 从而形成重载。方便使用,便于记忆。 若干函数,名称相同,但形参个数或类型不同,编译器根据实参和形参的类型及个数的最佳匹配，自动确定调用那一个函数,这就是函数重载。 例： //形参类型不同 int add(int x,int y); float add(float x,float y); //形参个数不同 int add(int x,int y); int add(int x,int y,int z); 注意事项 重载函数的形参必须不同: 个数不同或类型不同。 编译程序将根据实参和形参的类型及个数的最佳匹配来自动选择调用哪一个函数 不要将不同功能的函数声明为重载函数，以免出现调用结果的误解、混淆。这样不好： 例：编写三个名为add的重载函数，分别实现两整数相加，两实数相加和两个复数相加的功能 #include\u003ciostream.h\u003e struct complex { double real; double imaginary; }; void main(void) { int m, n; double x, y; complex c1, c2, c3; int add(int m, int n); double add(double x, double y); complex add(complex c1, complex c2); cout\u003c\u003c\"Enter two integer: \"; cin\u003e\u003em\u003e\u003en; cout\u003c\u003c\"integer\"\u003c\u003cm\u003c\u003c'+'\u003c\u003cn\u003c\u003c\"=“\u000b\u003c\u003cadd(m,n)\u003c\u003cendl; cout\u003c\u003c\"Enter two real number: \"; cin\u003e\u003ex\u003e\u003ey; cout\u003c\u003c\"real number \"\u003c\u003cx\u003c\u003c'+'\u003c\u003cy\u003c\u003c\u000b\"= \"\u003c\u003cadd(x,y) \u003c\u003cendl; cout\u003c\u003c\"Enter the first complex number: \"; cin\u003e\u003ec1.real\u003e\u003ec1.imaginary; cout\u003c\u003c\"Enter the second complex number: \"; cin\u003e\u003ec2.real\u003e\u003ec2.imaginary; c3=add(c1,c2); cout\u003c\u003c\"complex number (\" \u003c\u003cc1.real\u003c\u003c ',' \u003c\u003c c1.imaginary \u003c\u003c\")+(\"\u003c\u003cc2.real\u003c\u003c',' \u003c\u003cc2.imaginary\u003c\u003c\")=(\"\u003c\u003cc3.real\u003c\u003c',' \u003c\u003cc3.imaginary\u003c\u003c\")\\n\"; } int add(int m, int n) { return m+n; } double add(double x, double y) { return x+y; } complex add(complex c1, complex c2) { complex c; c.real=c1.real+c2.real; c.imaginary=c1.imaginary+c2.imaginary; return c; } //运行结果 //Enter two integer: 3 5 //integer 3+5=8 //Enter two real number: 2.3 5.8 //real number 2.3+5.8= 8.1 //Enter the first complex number: 12.3 45.6 //Enter the second complex number: 56.7 67.8 //complex number (12.3,45.6)+(56.7,67.8)=(69,113.4) 重载函数需要注意以下五个问题 函数的返回类型不能成为判断依据 如果在两个函数的参数列表中只有缺省实参不同，那么它们也不会被看作是重载函数。 采用typedef定义的类型也不能作为判断依据。 采用const来修饰按值传递的参数也意味着不改变实参的数值，所以不能被看作是重载函数 重载函数中所有的函数定义都必须在同一个域中，不同类域中的函数也不能构成重载函数 重载函数的选择 重载函数被调用时，系统会根据指定的实参在多个同名的函数中选择一个最合适的函数，通常分为三个步骤： 在重载函数集合中找出可行函数，可行函数的参数个数要和调用时的实参的个数相同，或者多一些缺省的参数，可行函数的参数类型要和调用时实参的类型相同，或者可以转换。 在可行函数中，寻找精确匹配的函数，精确匹配是指实参和形类的类型和个数完全相同，也指从数组到指针的类型转换，从函数到指针的类型转换。 依据数据类型转换规则，找到可匹配函数。类型转换被分成三个等级：提升转换、标准转换和自定义转换。 如果通过上述三步仍然无法找到任何可匹配函数，那么该函数的调用就是二义的。 ","date":"2024-03-21","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A13/:7:0","tags":["面向对象程序设计"],"title":"c++(three)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A13/"},{"categories":["面向对象程序设计"],"content":"函数模板 ","date":"2024-03-21","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A13/:8:0","tags":["面向对象程序设计"],"title":"c++(three)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A13/"},{"categories":["面向对象程序设计"],"content":"代码重用 按不同方式重复使用已有的代码 代码必须通用，不受数据类型的限制，这是参数化程序设计 模板有可以使用和操作任何数据类型的通用代码构成，其中将所使用的数据类型说明为参数 函数模板可以用来创建一个通用功能的函数，以支持多种不同形参，进一步简化重载函数的函数体设计。 ","date":"2024-03-21","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A13/:8:1","tags":["面向对象程序设计"],"title":"c++(three)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A13/"},{"categories":["面向对象程序设计"],"content":"函数模板的定义形式 template\u003c类型形式参数表\u003e 类型名 函数名(形式参数表) { //函数体 } 如果形式参数包含基本数据类型，加前缀typename template \u003ctypename T\u003eT func(T x) 如果形式参数表包含类类型名，加前缀class template T func(T x) template \u003cclass T\u003e 或 template \u003ctypename T\u003e 类型名 函数名(形式参数表) { 函数体 } 例：求绝对值函数的模板 #include\u003ciostream.h\u003e template\u003ctypename T\u003e T abs (T x) { return x\u003c0?-x:x; } void main（ ） { int n=-5; double d=-5.5; cout\u003c\u003cabs(n)\u003c\u003cendl; cout\u003c\u003cabs(d)\u003c\u003cendl; } 当类型参数的含义确定后，编译器将以函数模板为样板，生成一个函数： int abs (int x) { return x\u003c0?-x:x; } 对于调用表达式abs(d)，由于实参d为double类型，所以推导出模板中类型参数T为double。接着，编译器将以函数模板为样板 double abs (double x) { return x\u003c0?-x:x; } ","date":"2024-03-21","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A13/:8:2","tags":["面向对象程序设计"],"title":"c++(three)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A13/"},{"categories":["面向对象程序设计"],"content":"函数模板的说明 函数模板 函数模板的定义不是一个实实在在的函数，编译系统不为其产生任何执行代码。该定义只是对函数的描述，表示它每次能处理在类型形式参数表中说明的数据类型 当编译系统发现一个函数调用：func(实参表)，将根据实参表中的类型，确认是否匹配函数模板中对应的形式参数表，然后生成一个函数。该函数的函数体与函数模板中的函数体相同，而形式参数表的类型则以实参表的实际类型为依据。该函数称为模板函数。 函数模板与模板函数的区别 函数模板是模板的定义，定义中用到通用类型参数； 模板函数是实实在在的函数定义,由编译系统遇见具体的函数调用时生成,具有执行代码。 对上例的说明 编译器从调用abs（ ）时实参的类型，推导出函数模板的类型参数。例如,对于调用表达式abs(n),由于实参n为int类型,所以推导出模板中类型参数T为int。 当编译器发现调用函数模板时，就创建一个模板函数。在上例中，当编译器发现abs(n)调用用时，产生一个如下的函数定义，生成其程序代码： int abs(int x){ return x\u003c0?-x:x; } 当发现abs(d)调用时，产生如下的函数定义，也生成其程序代码： double abs(double x){ return x\u003c0?-x:x; } ","date":"2024-03-21","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A13/:8:3","tags":["面向对象程序设计"],"title":"c++(three)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A13/"},{"categories":["面向对象程序设计"],"content":"函数模板实例化 隐式实例化 #include \u003ciostream\u003e using namespace std; //定义函数模板 template\u003ctypename T\u003e T add(T t1, T t2) { return t1 + t2; } int main() { cout \u003c\u003c add(1, 2) \u003c\u003c endl; //传入int类型参数 cout \u003c\u003c add(1.2, 3.4) \u003c\u003c endl; //传入double类型参数 system(\"pause\"); return 0; } 显式实例化 #include \u003ciostream\u003e using namespace std; template\u003ctypename T\u003e T add(T t1, T t2) { return t1 + t2; } template int add\u003cint\u003e(int t1, int t2); //显式实例化为int类型 int main() { cout \u003c\u003c add\u003cint\u003e(10, 'B') \u003c\u003c endl; //函数模板调用 cout \u003c\u003c add(1.2, 3.4) \u003c\u003c endl; system(\"pause\"); return 0; } ","date":"2024-03-21","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A13/:8:4","tags":["面向对象程序设计"],"title":"c++(three)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A13/"},{"categories":["面向对象程序设计"],"content":"使用函数模板注意事项 函数模板中每一个类型参数在函数参数表中必须至少使用一次 在全局域中声明的模板参数同名对象、函数或类型、在函数模板中将被隐藏。 函数模板中定义声明的对象或类型不能与模板参数同名 模板参数名在同一模板参数表中只能使用一次，但可以在多个函数模板声明或定义之间重复使用。 ","date":"2024-03-21","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A13/:8:5","tags":["面向对象程序设计"],"title":"c++(three)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A13/"},{"categories":["面向对象程序设计"],"content":"使用C++系统函数 模板参数名在同一模板参数表中只能使用一次，但可以在多个函数模板声明或定义之间重复使用。 例如： 求平方根函数(sqrt)，求绝对值函数(abs)等 使用系统函数是要包含相应的头文件 使用函数之前必须先声明函数原型。系统函数的原型存在于不同的头文件中。用#include指令嵌入相应的头文件，就可以使用系统函数。 例如： #include\u003cmath\u003e ","date":"2024-03-21","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A13/:9:0","tags":["面向对象程序设计"],"title":"c++(three)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A13/"},{"categories":["编译原理"],"content":"词法分析 ","date":"2024-03-19","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%863/:0:0","tags":["编译原理"],"title":"编译引论(第三章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%863/"},{"categories":["编译原理"],"content":"词法分析程序的功能 词法分析程序的主要任务是按语言的词法规则从源程序中逐个识别单词，把字符串形式的源程序转换为单词串的形式，并把每个单词转换成他们的内部表示，即所谓的“TOKEN”，同时进行词法检测 词法分析和语法分析之间的关系通常由两种形式 词法分析程序既可作为编译器的独立一遍来完成 也可作为词法分析的一个子程序 ","date":"2024-03-19","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%863/:1:0","tags":["编译原理"],"title":"编译引论(第三章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%863/"},{"categories":["编译原理"],"content":"单词的种类及词法分析的输出 单词符号是一个程序语言的最小语法单位，一般分为5类： 保留字。保留字是由程序语言定义的具有固定意义的标识符。有时称这些标识符为关键字或基本字。例如，Pascal中的begin,end,if,while都是保留字。这些字通常不用作一般标识符 标识符。用来表示各种名字，如变量名，数组名，过程名等 常数。常数的类型一般有整型，实型，布尔型，文字性等。例如，100，3.14159，TRUE，‘Sample’ 运算符。如+，-，*，/等 界符。如逗号，分号，括号，/*，*/等 词法分析器所输出的单词符号通常表示成二元式：(单词类别，单词符号的属性值) 单词类别通常用整数编码。标识符一般统归为一类。常数则宜按类型(整，实，布尔等)分类。关键字可将全体视为一类，也可以一字一类。采用一字一类的分法实际处理起来较为方便。运算符可采用一类的分法，但也可以把具有一定共性的运算符视为一类。至于界符一般用一类的分法 单词符号的属性是指单词符号的特性或特征。属性值则是反应特性或特征的值。例如，对于某个标识符，常将存放它的有关信息的符号表项的指针作为其属性值；对于某个常数，则将存放它的常数表项的指针作为其属性值 ","date":"2024-03-19","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%863/:2:0","tags":["编译原理"],"title":"编译引论(第三章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%863/"},{"categories":["编译原理"],"content":"词法分析的手工设计 ","date":"2024-03-19","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%863/:3:0","tags":["编译原理"],"title":"编译引论(第三章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%863/"},{"categories":["编译原理"],"content":"新程序的输入 利用词法分析器生成器：此时生成器将提供用于源程序字符流的读入和缓冲的若干子程序 利用传统的系统程序设计语言来编写词法分析器：此时要利用该语言所具有的输入/输出能力来处理读入操作 不论扫描缓冲区设得多大都不能保证单词符号不会被它的边界所打断。因此，扫描缓冲区最好是用一个如图所示得一分为二的缓冲区域 ","date":"2024-03-19","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%863/:3:1","tags":["编译原理"],"title":"编译引论(第三章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%863/"},{"categories":["编译原理"],"content":"单词的识别和超前搜索 有些语言(如FORTRAN)对于保留字不加保护，用户可以用它们作为普通标识符，这就使得保留字的识别相当困难。请看下面两条正确的FORTRAN语言语句： DO99K=1,10 DO99K=1.10 若下一个界符是逗号，则可以肯定DO是保留字，否则，DO不构成保留字，它只是用户标识符的头两个字母，因此，为了区别语句1，2，必须超前扫描到等号后的第一个界符处。 标识符的识别 大多数语言的标识符是字母开头的字母和数字组成的串，而且在程序中标识符出现后都跟着算符和界符，因此标识符的识别比较简单 常数的识别 大多数语言算数常数的表示大体相似，对于它们的识别比较直接。但对于某些语言的常数的识别也需要用超前搜索的方法。例如，对于FORTRAN语言的语句： IF(5.EQ.M)I=10 其中，5.EQ.M只有当超前扫描到字母Q时才能断定5的词性。因为5.EO8和5.EQ.M的前三个字符完全一样 算符和界符的识别 词法分析器将那些有多个字符复合成的算符和界符(如C语言中的++)拼合成一个单词符号。因为这些字符串是不可分的整体，若分化开来，便失去了原来的意义。在这里同样需要超前搜索 ","date":"2024-03-19","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%863/:3:2","tags":["编译原理"],"title":"编译引论(第三章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%863/"},{"categories":["编译原理"],"content":"状态转换图 所谓状态转换图，就是一张有穷的有向图。在状态转换图中，结点代表状态，用圆圈表示。状态之间用箭弧连接。箭弧上的标记(字符)代表在射出结点状态下可能出现的合法的输入字符。如图a; 一个状态转换图可用于识别(或接受)一定的字符串，如图b; 如果在状态i时输入字符不为“字母”，则意味着识别不出标识符，或者说这个转换图工作不成功。有如，识别整数的状态转换图如图c所示，其中，i为初态，k为终态。大多数程序语言的单词符号都可以用状态转换图予以识别 注：终态结上打个星号“*”意味着多读进一个不属于标识符部分的字符，应把它退还给输入串 ","date":"2024-03-19","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%863/:3:3","tags":["编译原理"],"title":"编译引论(第三章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%863/"},{"categories":["编译原理"],"content":"词法分析的手工构造 简单语言的单词符号 状态转换图 单词可分为单字符单词和多字符单词。对于单字符的识别比较简单，见字符即知，如=，+，*等，无须多读，无须退回。对于多字符单词的识别比较麻烦，存在多读，退回处理。一个程序设计语言的单词识别，可以用若干张状态转换图予以描述，也可以用一张状态图转换图来描述。 为了把这个例子阐述得更简单，有几点重要限制： 所有保留字(如IF,WHILE等)都是“保留字”，用户不得使用它们作为自己定义的标识符，这样就避免了识别保留字时使用超前搜索技术。例如，DO(2)=x这种写法是绝对禁止的 把保留字作为一类特殊标识符来处理，对保留字不专门设计对应的状态图。把保留字及其类别编码预先安排在一张表格中(即保留字表)。当状态转换图识别出一个标识符时，就去查保留字表，确定是它是否为保留字。 如果保留字，标识符和常数之间没有运算符或界符作间隔时，则必须至少用一个空白符作间隔 在上述限制条件下，多数单词符号的识别就不必使用超前搜索技术。在此，可通过一张状态转换图来识别上图的单词符号，如图所示： 状态转换图的程序实现 用程序实现状态转换图的办法是让每个状态结点对应一段程序 设计一组全局变量，过程和函数 ch：字符变量，存放最新读入的源程序字符 strtoken：字符数组，存放构成单词符号的字符串 Get_char：过程，将下一输出字符读到ch中，搜索指示器前一字符位置 Get_BC：过程，检查ch中的字符是否是空白符，若是，则调用Get_char直到ch中进入一个非空白字符 Concat：过程，将ch中的字符连接到字符数组strtoken之后。如调用Concat之前，strtoken中存放的是“VA”，而ch中存放着“R”，则调用Concat后，strtoken的值就变为“VAR” Retract：过程，将搜索指示器回调一个字符位置，将ch置为空白字符 Letter和Digit：布尔函数，分别用于判断ch中的字符是否为字母和数字 Reserve：整型函数，对字符数组strtoken中的字符串查找保留字表，若它是一个保留字则返回它的编码，否则返回0值(假定0不是保留字的编码) Insert_Id：整型函数，将字符数组strtoken中的标识符插入符号表，返回符号表指针 Insert_Const：整型函数，将字符数组strtoken中的常数插入常数表，返回常数表指针 Error：出错处理 状态转换图的具体实现 一般来说，构造识别状态转换图的程序，可让每个状态节点对应一段程序。具体实现时，可分为不含回路的分叉状态节点和含回路的状态节点来讨论。 对于不含回路的分叉状态结点，可让它对应一个switch语句或一组if…then…else语句 例如，如图所示的不含回路的分叉状态结点的转换图，其状态节点0所对应的程序段可表示为 Get_char(); If(Letter()); {...状态1的对应程序段...;} else if(Digit()) {...状态2的对应程序段...;} else if(ch='_') {...状态3的对应程序段...;} else {...错误处理} 当程序执行达到\"错误处理\"时,意味着现行状态0和当前所面临的输入串不匹配. 对于含有回路的状态结点，可让它对应一个有while语句的if语句构成的程序段。例如，如图所示的按回路的状态节点的转换图，其状态节点0所对应的程序段可为 Get_char(); While(Letter() or Digit()) Get_char(); ...状态1的对应程序段... 对于上图 中的状态c,由于它既是标识符的出口又是保留字的出口，因此，需要对strtoue查询保留字表。这项工作由整型函数过程Reserve来完成。若此过程工作结果所得的值为0，则表示strtoken中的字符串是一个标识符(假定0不是保留字的编码)；否则，表示保留字编码。 综上，如图 所示的状态转换图所对应的词法分析器的主题程序如下： int code,value; strtoken:=\" \"; /*将strtoken初始化为空串*/ Get_char(); Get_BC(); if(Letter()) begin while(Letter() or Digit()) begin Concat(); Get_char(); end Retract(); code:=Reserve(); if(code = 0) begin vaue:=Insert_Id(strtoken); return($ID,value); end else return(code,-); end else if (Digit()) begin while(Digit()) begin Concat(); Get_char(); end Retract(); value:=Insert_Const(strtoken); return($INT,value); end else if(ch='=') return($ASSIGN,-); else if(ch='+') return($PLUS,-); else if(ch='*') begin Get_char(); if(ch='*') return($POWER,-); Retract(); return($STAR,-); end else if(ch=',') return($COMMA,-); else if(ch='(') return($LPAR,-); else if(ch=')') return($RPAR,-); else Error(); /*错误处理*/ ","date":"2024-03-19","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%863/:3:4","tags":["编译原理"],"title":"编译引论(第三章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%863/"},{"categories":["编译原理"],"content":"正规式与正规集 设字母表为$\\sum$，辅助字母表$*\\sum = {\\varepsilon,\\phi,|,\\cdot , * ,( , )}$，下面是正则表达式和它所表示的正规集的递归定义： $\\varepsilon$和$\\phi$都是$\\sum$上的正规式，它们所表示的正规集分别为{$\\varepsilon$}和$\\phi$ ; 任何$a \\in \\sum$,a是$\\sum$ 上的一个正规式，它所表示的正规集为{a}; 假定U和V都是$\\sum$上的正规式，它们所表示的正规集分别记为L(U)和L(V),则： U|V是正规式，它所表示的正规集为L(U)$\\cup$L(V)； U$\\cdot$V是正规式，它所表示的正规集L(U)L(V)(即连接积)。 $U^$是正规式，它所表示的正规集为$(L(U))^$ 仅有有限次使用上述3步骤而得到的表达式才是$\\sum$上的正规式。仅有这些正规式所表示的字符集才是$\\sum$上的正规集 ","date":"2024-03-19","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%863/:4:0","tags":["编译原理"],"title":"编译引论(第三章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%863/"},{"categories":["计算机组成原理"],"content":"数据与文字的表示方法 ","date":"2024-03-16","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%862/:0:0","tags":["计算机组成原理"],"title":"计算机组成(第二章)","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%862/"},{"categories":["计算机组成原理"],"content":"数据格式 ","date":"2024-03-16","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%862/:1:0","tags":["计算机组成原理"],"title":"计算机组成(第二章)","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%862/"},{"categories":["计算机组成原理"],"content":"分类 符号数据：非数字符号的表示(ASCII,汉字，图形等) 数值数据：数字数据的表示方式(定点，浮点) 计算机数字和字符的表示方法有利于数据的存储，加工(处理)，传送 ","date":"2024-03-16","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%862/:1:1","tags":["计算机组成原理"],"title":"计算机组成(第二章)","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%862/"},{"categories":["计算机组成原理"],"content":"编码 用少量，简单的基本符号，选择合适的规则表示尽量多的信息，同时利于信息处理(速度，方便) ","date":"2024-03-16","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%862/:1:2","tags":["计算机组成原理"],"title":"计算机组成(第二章)","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%862/"},{"categories":["计算机组成原理"],"content":"数值数据 计算机在数据，文字的表示方式时，应该考虑以下几个因素 表示的数据类型(符号，小数点，数值) 数值的范围 数值精度 存储，处理，传送的硬件代价 ","date":"2024-03-16","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%862/:2:0","tags":["计算机组成原理"],"title":"计算机组成(第二章)","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%862/"},{"categories":["计算机组成原理"],"content":"常用的表示方法 ","date":"2024-03-16","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%862/:3:0","tags":["计算机组成原理"],"title":"计算机组成(第二章)","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%862/"},{"categories":["计算机组成原理"],"content":"定点表示法 所有数据的小数点位置固定不变 理论上位置可以任意，但实际上将数据表示有两种方法(小数点位置固定—定点表示法/定点格式) 纯小数 纯整数 定点数表示 带符号数 不带符号数 定点纯整数 表示数的范围是 $0\\leqslant|x|\\leqslant 2^n-1$ 定点表示法的特点 定点数表示数的范围受字长限制，表示数的范围有限 定点表示的精度有限 机器中，常用定点纯整数表示 ","date":"2024-03-16","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%862/:3:1","tags":["计算机组成原理"],"title":"计算机组成(第二章)","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%862/"},{"categories":["计算机组成原理"],"content":"浮点表示 小数点位置随阶码不同而浮动 格式 $N=R^E.M$ 基数R，取固定的值，比如10.2等；指数E；尾数M； 机器中表示 ","date":"2024-03-16","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%862/:3:2","tags":["计算机组成原理"],"title":"计算机组成(第二章)","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%862/"},{"categories":["计算机组成原理"],"content":"IEEE754标准(规定了浮点数的表示规格，运算规则等) 规则规定了单精度(32)和双精度(64)的基本格式 规则中，尾数用原码，指数用移码(便于对阶和比较) 基数R=2，基数固定，采用隐含方式来表示它 32位的浮点数 S是数的符号位，1位，在最高位，“0”表示正数，“1”表示负数。 M是尾数，23位，在低位部分，采用纯小数表示 E是阶码，8位，采用移码表示。移码比较大小方便 指数偏移，127 64位的浮点数 符号位1位，阶码域11位，尾数域52位，指数偏移值是1023. 因此规格化的64位浮点数x的真值为： $x=(-1)^S\\times(1.M)\\times2^{E-1023}$ e=E-1023 一个规格化的32位浮点数x的真值表示为： $x=(-1)^S\\times(1.M)\\times2^{E-127}$ e=E-127 例题： ","date":"2024-03-16","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%862/:3:3","tags":["计算机组成原理"],"title":"计算机组成(第二章)","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%862/"},{"categories":["计算机组成原理"],"content":"数的机器码表示 ","date":"2024-03-16","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%862/:4:0","tags":["计算机组成原理"],"title":"计算机组成(第二章)","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%862/"},{"categories":["计算机组成原理"],"content":"数的机器码表示 真值：一般书写的数 机器码：机器中表示的数，要解决在计算机内部数的正，负符号和小数点的运算问题 原码，反码，补码，移码 ","date":"2024-03-16","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%862/:4:1","tags":["计算机组成原理"],"title":"计算机组成(第二章)","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%862/"},{"categories":["计算机组成原理"],"content":"原码表示法 原码特点 将真值的正负号换成1和0，表示简单，易于同真值之间进行转换 实现乘除运算规则简单 进行加减运算十分麻烦，做减法无法求解正确结果…… ","date":"2024-03-16","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%862/:4:2","tags":["计算机组成原理"],"title":"计算机组成(第二章)","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%862/"},{"categories":["计算机组成原理"],"content":"反码表示法 定义 正数的表示与原，补码相同，负数的补码符号位为1，数值位是将原码的数值按位取反，就得到该数的反码表示 电路容易实现，触发器的输出有正负之分 ","date":"2024-03-16","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%862/:4:3","tags":["计算机组成原理"],"title":"计算机组成(第二章)","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%862/"},{"categories":["计算机组成原理"],"content":"补码表示法 补码是在“模”和“同余”的概念下导出的(“模\"是指一个计量单位的计量系统的计量范围，即产生“溢出”的量。) 定义 正数的补码就是正数本身，负数的补码是原负数加上模。 计算机运算受字长限制，属于有模运算 定点小数$x_0x_1x_2……x_n$溢出量为2，以2为模(周期) 定点整数$x_0x_1x_2……x_n$溢出量为$2^{n+1}$，以$2{n+1}$为模(周期) 定点小数$x_0x_1x_2……x_n$ $[x]_补=\\begin{cases}x,1\u003ex\\geq-1\\2+x,0\\geq x \\geq -1\\end{cases}$ $符号\\begin{cases}0,正数\\1,负数\\end{cases}$ 补码性质 高位表示正负 正数补码，尾数与原码相同 范围$-2^n\\sim2^n-1$(定点正数) 无正负0之分 变形补码(双符号补码) 为了防止溢出而设定 结论 若运算结果超出了计算机所能表示的数值范围，则只保留它的小于模的低n位的数值，超过n位的高位部分就自动舍弃了。 ","date":"2024-03-16","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%862/:4:4","tags":["计算机组成原理"],"title":"计算机组成(第二章)","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%862/"},{"categories":["计算机组成原理"],"content":"移码表示法(用在阶码中) 定点整数定义：$[x]_移=2^n+x$ ($2^n\u003ex\\geq-2^n$) 00000000~11111111($-2^n\\sim 2^n-1$) 例： 特点 移码和补码尾数相同，符号位相反 范围 $-2^n\\sim 2^n-1$ 例：以定点整数为例，用数轴形式说明原码，反码，补码表示范围和可能的数码组合情况 例：将十进制真值(-127,-1,0,+1,+127)列表表示成二进制数及原码，反码，补码，移码值(要求8位) ","date":"2024-03-16","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%862/:4:5","tags":["计算机组成原理"],"title":"计算机组成(第二章)","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%862/"},{"categories":["计算机组成原理"],"content":"字符和字符串(非数值)的表示方法 符号数据：字符信息用数据表示，如ASCII等 常见的ASCII码用七位二进制表示一个字符，它包括10个十进制数字(0~9)，52个英文大写和小写字母(a ~ z,A~Z)，34个专用符号和32个控制符号，共计128个字符 字符表示方法ASCII：用一个字节表示，低7位用来编码(128)，最高位位校验位 字符串的存放方法：向量存放法 在存储器中占用一片连续的空间，每个字节存放一个字符代码，字符串的所有元素(字符)在物理上是相邻的。 ","date":"2024-03-16","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%862/:5:0","tags":["计算机组成原理"],"title":"计算机组成(第二章)","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%862/"},{"categories":["计算机组成原理"],"content":"奇偶校验概念 奇偶校验码是一种最简单的数据校验码，它的码距等于2，可以检测出一位错误(或奇数位错误)，但不能确定出错的位置，也不能检测出偶数位错误 码距：将两个码字逐位进行对比，具有不同的位的个数，例如01和10，码距为2 奇偶校验实现方法是：有若干为有效信息(如一个字节)，再加上一个二进制位(校验位)组成检验码 ","date":"2024-03-16","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%862/:6:0","tags":["计算机组成原理"],"title":"计算机组成(第二章)","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%862/"},{"categories":["计算机组成原理"],"content":"CRC循环冗余校验 循环冗余校验码 与奇偶校验码一样只能检错不能纠错 应用于数据通信领域和磁介质存储系统中 利用多项式校验 步骤： K=信息码的长度，R=生成多项式最高次幂-\u003e校验码位数N=K+R 生成多项式$G(x)=ax3+bx2+cx1+dx0$，对应二进制码abcd，即为模2除法的除数 信息码左移R位，利用模2除法(上商规则:最高位为1则商1，最高位为0则商0，减法规则：对应位上相同，结果为0，不同，结果为1)，产生余数，将余数补在信息码后形成CRC码，余数某位是1，则该位出错。 ","date":"2024-03-16","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%862/:7:0","tags":["计算机组成原理"],"title":"计算机组成(第二章)","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%862/"},{"categories":["计算机组成原理"],"content":"定点加法，减法运算 ","date":"2024-03-16","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%862/:8:0","tags":["计算机组成原理"],"title":"计算机组成(第二章)","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%862/"},{"categories":["计算机组成原理"],"content":"补码加减法 公式：$[x+y]_补=[x]_补+[y]_补$ 补码减法： 为了将减法转变为加法，需证明公式：$[x-y]_补=[x]_补+[-y]_补$ 证明： $[X]_补+[Y]_补=[X+Y]_补$证明 假设|x|\u003c1,|y|\u003c1,|x+y|\u003c1 现在分四种情况来证明 使用补码加减法求解下列题目 ","date":"2024-03-16","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%862/:8:1","tags":["计算机组成原理"],"title":"计算机组成(第二章)","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%862/"},{"categories":["计算机组成原理"],"content":"溢出的检测 检测方法 双符号位法(参与加减运算的数采用变形补码表示) 单符号位法 ","date":"2024-03-16","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%862/:9:0","tags":["计算机组成原理"],"title":"计算机组成(第二章)","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%862/"},{"categories":["计算机组成原理"],"content":"基本的加法器 半加器 $H_i=A_i\\bigoplus B_i$ 不考虑进位 全加器 考虑低位进位$C_{i-1}$和向高位的进位$C_i$ ","date":"2024-03-16","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%862/:10:0","tags":["计算机组成原理"],"title":"计算机组成(第二章)","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%862/"},{"categories":["计算机组成原理"],"content":"各种逻辑的图形符号 ","date":"2024-03-16","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%862/:10:1","tags":["计算机组成原理"],"title":"计算机组成(第二章)","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%862/"},{"categories":["计算机组成原理"],"content":"串行加法器 将n个全加器相连可得n位加法器，但其加法时间较长。这是因为其位间进位是串行传送的，本位全加和$F_i$必须等低位进位$C_{i-1}$来到后才能进行，加法时间与位数有关 只有改变进位逐位传送的路径，才能提高加法器工作速度 解决办法之一是采用“超前进位产生电路”来同时形成各位进位，从而实现快速加法，我们称这种加法器为超前进位加法器 ","date":"2024-03-16","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%862/:10:2","tags":["计算机组成原理"],"title":"计算机组成(第二章)","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%862/"},{"categories":["计算机组成原理"],"content":"定点乘法运算 乘法实现方法 在现有的加法和减法器的基础上增加适当的以为线路及控制逻辑可以实现 用LSI和VLSI工艺实现专用的乘法器 编制子程序(单片机等低端机器) 原理 $[x]原=x_f \\cdot x{n-1}\\dots x_1 x_0,[y]原=y_f \\cdot y{n-1} \\dots y_1 y_0$ $[x \\cdot y]原=(x_f \\bigoplus y_f)+( 0.x{n-1} \\dots x_1 x_0) \\cdot (0 \\cdot y_{n-1}\\dots y_1 y_0)$ 尾数乘法如下： ","date":"2024-03-16","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%862/:11:0","tags":["计算机组成原理"],"title":"计算机组成(第二章)","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%862/"},{"categories":["计算机组成原理"],"content":"定点原码乘法原理 n位乘n位积可能为2n位 乘积的最后是所有部分积之和，有n个数相加，而FA只有两个输入端 所以需要改造 方法一：硬件实现方法(串行的“加法和移位”)，硬件结构简单，速度太慢(时间延迟太长) 方法二：不带符号位的阵列乘法器 ","date":"2024-03-16","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%862/:11:1","tags":["计算机组成原理"],"title":"计算机组成(第二章)","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%862/"},{"categories":["计算机组成原理"],"content":"由手工计算到机器运算 由手工计算到机器运算，需要解决3个问题： 符号如何让处理 多个部分积如何相加 为保持两次部分积之间的位权对应关系，会导致加法器位数的增加，能否在不增加位数的情况下保持位权对应？ 由于解决方式的不同，形成了两种主要的乘法器结构 采用常规的加法器来实现 将n位乘法转换为n次累加和移位，每次处理1位 为避免加法器位数的扩充，可以把手工计算时的新部分积“左移-\u003e累加”改为机器运算的原部分积“累加-\u003e右移” 采用阵列乘法器实现 利用中大规模集成电路把多项部分积同时相加，这样结构的乘法器称为阵列乘法器 ","date":"2024-03-16","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%862/:11:2","tags":["计算机组成原理"],"title":"计算机组成(第二章)","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%862/"},{"categories":["计算机组成原理"],"content":"原码一位乘法 原码一位乘法是从手算演变而来的，即用两个操作数的绝对值相乘，乘积的符号为两操作数符号的异或值(同号为正，异号为负) 乘积P=|X|$\\times$|Y| 符号$P_s=X_s\\bigoplus Y_s$ 式中：$P_s$为乘积的符号，$X_s$和$Y_s$为被乘数和乘数的符号 规则 参加运算的操作数取其绝对值 令乘数的最低位为判断位，若为\"1”，加被乘数，若为“0”，不加被乘数(加0)； 累加后的部分积以及乘数右移一位 重复n次(2)和(3) 符号位单独处理，同号为正，异号为负。 基本过程 每次将一位乘数所对应的部分积与原部分积的累加和相加并移位 设置寄存器： A：存放部分累加和，乘积高位，格式为双符号位 B：存放被乘数，格式为双符号位 C：存放乘数，乘积低位，格式为无符号位 设置初值： A=00.0000 B=|X|=00.1101 C=|Y|= .1011 操作步骤 ","date":"2024-03-16","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%862/:11:3","tags":["计算机组成原理"],"title":"计算机组成(第二章)","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%862/"},{"categories":["计算机组成原理"],"content":"算法流程 ","date":"2024-03-16","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%862/:11:4","tags":["计算机组成原理"],"title":"计算机组成(第二章)","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%862/"},{"categories":["计算机算法设计与分析"],"content":"分治法 ","date":"2024-03-12","objectID":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A12/:0:0","tags":["计算机算法设计与分析"],"title":"算法与程序(第二章)","uri":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A12/"},{"categories":["计算机算法设计与分析"],"content":"思想 分+治+合 ","date":"2024-03-12","objectID":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A12/:1:0","tags":["计算机算法设计与分析"],"title":"算法与程序(第二章)","uri":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A12/"},{"categories":["计算机算法设计与分析"],"content":"过程 分治法产生的子问题是原问题的较小模式 反复应用分治手段，可以使子问题规模不断减小 最终使子问题缩小到很容易直接求出其解 将规模较小问题的答案逐级向上合并(递归过程)，可得大问题答案 分治法解决问题通常使用递归算法 递归的概念 直接或间接地调用自身的算法称为递归算法 ","date":"2024-03-12","objectID":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A12/:2:0","tags":["计算机算法设计与分析"],"title":"算法与程序(第二章)","uri":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A12/"},{"categories":["计算机算法设计与分析"],"content":"递归算法的框架 ","date":"2024-03-12","objectID":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A12/:3:0","tags":["计算机算法设计与分析"],"title":"算法与程序(第二章)","uri":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A12/"},{"categories":["计算机算法设计与分析"],"content":"要素 边界条件与递归方程是递归函数的两个要素 递归函数只有这两个要素才能在有限次运算得出结果 ","date":"2024-03-12","objectID":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A12/:4:0","tags":["计算机算法设计与分析"],"title":"算法与程序(第二章)","uri":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A12/"},{"categories":["计算机算法设计与分析"],"content":"小结 优点:结构清晰，可读性强，而且容易用数学归纳法来证明算法的正确性，因此它为设计算法，调试程序带来很大方便 缺点:递归算法的运行效率较低，无论是耗费的计算时间还是占用的存储空间都比非递归算法要多 建议: 如果问题用递推方法可解决，就不要使用递归算法 用栈模拟的非递归算法，对运行效率改善有限，不建议使用 分治法的适用条件 n个问题分解为k个规模较小的子问题，子问题之间相互独立，不包含公共的问题，名子问题的解合并得到原问题的解 ","date":"2024-03-12","objectID":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A12/:5:0","tags":["计算机算法设计与分析"],"title":"算法与程序(第二章)","uri":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A12/"},{"categories":["计算机算法设计与分析"],"content":"最优子传构性质 最优子结构是依赖特定问题和子问题的分割方式而成立的条件。各子问题具有最优解，就能求出整个问题的最优解，此时条件成立。 比如求广州到北京的最短距离，假设这个路径必经过中间的南京，那么先把路径分割为（广州，南京）和（南京，北京）。分别求出子路径的最短距离然后再连接，就可以得到广州到北京的最短路径。 因此，寻求最短路径的问题可以利用子路径的最优解获得整个问题的最优解。这样就可以证明，最短路径具有最优子结构。 ","date":"2024-03-12","objectID":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A12/:6:0","tags":["计算机算法设计与分析"],"title":"算法与程序(第二章)","uri":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A12/"},{"categories":["计算机算法设计与分析"],"content":"分治法时间复杂度分析 一个分治法将规模为n的问题分成k个规模为n/m的子问题去解。为方便起见，设分解阈值n0为1，且adhoc解规模为1的问题耗费1单位时间。另外，将原问题分解为k个子问题及用merge将k个子问题的解合并为原问题的解需用f(n)单位时间 二分搜索技术 将n个元素分成个数大致相同的两半，取a[n/2]与x作比较。如果x=a[n/2]，则找到x，算法终止；如果x\u003ca[n/2]，则只在数组a的左半部继续搜索x;如果x\u003ea[n/2]，则只在数组a的右半部继续搜索x 具体描述算法如下： ","date":"2024-03-12","objectID":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A12/:7:0","tags":["计算机算法设计与分析"],"title":"算法与程序(第二章)","uri":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A12/"},{"categories":["计算机算法设计与分析"],"content":"二分搜索技术(递归算法) int BinarySearch_Rec(int num[], int target, int left, int right) { while (left \u003c= right) { int mid = left + (right - left) / 2; if (num[mid] == target) return mid; else if (num[mid] \u003e target) return BinarySearch_Rec(num, target, left, mid - 1); else if (num[mid] \u003c target) return BinarySearch_Rec(num, target, mid + 1, right); } return -1; } 算法复杂度分析 利用主定理或递归树可求其时间复杂性为:O(logn) ","date":"2024-03-12","objectID":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A12/:7:1","tags":["计算机算法设计与分析"],"title":"算法与程序(第二章)","uri":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A12/"},{"categories":["计算机算法设计与分析"],"content":"二分搜索技术(非递归算法) int BinarySearch(int num[], int target, int len) //非递归实现 { int left = 0; int right = len - 1; // 第一个细节点 while (left \u003c= right) // 第二个细节点 { int mid = left + (right - left) / 2; if (num[mid] == target) return mid; else if (num[mid] \u003e target) right = mid - 1; // 第三个细节点 else if (num[mid] \u003c target) left = mid + 1; // 第四个细节点 } return -1; } 算法复杂度分析 每执行一次while循环，待搜素数组的大小减小1/2.在最坏情况下，while循环被执行了O(logn)次，因此算法在最坏情况下计算时间复杂性为O(logn) ","date":"2024-03-12","objectID":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A12/:7:2","tags":["计算机算法设计与分析"],"title":"算法与程序(第二章)","uri":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A12/"},{"categories":["计算机算法设计与分析"],"content":"快速幂算法 给定实数a和非负整数n，用分治法设计求$a^n$的快速算法(递归算法) 分析： 算法如下 double exp2(double a,int n){ if(a==0) return 0; if(n\u003c=0) return 1; else{ int x=exp2(a,n/2); if(n%2) return a*x*x; else return x*x; } } 该问题满足四个条件时间复杂性O(logn) 给定正整数a和n，用分治法设计求$a^n$的快速算法(非递归算法) 举例求$a^{93}$ n=93的二进制表示(如图)，也就是n=64+16+8+4+1,因此$a^{93}=a^{64}a^{16}a^8a^4a$ 算法如下 double exp2(double a,int n){ int i; double b,s=1.0; i=n; b=a; while(i\u003e0){ if(i%2) s*=b; i/=2; b*=b; } return s; } ","date":"2024-03-12","objectID":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A12/:8:0","tags":["计算机算法设计与分析"],"title":"算法与程序(第二章)","uri":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A12/"},{"categories":["计算机算法设计与分析"],"content":"Strassen矩阵乘法 首先，仍假设n是2的幂。将矩阵A,B和C中的每个矩阵都分块成4个大小相等的子矩阵，每个子矩阵都是n/2*n/2的方阵。由此可将方程C=AB重写为： 时间复杂性分析 上述分治法的计算时间耗费T(n)应满足 这个递归方程的解仍然是T(n)=O($n^3$)。因此，该方法并不比用原始定义直接计算更有效。究其原因，由于是该方法并没有减少矩阵的乘法次数。 要想改进矩阵乘法的计算时间复杂性，必须减少乘法运算 优化 时间复杂性分析 Strassen矩阵乘法中用了7次对于n/2阶矩阵乘积的递归调用和18次n/2阶矩阵的加减运算。由此可知，该算法所需的计算时间T(n)满足如下递归方程： 解此递归方程得T(n)=O($n^{log7}$)$\\approx$O($n^{2.81}$)。由此可见，Strassen矩阵乘法的计算时间复杂性比普通矩阵乘法有较大改进 ","date":"2024-03-12","objectID":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A12/:9:0","tags":["计算机算法设计与分析"],"title":"算法与程序(第二章)","uri":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A12/"},{"categories":["计算机算法设计与分析"],"content":"棋盘覆盖 当k\u003e0时，将$2^k\\times 2^k$棋盘分割为4个$2^{k-1}\\times 2{k-1}$子棋盘，如图a所示。特殊方格必位4个较小子棋盘之一中，其余3个子棋盘中无特殊方格。为了将这3个无特殊方格的子棋盘转化为特殊棋盘，可以用一个L型骨牌覆盖这3个较小棋盘的会合处，如b所示，这3个子棋盘上被L型骨牌覆盖的方格就成为该棋盘上的特殊方格，从而将原问题转化为4个较小规模的棋盘覆盖问题。递归地使用这种分割，直至棋盘简化为$1\\times1$棋盘 算法如下 void chessBoard(int tr, int tc, int dr, int dc, int size) { if (size==1) return; int s = size/2; //分割棋盘 int t = ++num; //L型骨牌号 //覆盖左上角子棋盘 if (dr \u003c tr + s \u0026\u0026 dc \u003c tc +s) { //特殊方格在此棋盘中 chessBoard(tr,tc,dr,dc,s); } else //此棋盘中无特殊方格 { //用t号L型骨牌覆盖右下角 Matrix[tr+s-1][tc+s-1] = t; //覆盖其余方格 chessBoard(tr,tc,tr+s-1,tc+s-1,s); } //覆盖右上角子棋盘 if (dr \u003c tr + s \u0026\u0026 dc \u003e= tc + s ) { //特殊方格在此棋盘中 chessBoard(tr,tc+s,dr,dc,s); } else //此棋盘中无特殊方格 { //用t号L型骨牌覆盖左下角 Matrix[tr+s-1][tc+s] = t; //覆盖其余方格 chessBoard(tr,tc+s,tr+s-1,tc+s,s); } //覆盖左下角子棋盘 if (dr \u003e= tr + s \u0026\u0026 dc \u003c tc + s) { //特殊方格在此棋盘中 chessBoard(tr+s,tc,dr,dc,s); } else { //用t号L型骨牌覆盖右上角 Matrix[tr+s][tc+s-1] = t; //覆盖其余方格 chessBoard(tr+s,tc,tr+s,tc+s-1,s); } //覆盖右下角子棋盘 if (dr \u003e= tr + s \u0026\u0026 dc \u003e= tc + s) { //特殊方格在此棋盘中 chessBoard(tr+s,tc+s,dr,dc,s); } else { //用t号L型骨牌覆盖左上角 Matrix[tr+s][tc+s] = t; //覆盖其余方格 chessBoard(tr+s,tc+s,tr+s,tc+s,s); } } 复杂度分析 T(n)=O($n^2$) 本算法可使用队列或者栈实现，非递归算法 ","date":"2024-03-12","objectID":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A12/:10:0","tags":["计算机算法设计与分析"],"title":"算法与程序(第二章)","uri":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A12/"},{"categories":["计算机算法设计与分析"],"content":"合并排序 将待排序元素分成大小大致相同的两个子集合，分别对两个子集合进行排序，最终将排好序的子集合合并成要求好的排好序的集合 算法描述(可递归) template\u003cclass Type\u003e void MergeSort(Type a[],int left,int right){ if(left\u003cright){ //至少有2个元素 int i =(left + right)/2; //取中点 MergeSort(a,left,i); MergeSort(a,i+1,right); Merge(a,b,left,i,right); //合并到数组b Copy(a,b,left,right); //复制回数组a } } 算法MergeSort的递归过程可以消去 复杂度分析 最坏时间复杂度：O(nlogn) 平均时间复杂度：O(nlogn) 辅助空间：O(n) 稳定性：稳定 ","date":"2024-03-12","objectID":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A12/:11:0","tags":["计算机算法设计与分析"],"title":"算法与程序(第二章)","uri":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A12/"},{"categories":["计算机算法设计与分析"],"content":"快速排序 快速排序算法是基于分治策略的另一个排序算法。其基本思想是，对于输入的子数组a[p:r]，按以下三个步骤进行排序。 分解(Divide):以a[p]为基准元素将a[p:r]划分成3段a[p:q-1],a[q]和a[q+1:r]，使a[p:q-1]中任何一个元素小于等于a[q]，而a[q+1:r]中任何一个元素大于等于a[q]。下标q在划分过程中确定 递归求解(Conquer)：通过递归调用快速排序算法，分别对a[p:q-1]和a[q+1:r]进行排序 合并(Merge):由于对a[p:q-1]和a[q+1:r]的排序是就地进行的，因此在a[p:q-1]和a[q+1:r]都已排好的序后，不需要执行任何计算，a[p:r]则已排好序 算法如下： template(class Type) void QuickSort(Type a[],int p,int r){ if(p\u003cr){ int q=Partition(a,p,r); QuickSort(a,p,q-1); //对左半段排序 QuickSort(a,q+1,r); //对右半段排序 } } 对含有n个元素的数组a[0:n-1]进行快速排序只要调用QuickSort(a,0,n-1)即可。 上述算法中的函数Partition()以一个确定的基准元素a[p]对子数组a[p:r]进行划分，它是快速排序算法的关键。 算法如下： template\u003cClass Type\u003e int Partition (Type a[],int p,int r){ int i =p,j=r+1; Type x =a[p]; //将小于x的元素交换到左边区域，将大于x的元素交换到右边区域 while(true){ while(a[++i]\u003cx\u0026\u0026i\u003cr); while(a[--j]\u003ex); if(i\u003e=j) break; Swap(a[i],a[j]); } a[p] = a[j]; a[j] = x; return j; } 复杂度分析 快速排序算法的性能取决于划分的对称性 最坏情况，每次划分出的二个子问题，一个长度为0，另一个长度为n-1，其对应的时间复杂性的递归定义为： 最坏时间复杂度：O($n^2$) 平均时间复杂度：O(nlogn) 稳定性：不稳定 通过修改算法partition，可以设计出采用随机选择策略的快速排序算法。可以在a[p:r]中随机选出一个元素作为划分基准。可以期望划分是较对称的。 template\u003cClass Type\u003e int RandomizedPartition(Type a[],int p,int r){ int i = Random(p,r); Swap(a[i],a[p]); return Partition(a,p,r); } void RandomizedQuickSort(Type a[],int p,int r){ if(p\u003cr){ int q=RandomizedPartition(a,p,r); RandomizedQuickSort(a,p,q-1); //对左半段排序 RandomizedQuickSort(a,q+1,r); //对右半段排序 } } ","date":"2024-03-12","objectID":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A12/:12:0","tags":["计算机算法设计与分析"],"title":"算法与程序(第二章)","uri":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A12/"},{"categories":["计算机算法设计与分析"],"content":"线性时间选择 给定线性序集中n个元素和一个整数k，$1\\leq k \\leq n$，要求找出这n个元素中第k小的元素 template\u003cClass Type\u003e Type RandomizedSelect(Type a[],int p,int r,int k){ if(p==r) return a[p]; int i=RandomizedPartition(a,p,r); j=j-p+1; if(j==k) return a[i]; if(k\u003cj) return RandomizedSelect(a,p,i,k); else return RandomizedSelect(a,i+1,r,k-j); } 时间复杂性分析 在最坏情况下，算法RandomizedSelect需要O($n^2$)计算时间 但可以证明，算法RandomizedSelect可以在O(n)平均时间内找出n个输入元素中的第k小元素 ","date":"2024-03-12","objectID":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A12/:13:0","tags":["计算机算法设计与分析"],"title":"算法与程序(第二章)","uri":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A12/"},{"categories":["数据结构"],"content":"概念 相互之间存在一种或多种特定关系的数据元素的集合 逻辑结构，存储结构，运算合称为三要素 ","date":"2024-03-10","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:0:0","tags":["数据结构"],"title":"数据结构(第一章)","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["数据结构"],"content":"数据结构形式定义 数据结构是一个二元组 Data_Structure = (D,S) D是数据元素的有限集，S是D上关系的有限集 基本术语 ","date":"2024-03-10","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:1:0","tags":["数据结构"],"title":"数据结构(第一章)","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["数据结构"],"content":"数据 所有能被计算机识别，存储和处理的符号的集合 ","date":"2024-03-10","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:2:0","tags":["数据结构"],"title":"数据结构(第一章)","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["数据结构"],"content":"数据元素 是数据的基本单位，具有完整的实际意义。一个数据元素可由若干个数据项组成 ","date":"2024-03-10","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:3:0","tags":["数据结构"],"title":"数据结构(第一章)","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["数据结构"],"content":"数据项 构成数据元素的项目。是数据不可分割的最小单位 ","date":"2024-03-10","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:4:0","tags":["数据结构"],"title":"数据结构(第一章)","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["数据结构"],"content":"数据类型 指一个类型和定义在这个类型上的操作集合。 ","date":"2024-03-10","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:5:0","tags":["数据结构"],"title":"数据结构(第一章)","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["数据结构"],"content":"抽象数据元素 抽象定义的，没有实际含义的数据元素 ","date":"2024-03-10","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:6:0","tags":["数据结构"],"title":"数据结构(第一章)","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["数据结构"],"content":"抽象数据类型 用户自己定义的数据类型 数据结构涵盖的内客 ","date":"2024-03-10","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:7:0","tags":["数据结构"],"title":"数据结构(第一章)","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["数据结构"],"content":"逻辑结构 ","date":"2024-03-10","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:8:0","tags":["数据结构"],"title":"数据结构(第一章)","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["数据结构"],"content":"线性结构 线性表，栈，队，串，数组 ","date":"2024-03-10","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:8:1","tags":["数据结构"],"title":"数据结构(第一章)","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["数据结构"],"content":"非线性结构 树结构，图结构，集合结构 ","date":"2024-03-10","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:8:2","tags":["数据结构"],"title":"数据结构(第一章)","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["数据结构"],"content":"物理结构(存储结构) 是数据的逻辑结构在计算机存储器内的表示(或映像)。它依赖于计算机 ","date":"2024-03-10","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:9:0","tags":["数据结构"],"title":"数据结构(第一章)","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["数据结构"],"content":"分类 顺序结构，链式结构，索引结构，散列结构 ","date":"2024-03-10","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:9:1","tags":["数据结构"],"title":"数据结构(第一章)","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["数据结构"],"content":"数据运算 在数据的逻辑结构上定义的操作算法 ","date":"2024-03-10","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:10:0","tags":["数据结构"],"title":"数据结构(第一章)","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["数据结构"],"content":"分类 插入运算，删除运算，修改运算，查找运算，排序运算 数据类型与抽象数据类型的区别 ","date":"2024-03-10","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:10:1","tags":["数据结构"],"title":"数据结构(第一章)","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["数据结构"],"content":"数据类型 是一个值的集合和定义在该值上的一组操作的总称 ","date":"2024-03-10","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:11:0","tags":["数据结构"],"title":"数据结构(第一章)","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["数据结构"],"content":"抽象数据类型 由用户定义，用以表示应用问题的数据类型。它由基本的数据类型构成，并包括一组相关的服务(或称操作) 它与数据类犁实质上是一个概念，但其特征是使用与实现相分离，实行数据封装和信息隐蔽(独立于计算机) ","date":"2024-03-10","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:12:0","tags":["数据结构"],"title":"数据结构(第一章)","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["数据结构"],"content":"抽象数据类型用三元组表示 ADT = (D,S,P) D:数据对象 S:D上的关系集 P:D上的操作集 ","date":"2024-03-10","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:13:0","tags":["数据结构"],"title":"数据结构(第一章)","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["数据结构"],"content":"ADT常用定义格式 算法和算法分析 ","date":"2024-03-10","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:14:0","tags":["数据结构"],"title":"数据结构(第一章)","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["数据结构"],"content":"算法 是对特定问题求解步骤的一种描述，是指令的有限序列，输入转换输出的计算步骤 好的程序设计：好算法+好结构 ","date":"2024-03-10","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:15:0","tags":["数据结构"],"title":"数据结构(第一章)","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["数据结构"],"content":"基本特性 有穷性，确定性，可行性，必有输出 ","date":"2024-03-10","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:15:1","tags":["数据结构"],"title":"数据结构(第一章)","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["数据结构"],"content":"评价指标 正确性，可读性，健状性，高效率(常用时间复杂度衡量)与低存储量(常用空间复杂度衡量)需求 ","date":"2024-03-10","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:15:2","tags":["数据结构"],"title":"数据结构(第一章)","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["数据结构"],"content":"算法描述方式 自然语言，程序设计语言，流程图，类高级语言(类C语言，类Pascal语言等) ","date":"2024-03-10","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:15:3","tags":["数据结构"],"title":"数据结构(第一章)","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["数据结构"],"content":"类C语言描述语法 类C语言精选了C语言的一个核心子集，也做了若干扩充，以利于描述 ","date":"2024-03-10","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:15:4","tags":["数据结构"],"title":"数据结构(第一章)","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["数据结构"],"content":"时间复杂度 若存在两个正常数c,n0，对于所有的$n\u003e=n_0$，有| f(n) |\u003c= c| g(n) |， 则记作f(n)=O(g(n)) 频度：是指该语句重复执行的次数 定理：若$$A(n)=a_mn^m+a_{m-1}n^{m-1}+…+a_1n+a_0是一个m次多项式，则A(n)=0(n^m)$$ ","date":"2024-03-10","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:16:0","tags":["数据结构"],"title":"数据结构(第一章)","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["数据结构"],"content":"空间复杂度 算法所需存储空间的量度 记作：S(n)=O(f(n)) 其中n为问题的规模(或大小) ","date":"2024-03-10","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:17:0","tags":["数据结构"],"title":"数据结构(第一章)","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["数据结构"],"content":"线性表定义 一个线性表是n个数据元素的有限序列 ","date":"2024-03-10","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%842/:0:0","tags":["数据结构"],"title":"数据结构(第二章)","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%842/"},{"categories":["数据结构"],"content":"数据元素类型 原子型 整数，字符 结构类型 表示学生的数据元素 ","date":"2024-03-10","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%842/:1:0","tags":["数据结构"],"title":"数据结构(第二章)","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%842/"},{"categories":["数据结构"],"content":"线性表中的元素之间的关系是线性关系 存在惟一的第一个元素 存在惟一的最后一个元素 除第一个元素之外，每个元素均只有一个直接前驱 除最后一个元素之外，每个元素均只有一个直接后继 ","date":"2024-03-10","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%842/:2:0","tags":["数据结构"],"title":"数据结构(第二章)","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%842/"},{"categories":["数据结构"],"content":"顺序表 线性表的顺序存储 ","date":"2024-03-10","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%842/:3:0","tags":["数据结构"],"title":"数据结构(第二章)","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%842/"},{"categories":["数据结构"],"content":"内涵 指用一组地址连续的存储单元依次存储线性表的数据元素。 ","date":"2024-03-10","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%842/:3:1","tags":["数据结构"],"title":"数据结构(第二章)","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%842/"},{"categories":["数据结构"],"content":"特点 存储单元地址连续(需要一段连续空间)逻辑上相邻的数据元素其物理位置也相邻存储密度大(100%) 随机存取 元素序号与存储位置存在如下关系： *Loc(ai) = Loc(ai)+(i-1)d (1\u003c=i\u003c=n) 线性表的动态分配顺序存储结构 在上述定义中，数组指针elem指示线性表的基地址，length指示线性表的当前长度。顺序表的初始化操作就是为顺序表分配一个预定义大小的数组空间，并将线性表的当前长度设为“0”.listsize指示顺序表当前分配的存储空间大小，一旦因插入元素而空间不足时，可再进行分配，即为顺序表增加一个大小为存储LISTINCREMENT个数据元素的空间 ","date":"2024-03-10","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%842/:3:2","tags":["数据结构"],"title":"数据结构(第二章)","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%842/"},{"categories":["数据结构"],"content":"线性表上的基本运算 ","date":"2024-03-10","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%842/:4:0","tags":["数据结构"],"title":"数据结构(第二章)","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%842/"},{"categories":["数据结构"],"content":"插入运算 含义 将元素e插入到线性表:($a_1,a_2,……,a_{i-1},a_i,……,a_n$)中，构成新的线性表($a_1,a_2,……,a_{i-1},e,a_i,……,a_n$)，满足$a_{i-1}\\leq e \\leq a_i$，(其中$\\leq$为比较关系)，即不破坏原线性关系。 一般情况下，在第i($1\\leq i \\leq n$)个元素之前插入一个元素时，需将第n至第i(共n-1+1)个元素向后移动一个位置。 算法如下： Status ListInsert Sq(SqList \u0026L,int i ,ElemType e){ //在顺序线性表L中第i个位置之前插入新的元素额， //i的合法值为1\u003c=i\u003c=ListLength_Sq(L)+1 if(i\u003c1||i\u003eL.length+1) return ERROR; //i值不合法 if(L.length\u003e=L.listsize){ //当前存储空间已满，增加分配 newbase = (ElemType *)realloc(L.elem,(L.listsize+LISTINCREMENT)*sizeof(ElemType)); if(!newbase) exit(OVERFLOW); //存储分配失败 L.elem = newbase; //新基址 L.listsize+=LISTINCREMENT; //增加存储容量 } q=\u0026(L.elem[i-1]); //q为插入位置 for(p=\u0026(L.elem[L.length-1]);p\u003e=q;--p) *(p+1)=*p; //插入位置及之后的元素右移 *q=e; //插入e ++L.length; //表长增1 return OK; } //ListInsert_Sq 顺序表上插入运算效率分析 时间复杂度 最好情况：在表尾插入，不移动元素，T(n)=O(1) 最坏情况：在表头插入，移动n个元素，T(n)=O(n) 平均复杂度 设$p_i$为在第i个元素之前插入一个元素的概率，且$P_1=P_2=…=P_i=…P_n=1/(n+1)$，则平均移动次数为： $E_is = \\sum \\limits^{n+1}{i=1}P_i(n-i+1)=1/(n+1)\\sum\\limits^{n+1}{i=1}(n-i+1)=n/2$ 即T(n)=O(n) 空间复杂度 不需要额外空间，S(n)=O(1). ","date":"2024-03-10","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%842/:4:1","tags":["数据结构"],"title":"数据结构(第二章)","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%842/"},{"categories":["数据结构"],"content":"删除运算 顺序表上删除运算的实现 一般情况下，删除第i($1\\leq i \\leq n$)个元素时需将从第i+1至第n(共n-i)个元素依次向前移动一个位置 算法如下： Status ListDelete_Sq(SqList \u0026L,int i,ElemType \u0026e){ //在顺序线性表L中删除第i个元素，并用e返回其值 //i的合法值为1\u003c=i\u003c=ListLength_Sq(L) if((i\u003c1) || (i\u003eL.length)) return ERROR //i值不合法 p=\u0026(L.elem[i-1]); //p为删除元素的位置 e=*p; //被删除元素的值赋给e q=L.elem+L.length-1; //表尾元素的位置 for(++p;p\u003c=q;++p) *(p-1) = *p; //被删除元素之后的元素左移 --L.length; //表长减1 return OK; }//ListDelete_Sq ","date":"2024-03-10","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%842/:4:2","tags":["数据结构"],"title":"数据结构(第二章)","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%842/"},{"categories":["数据结构"],"content":"顺序表上删除运算效率分析 平均复杂度 假设$q_i$是删除第i个元素的概率，则在长度为n的线性表中删除一个元素时所需移动元素次数的期望值(平均次数)为 $E_dl=\\sum\\limits^n_{i=1}q_i(n-i)=1/n\\sum\\limits^n_{i=1}(n-1)=(n-1)/2$ 即：T(n)=O(n) 空间复杂度 S(n)=O(1) ","date":"2024-03-10","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%842/:4:3","tags":["数据结构"],"title":"数据结构(第二章)","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%842/"},{"categories":["数据结构"],"content":"顺序表的优缺点 优点 不需要额外的存储空间来表示元素间的逻辑关系 可以随机地存取表中的任意一个元素 缺点 插入和删除元素时要移动大量的元素 必须事先进行空间分配，表的容量难以扩充(新算法已解决) ","date":"2024-03-10","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%842/:4:4","tags":["数据结构"],"title":"数据结构(第二章)","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%842/"},{"categories":["数据结构"],"content":"类语言书写的算法与C程序之间的差别 算法中除形式参数外，变量不做定义，在C程序中必须定义 算法中使用的元素类型(ElemType)没有定义，C程序中必须定义，常量OK,ERROR,OVERFLOW等在第一章统一定义 算法中的比较运算符(equal,less)未作定义，C程序中必须定义 必要的头文件(用作输入输出的stdio.h及内存申请的stdlib.h)，在C程序中必需包含 ","date":"2024-03-10","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%842/:5:0","tags":["数据结构"],"title":"数据结构(第二章)","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%842/"},{"categories":["数据结构"],"content":"线性表的链式表示和实现 ","date":"2024-03-10","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%842/:6:0","tags":["数据结构"],"title":"数据结构(第二章)","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%842/"},{"categories":["数据结构"],"content":"线性表的链式存储思路 逻辑结构 存储结构 实现方式 对每一个元素的存储单位进行扩充，在包含元素值存储的同时，在结点中存储与当前元素有直接关系的其他元素(直接前驱/直接后继)存储单位的地址(指针) 链式存储单位结构示意图 ","date":"2024-03-10","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%842/:6:1","tags":["数据结构"],"title":"数据结构(第二章)","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%842/"},{"categories":["数据结构"],"content":"链表(线性表的链式存储) 内涵 线性表的链式存储指用任意的存储单位存放线性表中的元素，每个元素与其直接前驱和(或)直接后继之间的关系用指针来存储，这称为链表 术语 结点：数据元素及其有直接关系的元素的地址构成的存储单位 链表结点结构示意图 ","date":"2024-03-10","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%842/:6:2","tags":["数据结构"],"title":"数据结构(第二章)","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%842/"},{"categories":["数据结构"],"content":"单链表 链表中，如果每个结点中只包含一个指针域，则称之为线性链表或单链表 单链表的存储 每个结点存储当前元素的直接后继。 线性表($a_1,a_2,…,a_{i-1},a_i,a_{i+1},…,a_n$) 链表示意图 单链表的内存镜像 单链表的C语言实现 //用结构指针描述 typedef struct LNode{ ElemType data; //数据域 struct LNode *next //指针域 }LNode,*LinkList 与之对应的结点结构示意图 单链表构建示意图(表头插入法) 带头结点的单链表 ","date":"2024-03-10","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%842/:6:3","tags":["数据结构"],"title":"数据结构(第二章)","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%842/"},{"categories":["数据结构"],"content":"单链表上的查找运算 在单链表中，必须从头指针出发进行查找 查找第i个元素 查找指定元素是否在表中 ….. 若找到，则返回该元素的值，否则返回ERROR 在单链表上查找第i个元素的示意图 用类C语言实现单链表上的查询(查找第i个元素) Status GetElem_L(LinkList L,int i,ElemType \u0026e){ //L为带头结点的单链表的头指针 //当第i个元素存在时，其赋值给e并返回OK，否则返回ERROR p=L-\u003enext; j=1; //初始化，p指向第一个结点，否则返回ERROR while(p\u0026\u0026j\u003c1){ p=p-\u003enext; ++j; } if(!p||j\u003ei) return ERROR; //第i个元素不存在 e=p-\u003edata; //取第i个元素 return OK; }//GetElem_L ","date":"2024-03-10","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%842/:6:4","tags":["数据结构"],"title":"数据结构(第二章)","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%842/"},{"categories":["数据结构"],"content":"单链表的插入运算(第i个位置插入新的结点) 用类C语言实现单链表上的插入(插入第i个元素) Status ListInsert_L(LinkList \u0026L,int i,ElemType e){ //在带头结点的单链线性表L中的第i个位置之前插入元素e p=L; j=0; while(p\u0026\u0026j\u003ci-1){ p=p-\u003enext; ++j; } //寻找i-1个结点 if(!p||j\u003ei-1) return ERROR; //i小于1或者大于表长+1 s=(LinkList)malloc(sizeof(LNode)); //生成新结点 s-\u003edata=e; s-\u003enext=p=\u003enext; //插入L中 p-\u003enext=s; return OK; }//ListInsert_L 用类C语言实现单链表上的删除(删除第i个元素) Status ListDelete_L(LinkList \u0026L,int i,ElemType \u0026e){ //在带头结点的单链线性表L中，删除第i个元素，并由e返回其值 p=L; j=0; while(p-\u003enext\u0026\u0026j\u003ci-1){ //寻找第i个结点，并令p指向其前驱 p=p-\u003enext; ++j; } if(!(p-\u003enext)||j\u003ei-1) return ERROR; //删除位置不合理 q=p-\u003enext; p-\u003enext=q-\u003enext; //删除并释放结点 e=q-\u003edata; free(q); return OK; }//ListDelete_L ","date":"2024-03-10","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%842/:6:5","tags":["数据结构"],"title":"数据结构(第二章)","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%842/"},{"categories":["面向对象程序设计"],"content":"c++的产生 c++是从c语言发展演变而来的，引入了类的机制，最初也被称为\"带类的C\" ","date":"2024-03-09","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/:0:0","tags":["面向对象程序设计"],"title":"c++(two)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/"},{"categories":["面向对象程序设计"],"content":"特点 保持c的简洁，高效和接近汇编语言等特点 对c的类型系统进行改革和扩充 c++也支持面向过程的程序设计，不是一个纯正的面向对象的语言 支持面向对象的方法 ","date":"2024-03-09","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/:1:0","tags":["面向对象程序设计"],"title":"c++(two)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/"},{"categories":["面向对象程序设计"],"content":"实例 #include\u003ciostream\u003e using namespace std; int main(){ ​ cout\u003c\u003c\"Hello\\n\"; ​ cout\u003c\u003c\"Welcome to c++!\\n\"; } 结果 Hello! Welcome to c++! ","date":"2024-03-09","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/:2:0","tags":["面向对象程序设计"],"title":"c++(two)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/"},{"categories":["面向对象程序设计"],"content":"实例说明 在新的c++标准程序库中，所有标识符都声明在命名空间std中，且头文件不使用扩展名 头文件使用旧版(带扩展名)和新版(不带扩展名)皆可，但不可以混用 名字空间防止命名冲突 1. 命名空间声明： namespace NS{ ​ class File; ​ void fun(); } 2. 命名空间内标识符使用： NS::File obj; NS::Fun(); 3. 简洁方法: using namespace NS; 函数 把相关的语句组织在一起，注明相应的名称，利用这种方法把程序分块，这种形式的组合就叫做函数 一个c++程序由一个主函数(main)和若干个函数构成 ","date":"2024-03-09","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/:3:0","tags":["面向对象程序设计"],"title":"c++(two)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/"},{"categories":["面向对象程序设计"],"content":"分类 标准库函数和用户自定义函数 由主函数调用其他函数，其他函数也可以相互调用 ","date":"2024-03-09","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/:4:0","tags":["面向对象程序设计"],"title":"c++(two)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/"},{"categories":["面向对象程序设计"],"content":"函数驱动机制 ","date":"2024-03-09","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/:5:0","tags":["面向对象程序设计"],"title":"c++(two)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/"},{"categories":["面向对象程序设计"],"content":"c++字符集 大小写的英文字母：A~Z,a~z 数字字符:0~9 特殊字符： 空格 ! # % ^ \u0026 * __(下划线) + = -(减号) ~ \u003c \u003e / \\ ’ \" ; . , () [ ] {} 关键字 https://blog.csdn.net/wuxinliulei/article/details/9787901 ","date":"2024-03-09","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/:6:0","tags":["面向对象程序设计"],"title":"c++(two)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/"},{"categories":["面向对象程序设计"],"content":"词法记号 关键字：C++预定义的单词 标识符：程序员声明的单词，它命名程序正文的一些实体 文字：在程序中直接使用符号表示的数据 操作符：用于实现各种运算的符号 分隔符：用于分隔各个词法记号或程序正文，分隔符是() {} , ; 空白：空格，制表符（TAB键产生的字符），换行符（Enter键所产生的字符）和注释的总称 ","date":"2024-03-09","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/:6:1","tags":["面向对象程序设计"],"title":"c++(two)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/"},{"categories":["面向对象程序设计"],"content":"标识符的构成规则 以大写字母，小写字母或下划线(_)开始 可以由以大写字母，小写字母，下划线(_)或数字0·9组成 大写字母和小写字母代表不同的标识符 注释两种(/….****/或则//) 基本数据类型和表达式 ","date":"2024-03-09","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/:6:2","tags":["面向对象程序设计"],"title":"c++(two)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/"},{"categories":["面向对象程序设计"],"content":"C++的基本数据类型 ","date":"2024-03-09","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/:6:3","tags":["面向对象程序设计"],"title":"c++(two)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/"},{"categories":["面向对象程序设计"],"content":"数据类型 常量与变量 整型数据 ","date":"2024-03-09","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/:6:4","tags":["面向对象程序设计"],"title":"c++(two)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/"},{"categories":["面向对象程序设计"],"content":"变量 在程序执行过程中其值可以变化的量，需用名字标识 ","date":"2024-03-09","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/:7:0","tags":["面向对象程序设计"],"title":"c++(two)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/"},{"categories":["面向对象程序设计"],"content":"声明和定义 变量在使用之前需要首先声明其类型和名称 ","date":"2024-03-09","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/:7:1","tags":["面向对象程序设计"],"title":"c++(two)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/"},{"categories":["面向对象程序设计"],"content":"声明语句的形式 ","date":"2024-03-09","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/:7:2","tags":["面向对象程序设计"],"title":"c++(two)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/"},{"categories":["面向对象程序设计"],"content":"变量赋初值 注：C++中有字符串常量，却无字符串变量 ","date":"2024-03-09","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/:7:3","tags":["面向对象程序设计"],"title":"c++(two)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/"},{"categories":["面向对象程序设计"],"content":"整型数据及取值范围 实型数据 字符型数据(一) 布尔型数据 ","date":"2024-03-09","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/:8:0","tags":["面向对象程序设计"],"title":"c++(two)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/"},{"categories":["面向对象程序设计"],"content":"符号常量 为常量命名，这就是符号常量 符号常量在使用之前一定要首先声明 常量声明语句的形式 符号常量在声明时一定要赋初值，而在程序中间不能改变其值 例： ","date":"2024-03-09","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/:8:1","tags":["面向对象程序设计"],"title":"c++(two)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/"},{"categories":["面向对象程序设计"],"content":"不同类型数据混合运算时的类型转换 不同类型数据进行混合运算时，C++编译器会自动进行类型转换 为了避免不同的数据类型在运算中出现混淆，应尽量使用同种类型数据。 可以采用强制类型转换： 例如： ","date":"2024-03-09","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/:8:2","tags":["面向对象程序设计"],"title":"c++(two)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/"},{"categories":["面向对象程序设计"],"content":"变量的存储类型 auto:采用堆栈方式分配内存空间，属于暂时性存储，其存储空间可以被若干变量多次覆盖使用 register:存放在通用寄存器中 extern:在所有函数和程序段中都可以引用 static:在内存中都是以固定地址存放的，在整个程序运行期间都有效 运算符和表达式 ","date":"2024-03-09","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/:9:0","tags":["面向对象程序设计"],"title":"c++(two)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/"},{"categories":["面向对象程序设计"],"content":"表达式是计算求值的基本单位 表达式组成 有运算符(例：+，-，*，/)，运算量(也称操作符，可以是常量，变量等等)和括号组成 例：a+b,x/y 表达式的值 执行表达式所规定的运算，所得到的结果值是表达式的值 表达式的定义 一个常量或表示对象的标识符是一个最简单的表达式，其值是常量或对象的值 一个表达式的值可以用来参与其他操作，即用作其他运算符的操作数，这就形成了更复杂的表达式 包括在括号中的表达式仍是一个表达式，其类型和值与未加括号时的表达式相同 运算符的种类：算术，关系，逻辑。 运算符的分类： 一元运算符(单目运算符) 二元运算符(双目运算符) ","date":"2024-03-09","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/:9:1","tags":["面向对象程序设计"],"title":"c++(two)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/"},{"categories":["面向对象程序设计"],"content":"算术运算符与算术表达式 基本算术运算符 优先级与结核性 先乘除，后加减，同级自左至右 ++，– 例：i++;j–； ","date":"2024-03-09","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/:10:0","tags":["面向对象程序设计"],"title":"c++(two)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/"},{"categories":["面向对象程序设计"],"content":"增量和减量运算符 增量运算符：前增量和后增量 前增量操作++a:先修改变量使之增1，然后将增1过的a的值作为表达式的值 后增量操作a++:先将变量a的值作为表达式的值确定下来，再将a增1 ","date":"2024-03-09","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/:11:0","tags":["面向对象程序设计"],"title":"c++(two)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/"},{"categories":["面向对象程序设计"],"content":"赋值运算符和赋值表达式 ","date":"2024-03-09","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/:12:0","tags":["面向对象程序设计"],"title":"c++(two)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/"},{"categories":["面向对象程序设计"],"content":"简单的赋值运算符 “=” 例：n=n+5,a=b=c=5 作用 将等号右边表达式的值赋给等号左边的对象 类型 等号左边对象的类型 值 等号左边对象被赋值后的值 运算的结合性为自右向左 ","date":"2024-03-09","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/:12:1","tags":["面向对象程序设计"],"title":"c++(two)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/"},{"categories":["面向对象程序设计"],"content":"复合的赋值运算符 有10种符合运算符 这10种复合的赋值运算都是二元运算符，优先级与“=”相同，结合性也是自右向左。 ","date":"2024-03-09","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/:12:2","tags":["面向对象程序设计"],"title":"c++(two)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/"},{"categories":["面向对象程序设计"],"content":"逗号运算和逗号表达式 格式 表达式1，表达式2 求解顺序及结果 先求解1，再求解2，最终结果为表达式2的值，若多个表达式，结果为最后表达式的值 ","date":"2024-03-09","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/:13:0","tags":["面向对象程序设计"],"title":"c++(two)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/"},{"categories":["面向对象程序设计"],"content":"关系运算与关系表达式 关系运算是比较简单的一种逻辑运算，优先次序为： 关系表达式是一种最简单的逻辑表达式其结果类型为bool，值只能为true或false. 关系运算 关系运算的结果true或false是逻辑值 关系运算在C++中，0表示假，任意一个非0的数都表示真 关系运算注意不要将=和==用错 ","date":"2024-03-09","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/:14:0","tags":["面向对象程序设计"],"title":"c++(two)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/"},{"categories":["面向对象程序设计"],"content":"逻辑运算与逻辑表达式 逻辑运算符 !(非) \u0026\u0026(与) ||(或) 优先次序：高$\\rightarrow$ 低 逻辑表达式 其结果类型为bool，值只能为true或false. ","date":"2024-03-09","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/:15:0","tags":["面向对象程序设计"],"title":"c++(two)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/"},{"categories":["面向对象程序设计"],"content":"条件运算符与条件表达式 一般形式 表达式1?表达式2:表达式3 表达式1必须是bool类型 执行顺序 先求解表达式1 若表达式1的值为true，则求解表达式2，表达式2的值为最终结果 若表达式1的值为false，则求解表达式3，表达式3的值为最终结果 ","date":"2024-03-09","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/:16:0","tags":["面向对象程序设计"],"title":"c++(two)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/"},{"categories":["面向对象程序设计"],"content":"sizeof操作符 语法形式 sizeof(类型名)或sizeof(表达式) 结果值 “类型名”所指定的类型或“表达式”的结果类型所占的字节数 注意不用对括号中的表达式本身求值 ","date":"2024-03-09","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/:17:0","tags":["面向对象程序设计"],"title":"c++(two)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/"},{"categories":["面向对象程序设计"],"content":"位运算(按位与(\u0026)) 运算规则 将两个运算量的每一个位进行逻辑与操作 用途 将某一位置0，其它位不变。例如： 将char型变量a的最低位置0：a=a\u00260376; 取指定位。例如： ","date":"2024-03-09","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/:18:0","tags":["面向对象程序设计"],"title":"c++(two)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/"},{"categories":["面向对象程序设计"],"content":"位运算(按位或(|)) 运算规则 将两个运算量的每一个位进行逻辑或操作 用途 将某些位置1，其它位不变。 例如：将int型变量a的低字节位置1： a=a|0xff; ","date":"2024-03-09","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/:19:0","tags":["面向对象程序设计"],"title":"c++(two)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/"},{"categories":["面向对象程序设计"],"content":"位运算(按位异或(^)) 运算规则 两个操作数进行异或： 若对应位相同，则结果该位为0 若对应位不同，则结果该位为1 用途 使特定位翻转(与0异或保持原值，与1异或取反) 例如： ","date":"2024-03-09","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/:20:0","tags":["面向对象程序设计"],"title":"c++(two)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/"},{"categories":["面向对象程序设计"],"content":"位运算(取反(~)) 单目运算符 对一个二进制数按位取反 ","date":"2024-03-09","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/:21:0","tags":["面向对象程序设计"],"title":"c++(two)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/"},{"categories":["面向对象程序设计"],"content":"位运算(移位) ","date":"2024-03-09","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/:22:0","tags":["面向对象程序设计"],"title":"c++(two)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/"},{"categories":["面向对象程序设计"],"content":"左移运算(«) 左移后，低位补0，高位舍弃 ","date":"2024-03-09","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/:22:1","tags":["面向对象程序设计"],"title":"c++(two)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/"},{"categories":["面向对象程序设计"],"content":"右移运算 右移后，低位：舍弃； 高位： 无符号数：补0 有符号数：补“符号数” ","date":"2024-03-09","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/:22:2","tags":["面向对象程序设计"],"title":"c++(two)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/"},{"categories":["面向对象程序设计"],"content":"运算符优先级 ","date":"2024-03-09","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/:23:0","tags":["面向对象程序设计"],"title":"c++(two)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/"},{"categories":["面向对象程序设计"],"content":"混合运算时数据类型的转换(隐含转换) 一些二元运算符(算符运算符，关系运算符，逻辑运算符，位运算符和赋值运算符)要求两个操作数的类型一致 在算数运算和关系运算中如果参与运算的操作数类型不一致，编译系统会自动对数据进行转换(即隐含转换)，基本原则是将低类型数据转换为高类型数据。 类型转换的规则举例 ","date":"2024-03-09","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/:24:0","tags":["面向对象程序设计"],"title":"c++(two)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/"},{"categories":["面向对象程序设计"],"content":"混合运算时数据类型的转换(强制类型转换) 语法形式： 类型说明符(表达式)或(类型说明符)表达式 强制类型转换的作用是将表达式的结果类型转换为类型说明符所指定的类型 强制类型转换的规则举例 ","date":"2024-03-09","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/:25:0","tags":["面向对象程序设计"],"title":"c++(two)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/"},{"categories":["面向对象程序设计"],"content":"语句 ","date":"2024-03-09","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/:26:0","tags":["面向对象程序设计"],"title":"c++(two)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/"},{"categories":["面向对象程序设计"],"content":"C++语言的语句 声明语句，表达式语句，选择语句，循环语句，跳转语句，复合语句，标号语句几类。 ","date":"2024-03-09","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/:26:1","tags":["面向对象程序设计"],"title":"c++(two)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/"},{"categories":["面向对象程序设计"],"content":"表达式与表达式语句的区别 表达式可以包含在其它表达式中，而语句不能。 注意 C++语言没有赋值语句也没有函数调用语句，赋值与函数调用功能都是通过表达式来实现的。 如果在赋值表达式后面加上分号，便成了语句。 数据的输入与输出 ","date":"2024-03-09","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/:26:2","tags":["面向对象程序设计"],"title":"c++(two)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/"},{"categories":["面向对象程序设计"],"content":"I/O流 ","date":"2024-03-09","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/:27:0","tags":["面向对象程序设计"],"title":"c++(two)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/"},{"categories":["面向对象程序设计"],"content":"流 在C++中，将数据从一个对象到另一个对象的流动抽象为“流” ","date":"2024-03-09","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/:27:1","tags":["面向对象程序设计"],"title":"c++(two)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/"},{"categories":["面向对象程序设计"],"content":"提取操作 从流中获取数据的操作称为提取操作 ","date":"2024-03-09","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/:27:2","tags":["面向对象程序设计"],"title":"c++(two)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/"},{"categories":["面向对象程序设计"],"content":"插入操作 向流中添加数据的操作称为插入操作 ","date":"2024-03-09","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/:27:3","tags":["面向对象程序设计"],"title":"c++(two)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/"},{"categories":["面向对象程序设计"],"content":"预定义的插入符和提取符 数据的输入和输出通过I/O流(stream)来实现 插入操作符“«” 预定义的流类对象cout cout用来处理标准输出，即屏幕输出格式：cout«表达式«表达式… 提取操作符“»” 预定义的流类对象：cin cin用来处理标准输入，即键盘输入 **格式：cin»表达式»表达式… ** 例： int x,y; cin\u003e\u003ex\u003e\u003ey; 从键盘上输入两个int型数，两数之间以空格分隔。 ","date":"2024-03-09","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/:28:0","tags":["面向对象程序设计"],"title":"c++(two)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/"},{"categories":["面向对象程序设计"],"content":"I/O标准流类 ","date":"2024-03-09","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/:29:0","tags":["面向对象程序设计"],"title":"c++(two)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/"},{"categories":["面向对象程序设计"],"content":"标准流的设备名 ","date":"2024-03-09","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/:29:1","tags":["面向对象程序设计"],"title":"c++(two)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/"},{"categories":["面向对象程序设计"],"content":"cout原理 cout是iostream流类的对象，它在iostream头文件中作为全局对象定义： ostream cout(stdout) 标准设备名作为其构造时的参数 ","date":"2024-03-09","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/:29:2","tags":["面向对象程序设计"],"title":"c++(two)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/"},{"categories":["面向对象程序设计"],"content":"cin原理 cin是istream全局对象 除了标准输入输出设备，还有标准错误设备cerr ","date":"2024-03-09","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/:29:3","tags":["面向对象程序设计"],"title":"c++(two)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/"},{"categories":["面向对象程序设计"],"content":"简单的I/O格式控制 流的默认格式输出有时不能满足特殊要求 希望显示的是9.40，即保留两位小数，可是却显示了9.40007；默认显示6位有效位 用控制符(manipulators)可以对I/O流1的格式进行控制 ","date":"2024-03-09","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/:30:0","tags":["面向对象程序设计"],"title":"c++(two)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/"},{"categories":["面向对象程序设计"],"content":"I/O流的常用控制符 ","date":"2024-03-09","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/:30:1","tags":["面向对象程序设计"],"title":"c++(two)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/"},{"categories":["面向对象程序设计"],"content":"I/O流的常用控制符(举例) **例：控制浮点数值显示 ** 设置值的输出宽度 除了使用空格来强制输出间隔外，还可以用setw(n)控制符。 如果一个值需要比setw(n)确定的字符数更多的字符，则该值将用它所需要的所有字符 超过setw(4)将会原样输出 如果一个值的字符比setw(n)确定的字符个数少，则在数字字符前显示空白。 若要每个数值都有宽度8，则每个值都要设置 输出8进制和16进制 3个常用的控制符是hex,oct和dec 这3个控制符在iostream.h头文件中定义 设置填充字符 用setfill控制符可以确定一个非空格的别的字符 setfill在头文件iomanip.h中定义 左右对齐输出 默认时，I/O流左对齐显示的内容。 使用头文件iomanip.h中的setiosflags(ios::left)可输出左对齐 使用头文件iomanip.h中的setiosflags(ios::right)可输出右对齐 强制显示小数 使用头文件iomanip.h中的setiosflags(ios::showpoint)可强制显示小数(后六位，包括小数点)以及显示正负号 ","date":"2024-03-09","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/:30:2","tags":["面向对象程序设计"],"title":"c++(two)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/"},{"categories":["面向对象程序设计"],"content":"算法的基本控制结构 顺序结构，分支结构，循环结构 ","date":"2024-03-09","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/:31:0","tags":["面向对象程序设计"],"title":"c++(two)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/"},{"categories":["面向对象程序设计"],"content":"if语句(多种形式) if语句(空语句) 编译器必须在if条件表达式的后面找到一个作为语句结束的分号“;”，以标志if语句的结束。 例： if(条件表达式)：//空语句做if中的语句 语句; 则不管条件表达式为真为假，总是接着执行语句 else if 语句 if语句(嵌套) 一般形式 c++ if() if() 语句1 else 语句2 else if() 语句3 else 语句4 注意 语句1，2，3，4可以是复合语句，每层的if与else配对，或用{}来确定层次关系 ","date":"2024-03-09","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/:31:1","tags":["面向对象程序设计"],"title":"c++(two)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/"},{"categories":["面向对象程序设计"],"content":"switch语句(特殊的多分支结构) 一般形式 特殊的多分支结构 执行顺序 以case中的常量表达式值为入口标号，由此开始顺序执行。因此，每个case分支最后应该加break语句 例：输入一个0~6的整数，转换成星期输出 #include\u003ciostream\u003e void main(void){ int day; cin\u003e\u003eday; switch(day){ case0:cout\u003c\u003c\"Sunday\"\u003c\u003cendl;break; case1:cout\u003c\u003c\"Monday\"\u003c\u003cendl;break; case2:cout\u003c\u003c\"Tuesday\"\u003c\u003cendl;break; case3:cout\u003c\u003c\"Wednesday\"\u003c\u003cendl;break; case4:cout\u003c\u003c\"Thursday\"\u003c\u003cendl;break; case5:cout\u003c\u003c\"Friday\"\u003c\u003cendl;break; case6:cout\u003c\u003c\"Saturday\"\u003c\u003cendl;break; default: cout\u003c\u003c\"Day out of range Sunday...Saturday\"\u003c\u003cendl;break; } } 使用switch语句应注意的问题 case分支可包含多个语句，且不用{}. switch语句后面的表达式，可以是整型，字符型，枚举型 各个常量表达式的值不能相同，但次序不影响执行结果 每个case分支的最后应该加break语句，用来结束整个switch结构 当若干分支需要执行相同操作时，可以使多个case分支共用一组语句 ","date":"2024-03-09","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/:31:2","tags":["面向对象程序设计"],"title":"c++(two)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/"},{"categories":["面向对象程序设计"],"content":"循环语句(while) 形式： while(条件表达式) 循环体 //可以是复合语句，其中必须含有改变条件表达式值的语句 执行顺序 先判断表达式的值，为true时，再执行循环体 组成 while循环由四部分组成：循环变量初始化，继续条件，循环体，改变循环变量的值。 例： #include\u003ciostream\u003e void main(){ inti(1),sum(0); //循环变量初始化 while(i\u003c=10) //继续条件 { //循环体 sum+=i; i++; //改变循环体变量的值 } cout\u003c\u003c\"sum=\"\u003c\u003csum\u003c\u003cendl; } do-while语句 一般形式 do //语句(可以是复合语句，其中必须含有改变条件表达式值的语句) while(条件表达式) 例：用2-7用do-while语句编程，求自然数1~10之和 #include\u003ciostream\u003e void main(){ int i(1),sum(0); do { sum+=i; i++; }while(i\u003c=10); cout\u003c\u003c\"sum=\"\u003c\u003csum\u003c\u003cendl; } do-while循环在循环的底部进行继续条件的测试，所以它至少执行一次循环体 while循环在循环的顶部进行测试，有可能永远不执行循环体 do-while循环中，while(条件表达式)后面的分号不要遗忘 ","date":"2024-03-09","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/:31:3","tags":["面向对象程序设计"],"title":"c++(two)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/"},{"categories":["面向对象程序设计"],"content":"for语句 语法形式 for(表达式1;表达式2;表达式3)语句 表达式1：循环先求解； 表达式2：循环控制条件，根据表达式2的值判断是否执行循环体，如果表达式2的值为true，则执行一次循环体；如果为false，则退出循环 表达式3：每执行一次循环体后，计算表达式3的值，然后再计算表达式2，根据表达式2的值决定是否继续执行循环体 表达式1，2，3都可以省略，分号不能省略 例：for(;;)语句 //相当于while(true)语句 表达式1一般用于给循环变量赋初值 表达式1可以省略.此时应在for语句之前给循环变量赋初值。若省略表达式1，其后的分号不能省略。 例：求和运算 i=1; for(;i\u003c=100;i++) //分号不能省略 sum+=i; for语句的几点说明 表达式2是循环控制条件，如省略，循环将无终止地进行下去。 例：求和运算 for(i=1;;i++){ //分号不能省略 sum+=i; if(i\u003e=100) break; } //等价于 for(i=1;1;i++){ sum+=i; if(i\u003e=100) break; } 表达式3一般用于改变循环控制条件的值. 如果表达式3省略或者是其他与循环条件无关的表达式，则应该在循环体中另有语句改变循环条件，以保证循环能正常结束。 例：求和运算 for(i=1;i\u003c=100) //分号不能省略 sum+=i++ //同时改变循环变量 表达式1和表达式3可同时省略 i=1; for(;i\u003c=100;) //分号不能省略 sum+=i++; //同时改变循环变量 表达式1和表达式3都为逗号表达式； for(i=0,j=100,k=0;i\u003c=j;i++,j--) k+=i*j; 表达式2和表达式3可以为赋值或算术表达式的情况； for(i=1;i\u003c=100;sum+=i++); //循环为空语句 for(i=1;sum+=i++,i\u003c=100;); //表达式3省略，循环为空语句 ","date":"2024-03-09","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/:31:4","tags":["面向对象程序设计"],"title":"c++(two)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/"},{"categories":["面向对象程序设计"],"content":"循环结构的嵌套 #include\u003ciostream\u003e void mian(){ int i(1),a(0); for(;i\u003c=5;i++){ do{ i++; a++; }while(i\u003c3); i++; } cout\u003c\u003ca\u003c\u003c\",\"\u003c\u003ci\u003c\u003cendl; } 循环结构与选择结构相互嵌套 #include\u003ciostream\u003e void main(){ int n; for(n=100;n\u003c=200;n++){ if(n%3!=0) printf(\"%d\",n); } } ","date":"2024-03-09","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/:31:5","tags":["面向对象程序设计"],"title":"c++(two)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/"},{"categories":["面向对象程序设计"],"content":"break和continue语句 break语句: 用在while,do-while,for和switch结构中在switch语句中，break使流程跳出switch语句中，break使流程跳出switch语句，继续执行switch后的语句在循环语句中，break用来从最近的封闭循环体中跳出 continue语句： 结束本次循环，接着判断是否执行下一次循环 区别 continue语句只结束本次循环；而不是终止整个循环的执行 break语句则是结束本次循环，不再进行条件判断。在循环语句中，break用来从最近的封闭循环体中跳出 ","date":"2024-03-09","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/:31:6","tags":["面向对象程序设计"],"title":"c++(two)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/"},{"categories":["面向对象程序设计"],"content":"自定义数据类型(typedef声明) 为一个已有的数据类型另外命名 语法形式 typedef 已有类型名 新类型名表; 例如： typedef double area,volume; typedef int natural; natural i1,i2; area a; volume v; ","date":"2024-03-09","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/:32:0","tags":["面向对象程序设计"],"title":"c++(two)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/"},{"categories":["面向对象程序设计"],"content":"枚举类型 只要将需要的变量值一一列举出来便构成了一个枚举类型 枚举类型的声明形式： enum 枚举类型名 {变量值列表}; 例如： enum weekday {sun,mon,tue,wed,thu,fri,sat}; 注：整数值不能直接赋给枚举变量，如需要将整数赋值给枚举变量，应进行强制类型转换 #include\u003ciostream\u003e using namespace std; enum game_result{WIN,LOSE,TIE,CANCEL}; void main(){ game_result result; //声明变量时，可以不写关键字enum enum game_result omit=CANCEL; //也可以在类型名前写enum int count; for(count=WIN;count\u003c=CANCEL;count++){ result=(game_result)count; //强制类型转换，小类型可以转大类型，大类型转小类型必须要强制转换 if(result==omit){ cout\u003c\u003c\"The game was cancelled\\n\"; } else{ cout\u003c\u003c\"The game was played\"; if(result==WIN) cout\u003c\u003c\"and we won\"; if(result==LOSE) cout\u003c\u003c\"and we lose\"; cout\u003c\u003c\"\\n\"; } } } ","date":"2024-03-09","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/:32:1","tags":["面向对象程序设计"],"title":"c++(two)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/"},{"categories":["面向对象程序设计"],"content":"结构体(结构体的声明) 概念：结构是由不同的数据类型的数据组成的 声明结构体类型 struct 结构名{ 数据类型 成员名1； 数据类型 成员名2； . . 数据类型 成员名3； }; 例：结构体变量的初始化和使用 #include\u003ciostream\u003e #include\u003ciomanip\u003e struct student{ //学生信息结构体 int num; char name[20]; char sex; int age; }stu={97001,\"LinLin\",'F',19}; //在定义结构体的同时，生命结构类型的变量stu void main(){ cout\u003c\u003csetw(7)\u003c\u003cstu,num\u003c\u003csetw(10)\u003c\u003cstu.name\u003c\u003cset(3)\u003c\u003cstu.sex \u003c\u003csetw(3)\u003c\u003cstu.age\u003c\u003cendl; } ","date":"2024-03-09","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/:33:0","tags":["面向对象程序设计"],"title":"c++(two)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/"},{"categories":["面向对象程序设计"],"content":"结构体(结构变量说明) 变量说明形式 结构名 结构变量名； 注意： 结构变量的存储类型概念，它的寿命，可见性及使用范围与普通变量完全一致 结构变量说明在结构类型声明之后，二者也可同时进行 结构变量占用内存大小可用sizeof运算求出：sizeof(类型名) 说明结构变量的同时可以直接设置初值 在定义结构体类型的同时声明变量 struct student{ //学生信息结构体 int num; char name[20]; char sex; int age; float score; char addr[30]; }stu1,stu2; 直接定义变量 struct //省略结构体名称 { int num; char name[20]; char sex; int age; float score; char addr[30]; }stu1,stu2; 用typedef关键字给结构体取个别名 typedef struct student //学生信息结构 { int num; char name[20]; char sex; int age; float score; char addr[30]; }postgraduate; 定义2个struct student 类型的变量 postgraduate stu1,stu2 可以先定义结构体类型，然后取别名 struct student //学生信息结构 { ..... } typedef struct student postgraduate; 也可以省略结构体名称student typedef struct //学生信息结构体 { ..... }postgraduate; 下面几种情况要分清楚 struct student //student是类型名 { ..... }; typedef struct { ..... }postgraduate; //postgraduate是类型名 typedef student postgraduate //postgraduate是类型名 struct{ .... }stu; //stu是变量名 struct student //student是类型名 { ..... }stu; //stu是变量名 struct student stu; //stu是变量名 typedef struct student{ //student是类型名 ... }STUDENT; //STUDENT是类型名，是student的别名 ","date":"2024-03-09","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/:33:1","tags":["面向对象程序设计"],"title":"c++(two)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/"},{"categories":["面向对象程序设计"],"content":"结构体(结构变量的初始化和使用) 初始化 说明结构变量的同时可以直接设置初值。 struct student stu={97001,\"李明\",'M',16,92,\"北京市\"} 但一定要注意，不能在定义结构体类型的时候，进行赋初值 struct student //下面的做法是错误的 { int num =97001; char name[20] = “Li Lin”; char sex= “M”; int age = 16; float score = 92; char addr[30] = “123 Bejing Road”; }stu 使用(访问结构成员) 结构体成员的引用形式 结构变量名.成员名 例如： cout\u003c\u003cstu.num\u003c\u003c\",\"\u003c\u003cstu.name\u003c\u003c\",\"\u003c\u003cstu.sex\u003c\u003c\",\"\u003c\u003cstu.age \u003c\u003c\",\"\u003c\u003cstu.score\u003c\u003c\",\"\u003c\u003cstu.addr; 下面这些写法都是错误的 1.strcpy(student.name,\"wangli\"); //student是结构体类型名，不是结构体变量 2.stu.book=6 //结构体student中没有定义\"book\"这个成员 初始化结构体部分成员 使用赋值语句对它们进行初始化了。 例如： stu . Num = 97001; strcpy(stu . name, “李明”); stu . sex = ‘M’; stu . age = 16; stu . score = 91; strcpy(stu . addr, “北京”); 当然，使用输入语句也可以实现部分结构体成员的初始化 例： cin\u003e\u003estu.Age; 把结构体变量当作整体赋值 结构体变量整体赋值 例： stu2 = stu1; //通过这种模式，可以直接完成结构体之间的赋值 去结构体变量地址 例： cout\u003c\u003c\u0026stu1; //输出stu1的地址 cin\u003e\u003estu1.Age; //输入stu1的年龄 需要注意，不能把结构体变量整体输入进来 例： cin\u003e\u003estu1; //错误 逐级访问成员 #include\u003ciostream\u003e struct student //学生信息结构体 { int num; char name[20]; char sex; struct date { int month; int day; int year; }birthday; float score; char addr[30]; }stu; //对成员进行逐级访问 void main(){ stu.birthday.month=9; stu.birthday . day = 20; stu.birthday . year = 1996; cout\u003c\u003cstu.birthday .month\u003c\u003c\"/ \" \u003c\u003cstu.birthday . day\u003c\u003c\"/ \" \u003c\u003cstu.birthday . year\u003c\u003cendl; } 说明结构变量的同时可以直接设置初值 #include \u003ciostream.h\u003e #include \u003ciomanip.h\u003e struct student //学生信息结构体 { int num; //学号 char name[20]; //姓名 char sex; //性别 int age; //年龄 float score; //成绩 char addr[30]; //住址 }stu={97001,“李明”,‘F’,19, “北京“}; void main() { cout\u003c\u003csetw(7)\u003c\u003cstu.num\u003c\u003csetw(20) \u003c\u003cstu.name\u003c\u003csetw(3)\u003c\u003cstu.sex\u003c\u003csetw(3) \u003c\u003cstu.age \u003c\u003csetw(7) \u003c\u003cstu.addr\u003c\u003cendl; } ","date":"2024-03-09","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/:33:2","tags":["面向对象程序设计"],"title":"c++(two)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/"},{"categories":["面向对象程序设计"],"content":"联合体 声明形式 union 联合名 { 数据类型 成员名1; 数据类型 成员名2; . . 数据类型 成员名n; }; 联合体类型变量说明的语法形式 联合名 联合名变量; 引用形式 联合变量名.成员名 例： union uarea { char c_data; short s_data; long l_data; } 联合体可以不声明名称 例：声明无名联合体 union{ int i; float f; } 无名联合体通常作结构体的内嵌成员 例：适用于描述战斗机，轰炸机，运输机的结构体 # include \u003ciostream.h\u003e struct aircraft { int wingspan ; //翼幅 int passengers ; //乘客 union //无名联合作为结构体的内嵌成员 { float fuel _load; //战斗机装载的燃料 float bomb _load; //轰炸机装载的燃料 int pallets ; //运输机的货盘 }; } fighter,bomber,transport ; int main( ) { fighter . wingspan = 40 ; fighter . passengers = 1; fighter . fuel_load = 12000.0 ; bomber . wingspan = 90 ; bomber . passengers = 12; bomber . bomb_load = 14000.0 ; transport . wingspan = 106 ; transport . passengers = 4; transport .pallets = 42 ; transport . fuel_load = 18000.0 ; fighter . pallets = 4 ; cout\u003c\u003c“The fighter carries”\u003c\u003cfighter . Pallets\u003c\u003c“pallets.\\n”; cout\u003c\u003c“The bomber bomb load is”\u003c\u003cbomber . bomb_load\u003c\u003c“\\n”; return 0 ; } 运行结果 The fighter carries 4 pallets. The bomber bomb load is 14000 ","date":"2024-03-09","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/:34:0","tags":["面向对象程序设计"],"title":"c++(two)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/"},{"categories":["面向对象程序设计"],"content":"联合体类型的特点 从同一地址开始，将几个不同类型的变量存放到同一段内存单元中 同一个内存段可以用来存放几种不同类型的成员，但在每一瞬间只能存放其中一种，而不是同时存放几种。即每一瞬时只有一个成员起作用，其他成员不起作用 联合体变量中起作用的成员是最后一次存放的成员，在存入一个新的成员后原成员就失去作用。 ","date":"2024-03-09","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/:34:1","tags":["面向对象程序设计"],"title":"c++(two)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A12/"},{"categories":["hugo"],"content":"用Hugo配合Algolia实现高效美观的站内搜索 ","date":"2024-03-09","objectID":"/posts/%E7%94%A8hugo%E9%85%8D%E5%90%88algolia%E5%AE%9E%E7%8E%B0%E9%AB%98%E6%95%88%E7%BE%8E%E8%A7%82%E7%9A%84%E7%AB%99%E5%86%85%E6%90%9C%E7%B4%A2/:0:0","tags":["hugo"],"title":"用Hugo配合Algolia实现高效美观的站内搜索","uri":"/posts/%E7%94%A8hugo%E9%85%8D%E5%90%88algolia%E5%AE%9E%E7%8E%B0%E9%AB%98%E6%95%88%E7%BE%8E%E8%A7%82%E7%9A%84%E7%AB%99%E5%86%85%E6%90%9C%E7%B4%A2/"},{"categories":["hugo"],"content":"前言 很多的 Hugo 主题是没有自带搜索功能的，但是们为了方便用户浏览和查找内容是需要在网站上提供搜索功能。大家可以查看 Hugo 官方推荐的搜索方案，这里我选择的是 Algolia ， 折腾了很久，主题也从EVEN更新到了现在的LOVEIT，发现也并非很繁琐，以下是折腾后的成果。 ","date":"2024-03-09","objectID":"/posts/%E7%94%A8hugo%E9%85%8D%E5%90%88algolia%E5%AE%9E%E7%8E%B0%E9%AB%98%E6%95%88%E7%BE%8E%E8%A7%82%E7%9A%84%E7%AB%99%E5%86%85%E6%90%9C%E7%B4%A2/:1:0","tags":["hugo"],"title":"用Hugo配合Algolia实现高效美观的站内搜索","uri":"/posts/%E7%94%A8hugo%E9%85%8D%E5%90%88algolia%E5%AE%9E%E7%8E%B0%E9%AB%98%E6%95%88%E7%BE%8E%E8%A7%82%E7%9A%84%E7%AB%99%E5%86%85%E6%90%9C%E7%B4%A2/"},{"categories":["hugo"],"content":"在Algolia 端创建应用和索引 ","date":"2024-03-09","objectID":"/posts/%E7%94%A8hugo%E9%85%8D%E5%90%88algolia%E5%AE%9E%E7%8E%B0%E9%AB%98%E6%95%88%E7%BE%8E%E8%A7%82%E7%9A%84%E7%AB%99%E5%86%85%E6%90%9C%E7%B4%A2/:2:0","tags":["hugo"],"title":"用Hugo配合Algolia实现高效美观的站内搜索","uri":"/posts/%E7%94%A8hugo%E9%85%8D%E5%90%88algolia%E5%AE%9E%E7%8E%B0%E9%AB%98%E6%95%88%E7%BE%8E%E8%A7%82%E7%9A%84%E7%AB%99%E5%86%85%E6%90%9C%E7%B4%A2/"},{"categories":["hugo"],"content":"Application 点击NEW APPLICATION，Name可选，方案选择FREE，然后创建，随后的地区选择邻近地区即可； ","date":"2024-03-09","objectID":"/posts/%E7%94%A8hugo%E9%85%8D%E5%90%88algolia%E5%AE%9E%E7%8E%B0%E9%AB%98%E6%95%88%E7%BE%8E%E8%A7%82%E7%9A%84%E7%AB%99%E5%86%85%E6%90%9C%E7%B4%A2/:2:1","tags":["hugo"],"title":"用Hugo配合Algolia实现高效美观的站内搜索","uri":"/posts/%E7%94%A8hugo%E9%85%8D%E5%90%88algolia%E5%AE%9E%E7%8E%B0%E9%AB%98%E6%95%88%E7%BE%8E%E8%A7%82%E7%9A%84%E7%AB%99%E5%86%85%E6%90%9C%E7%B4%A2/"},{"categories":["hugo"],"content":"Indices \u0026 Index 点击侧栏的Indices，然后点击Create Index，Index name自定义（例如自己的域名） ","date":"2024-03-09","objectID":"/posts/%E7%94%A8hugo%E9%85%8D%E5%90%88algolia%E5%AE%9E%E7%8E%B0%E9%AB%98%E6%95%88%E7%BE%8E%E8%A7%82%E7%9A%84%E7%AB%99%E5%86%85%E6%90%9C%E7%B4%A2/:2:2","tags":["hugo"],"title":"用Hugo配合Algolia实现高效美观的站内搜索","uri":"/posts/%E7%94%A8hugo%E9%85%8D%E5%90%88algolia%E5%AE%9E%E7%8E%B0%E9%AB%98%E6%95%88%E7%BE%8E%E8%A7%82%E7%9A%84%E7%AB%99%E5%86%85%E6%90%9C%E7%B4%A2/"},{"categories":["hugo"],"content":"API Keys 点击侧栏API Keys，记住以下的 Keys，之后都会用到； ","date":"2024-03-09","objectID":"/posts/%E7%94%A8hugo%E9%85%8D%E5%90%88algolia%E5%AE%9E%E7%8E%B0%E9%AB%98%E6%95%88%E7%BE%8E%E8%A7%82%E7%9A%84%E7%AB%99%E5%86%85%E6%90%9C%E7%B4%A2/:2:3","tags":["hugo"],"title":"用Hugo配合Algolia实现高效美观的站内搜索","uri":"/posts/%E7%94%A8hugo%E9%85%8D%E5%90%88algolia%E5%AE%9E%E7%8E%B0%E9%AB%98%E6%95%88%E7%BE%8E%E8%A7%82%E7%9A%84%E7%AB%99%E5%86%85%E6%90%9C%E7%B4%A2/"},{"categories":["hugo"],"content":"在本地生成索引 ","date":"2024-03-09","objectID":"/posts/%E7%94%A8hugo%E9%85%8D%E5%90%88algolia%E5%AE%9E%E7%8E%B0%E9%AB%98%E6%95%88%E7%BE%8E%E8%A7%82%E7%9A%84%E7%AB%99%E5%86%85%E6%90%9C%E7%B4%A2/:3:0","tags":["hugo"],"title":"用Hugo配合Algolia实现高效美观的站内搜索","uri":"/posts/%E7%94%A8hugo%E9%85%8D%E5%90%88algolia%E5%AE%9E%E7%8E%B0%E9%AB%98%E6%95%88%E7%BE%8E%E8%A7%82%E7%9A%84%E7%AB%99%E5%86%85%E6%90%9C%E7%B4%A2/"},{"categories":["hugo"],"content":"config.yaml 在themes同级添加config.yaml文件,注意这里的key是Admin API Key。 --- baseurl: \"https://www.adan-ning.github.io\" DefaultContentLanguage: \"zh-cn\" hasCJKLanguage: true languageCode: \"zh-cn\" title: \"lqx's blog\" theme: \"loveit\" metaDataFormat: \"yaml\" algolia: index: \"**blogloveit\" key: \"*****9748e4cf6b\" appID: \"***KWB5\" --- ","date":"2024-03-09","objectID":"/posts/%E7%94%A8hugo%E9%85%8D%E5%90%88algolia%E5%AE%9E%E7%8E%B0%E9%AB%98%E6%95%88%E7%BE%8E%E8%A7%82%E7%9A%84%E7%AB%99%E5%86%85%E6%90%9C%E7%B4%A2/:3:1","tags":["hugo"],"title":"用Hugo配合Algolia实现高效美观的站内搜索","uri":"/posts/%E7%94%A8hugo%E9%85%8D%E5%90%88algolia%E5%AE%9E%E7%8E%B0%E9%AB%98%E6%95%88%E7%BE%8E%E8%A7%82%E7%9A%84%E7%AB%99%E5%86%85%E6%90%9C%E7%B4%A2/"},{"categories":["hugo"],"content":"hugo-aligolia 我们这里使用一个hugo-algolia的插件来完成我们的数据同步工作,要安装hugo-aligolia我们需要先确保我们已经安装了 npm 或者 yarn 包管理工具。 使用下面的命令安装即可： $ npm install hugo-algolia -g 配置完成以后，在根目录下面执行下面的命令： $ hugo-algolia -s JSON index file was created in public/algolia.json { updatedAt: '2020-01-23T02:36:09.480Z', taskID: 249063848950 } 这个时候我们在 dashboard 中打开 Indices，可以看到已经有几十条数据了。 如果某篇文章不想被索引的话，我们只需要在文件的最前面设置 index 参数为 false 即可。 ","date":"2024-03-09","objectID":"/posts/%E7%94%A8hugo%E9%85%8D%E5%90%88algolia%E5%AE%9E%E7%8E%B0%E9%AB%98%E6%95%88%E7%BE%8E%E8%A7%82%E7%9A%84%E7%AB%99%E5%86%85%E6%90%9C%E7%B4%A2/:3:2","tags":["hugo"],"title":"用Hugo配合Algolia实现高效美观的站内搜索","uri":"/posts/%E7%94%A8hugo%E9%85%8D%E5%90%88algolia%E5%AE%9E%E7%8E%B0%E9%AB%98%E6%95%88%E7%BE%8E%E8%A7%82%E7%9A%84%E7%AB%99%E5%86%85%E6%90%9C%E7%B4%A2/"},{"categories":["hugo"],"content":"hugo.toml文件配置 配置结束后，就可以使用Algolia 的搜索功能 ","date":"2024-03-09","objectID":"/posts/%E7%94%A8hugo%E9%85%8D%E5%90%88algolia%E5%AE%9E%E7%8E%B0%E9%AB%98%E6%95%88%E7%BE%8E%E8%A7%82%E7%9A%84%E7%AB%99%E5%86%85%E6%90%9C%E7%B4%A2/:4:0","tags":["hugo"],"title":"用Hugo配合Algolia实现高效美观的站内搜索","uri":"/posts/%E7%94%A8hugo%E9%85%8D%E5%90%88algolia%E5%AE%9E%E7%8E%B0%E9%AB%98%E6%95%88%E7%BE%8E%E8%A7%82%E7%9A%84%E7%AB%99%E5%86%85%E6%90%9C%E7%B4%A2/"},{"categories":["计算机组成原理"],"content":"计算机组成部分 运算器，控制器，存储器，输入/输出设备 概念 计算机是一种以电子器件为基础的，不需人的直接干预，能够对各种数字化信息，进行算术和逻辑运算的快速工具 层次 ","date":"2024-03-09","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/:0:0","tags":["计算机组成原理"],"title":"计算机组成(第一章)","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"},{"categories":["计算机组成原理"],"content":"电子数字计算机 以电子器件为物质基础 ","date":"2024-03-09","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/:1:0","tags":["计算机组成原理"],"title":"计算机组成(第一章)","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"},{"categories":["计算机组成原理"],"content":"自动化 不需要人的直接干预 ","date":"2024-03-09","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/:2:0","tags":["计算机组成原理"],"title":"计算机组成(第一章)","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"},{"categories":["计算机组成原理"],"content":"数字化信息 二进制 ","date":"2024-03-09","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/:3:0","tags":["计算机组成原理"],"title":"计算机组成(第一章)","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"},{"categories":["计算机组成原理"],"content":"算逻运算 基本运算操作是算术和逻辑运算 ","date":"2024-03-09","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/:4:0","tags":["计算机组成原理"],"title":"计算机组成(第一章)","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"},{"categories":["计算机组成原理"],"content":"快速工具 电子器件 存储程序 特征 ","date":"2024-03-09","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/:5:0","tags":["计算机组成原理"],"title":"计算机组成(第一章)","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"},{"categories":["计算机组成原理"],"content":"内部特征 高速高集成开关元件 数字化信息编码 逻辑判断和处理能力 存储程序 ","date":"2024-03-09","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/:6:0","tags":["计算机组成原理"],"title":"计算机组成(第一章)","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"},{"categories":["计算机组成原理"],"content":"外部特征 快速性(由内部特征中1，4决定) 准确性(由内部特征中2，4决定) 逻辑性(由内部特征中1，3，4决定) 通用性(由内部特征中1，2，3，4决定) 分类 模拟计算机和数字计算机 ","date":"2024-03-09","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/:7:0","tags":["计算机组成原理"],"title":"计算机组成(第一章)","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"},{"categories":["计算机组成原理"],"content":"各自特点 ","date":"2024-03-09","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/:8:0","tags":["计算机组成原理"],"title":"计算机组成(第一章)","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"},{"categories":["计算机组成原理"],"content":"区别(图) 应用 科学计算 教育和卫生 自动控制和测量 家用电器 信息处理 人工智能 计算机的硬件系统组成 指令字和数据字，指令流和数据流 指令字 某字为一条指令 数据字 某字代表要处理的数据 指令流 在取指周期中从内存读出的信息，它流向控制器 数据流 而执行周期中从内存读出的信息，它由内存流向运算器 ","date":"2024-03-09","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/:9:0","tags":["计算机组成原理"],"title":"计算机组成(第一章)","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"},{"categories":["计算机组成原理"],"content":"时间上 在取指周期中，CPU从内存读出的信息一定是指令；而执行周期中从内存读出或写入的信息一定是数据 ","date":"2024-03-09","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/:10:0","tags":["计算机组成原理"],"title":"计算机组成(第一章)","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"},{"categories":["计算机组成原理"],"content":"空间上 指令一定流向控制器；而数据则是在内存(或寄存器)与运算器之间流动 系统总线 总线 传递信息的一组公用导线，信息通道 系统总线 微机系统中信息交换的主要公共通道 地址总线 单向输出主存单元或I/O端口的地址信息 数据总线 读(Read)操作数据输入微处理器；写(Write)操作数据输出到外界(主存或外设) 控制总线 有些控制信号或状态信号；有些请求或联络信号输入 微机系统采用总线结构，总线连接使得微机组合灵活，扩展方便 ","date":"2024-03-09","objectID":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/:11:0","tags":["计算机组成原理"],"title":"计算机组成(第一章)","uri":"/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"},{"categories":["面向对象程序设计"],"content":"计算机程序 ","date":"2024-03-08","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/:0:0","tags":["面向对象程序设计"],"title":"c++(one)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"},{"categories":["面向对象程序设计"],"content":"面向对象的方法 抽象 分类所依据的原则 忽略事物的非本质特征，从而找出事物的共性，把具有共同性质的事物划分为一类，得出一个抽象的概念 封装 把对象的属性和行为结合成一个独立的系统单位 尽可能隐藏对象的内部细节。对外形成一个边界(或屏障)，只保留有限的对外接口使之与外部发生联系 继承(多继承) 特殊类的对象拥有其一般类的全部属性与行为 多态 在一般类中定义的属性或行为，被特殊类继承之后，可以具有不同的数据类型或表现出不同的行为。这使得同一个属性或行为在一般类及其各个特殊类中具有不同的语义 ","date":"2024-03-08","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/:1:0","tags":["面向对象程序设计"],"title":"c++(one)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"},{"categories":["面向对象程序设计"],"content":"类和对象 对象：将数据及对数据的操作方法封装在一起，做为一个互相依存，不可分离的整体 对象与对象之间通过消息通讯 类：对同类型对象抽象出其共性 类通过一个简单的外部接口，与外界发生关系 一般意义上的对象 是现实世界中一个实际存在的事物，可以是有形的(如：一辆汽车)，也可以是无形的(如：一项计划) 是构成世界的一个独立单位，具有： **静态特征:**可以用某种数据描述 **动态特征:**对象所表现的行为或具有的功能 类与对象的关系 就如模具与铸件之间的关系，一个属于某类的对象称为该类的一个实例 ","date":"2024-03-08","objectID":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/:2:0","tags":["面向对象程序设计"],"title":"c++(one)","uri":"/posts/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"},{"categories":["编译原理"],"content":"高级语言的定义 ","date":"2024-03-06","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%862/:0:0","tags":["编译原理"],"title":"编译引论(第二章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%862/"},{"categories":["编译原理"],"content":"语法 任何高级语言程序都可以看成是一个特定字母表(即元素的非空有穷集合)上的一个字符串(有穷序列) ","date":"2024-03-06","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%862/:1:0","tags":["编译原理"],"title":"编译引论(第二章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%862/"},{"categories":["编译原理"],"content":"词法规则 指单词符号的形成规则，它确定语言的单词符号，单词符号一般包括：标识符，保留字，界符，算符等 ","date":"2024-03-06","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%862/:2:0","tags":["编译原理"],"title":"编译引论(第二章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%862/"},{"categories":["编译原理"],"content":"语法规则 从单词符号形成更大的结构(即语法单位)，它是语法单位的形成规则，一般语法单位有：表达式，语句，函数，程序等 ","date":"2024-03-06","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%862/:3:0","tags":["编译原理"],"title":"编译引论(第二章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%862/"},{"categories":["编译原理"],"content":"语义 定义它的单词符号和语法单位的意义 所谓一个语言的语义是指这样的一组规则，使用它可以定义一个程序的意义 文法和语言 ","date":"2024-03-06","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%862/:4:0","tags":["编译原理"],"title":"编译引论(第二章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%862/"},{"categories":["编译原理"],"content":"基本概念 ","date":"2024-03-06","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%862/:5:0","tags":["编译原理"],"title":"编译引论(第二章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%862/"},{"categories":["编译原理"],"content":"字母表 字母表：元素的非空有穷集合，习惯上用大写字母表示，如 ∑ ={a,b} 符号:字母表中的每一个元素，如a,b; ","date":"2024-03-06","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%862/:5:1","tags":["编译原理"],"title":"编译引论(第二章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%862/"},{"categories":["编译原理"],"content":"符号串 符号串:字母表中的符号的有穷序列，如 a,b,aa,bb….。 空符号串：不含任何符号的符号串，记为ε 符号串集合：字母表∑上的符号串组成的集合。 ","date":"2024-03-06","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%862/:5:2","tags":["编译原理"],"title":"编译引论(第二章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%862/"},{"categories":["编译原理"],"content":"符号串运算 符号串长度：符号串中所包含的符号个数。设符号串为x,则其长度记为|x|。 符号串连接:设有符号串x和y，把y的所有符号相继写在x的符号串之后所得到的符号串即称为x和y的连接，记为xy 例：εx=xε=x 符号串的方幂：设x的符号串，则x的n次连接称为n次方幂，记为xn。 例：$x^0$=ε 符号串的前缀，后缀，子串 假设x是一个符号串，则有： 符号串x的前缀是指：从符号串x的尾部删除若干(含0个)符号后得到的符号串； 符号串x的后缀是指：从符号串x的头部删除若干(含0个)符号后得到的符号串： 符号串x的子串是指：删除了x前缀(或删除x的后缀或删除x的前缀和后缀)后得到的符号串； 对任意的符号串x，x的前缀，后缀都是x的子串，但x的子串不一定是x的前缀或后缀。 对任意的符号串x，x和ε都是符号串x的前缀，后缀，也是x的子串。 ","date":"2024-03-06","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%862/:5:3","tags":["编译原理"],"title":"编译引论(第二章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%862/"},{"categories":["编译原理"],"content":"符号串集合的运算 符号串的集合的乘积 设A，B为符号串集合，则符号串集合的乘积表示为AB={xy|x∈A,y∈B},即A中的任意符号串和B中的任意符号串的连接所构成的集合。 以为有 xε=εx=x,所以有{ε}A={ε}A=A 注：∅A= A∅ =∅ 符号串集合的方幂：即同一个符号串集合的乘积。 例：设A为符号串集合，则 $A^0$={ε} , $A^1$=A, $A^2$=AA,….. ","date":"2024-03-06","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%862/:6:0","tags":["编译原理"],"title":"编译引论(第二章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%862/"},{"categories":["编译原理"],"content":"符号串集合的闭包 ","date":"2024-03-06","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%862/:7:0","tags":["编译原理"],"title":"编译引论(第二章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%862/"},{"categories":["编译原理"],"content":"星闭包 设A为符号串集合，则$A^*$为符号串集合A的星闭包。具体定义如下： $A^*=A^0\\bigcup$$A^1$$\\bigcup$$A^2$$\\bigcup$$A^3$$\\bigcup$….. ","date":"2024-03-06","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%862/:7:1","tags":["编译原理"],"title":"编译引论(第二章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%862/"},{"categories":["编译原理"],"content":"正闭包 设A为符号串集合，则$A^+$为符号串集合A的正闭包。具体定义如下： $A^+=A^0\\bigcup$$A^1$$\\bigcup$$A^2$$\\bigcup$$A^3$$\\bigcup$….. **由上述两个定义，显然有 :$A^+$ $=$ $AA^*$ ** ","date":"2024-03-06","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%862/:7:2","tags":["编译原理"],"title":"编译引论(第二章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%862/"},{"categories":["编译原理"],"content":"文法及文法的BNF表示 ","date":"2024-03-06","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%862/:8:0","tags":["编译原理"],"title":"编译引论(第二章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%862/"},{"categories":["编译原理"],"content":"规则 即产生式，是一有序对(U，ⅹ)，通常记为： U→x(或U::x) ","date":"2024-03-06","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%862/:8:1","tags":["编译原理"],"title":"编译引论(第二章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%862/"},{"categories":["编译原理"],"content":"文法和字汇表 文法可以定义成一个四元组G=($V_N$,$V_T$,S,P) $V_N$:一个非空有限的非终结符号集合 $V_T$:一个非空有限的终结符号集合 S:文法的开始符号，它是一个特殊的非终结符号 P:产生式的有限集合 例如： ","date":"2024-03-06","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%862/:9:0","tags":["编译原理"],"title":"编译引论(第二章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%862/"},{"categories":["编译原理"],"content":"文法的BNF(巴科斯范式)表示 为了书写简洁，常常把左部相同的规则缩写在一起，使其结构更加紧凑，在规则中引入符号\"|\",以表示“或者”。形如$S\\rightarrow$$a_1$,$S\\rightarrow$$a_2$,….,$S\\rightarrow$$a_n$,缩写为$S\\rightarrow$$a_1$|$a_2$|….|$a_n$,每个$a_i$被称为S的一个候选式 因此，上述例子的文法还可以写成： ","date":"2024-03-06","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%862/:9:1","tags":["编译原理"],"title":"编译引论(第二章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%862/"},{"categories":["编译原理"],"content":"递归规则及递归文法 ","date":"2024-03-06","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%862/:10:0","tags":["编译原理"],"title":"编译引论(第二章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%862/"},{"categories":["编译原理"],"content":"递归规则 指那些在规则的右部含有与规则左部相同符号的规则，例如，$U\\rightarrow$$xUy$,右部含有与规则左部相同部分符号U，这就是递归规则 如果这个相同符号出现在右部的最左端，则为左递归规则，例如:$U\\rightarrow$$Uy$ 如果这个相同符号出现在左部的最右端，则为右递归规则，例如:$U\\rightarrow$$xU$ ","date":"2024-03-06","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%862/:10:1","tags":["编译原理"],"title":"编译引论(第二章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%862/"},{"categories":["编译原理"],"content":"递归文法 若文法中至少包含一条递归规则，则称文法是直接递归的 例如： 算术表达式G[E]: $E\\rightarrow$$E+T|T$ $T\\rightarrow$$T*F|F$ $F\\rightarrow$$(E)|i$ 显然，该文法就是一个直接递归文法 ","date":"2024-03-06","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%862/:10:2","tags":["编译原理"],"title":"编译引论(第二章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%862/"},{"categories":["编译原理"],"content":"推导和归约 ","date":"2024-03-06","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%862/:11:0","tags":["编译原理"],"title":"编译引论(第二章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%862/"},{"categories":["编译原理"],"content":"直接推导 设$\\alpha\\rightarrow$$\\beta$是文法$G=(V_N,V_T,S,P)$的产生式，$\\gamma$和$\\delta \\in (V_N \\bigcup V_T)^*$,若有符号串v,w满足： $v=\\gamma\\alpha\\delta$，$w=\\gamma\\beta\\delta$ 则称v(利用规则$\\alpha\\rightarrow\\beta$)直接推出w，或则说w是v的直接推导，记作:$v\\Rightarrow w$. 归约是推导的逆过程，若$v\\Rightarrow w$,也可以说w直接规约到v ","date":"2024-03-06","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%862/:11:1","tags":["编译原理"],"title":"编译引论(第二章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%862/"},{"categories":["编译原理"],"content":"长度为n的推导 如果存在直接推导的序列:$v=w_0\\Rightarrow w_1\\Rightarrow …. \\Rightarrow w_n = w (n\\geq1)$，则说v经过n步(n\u003e0)推导出w，记作：$v\\stackrel{+}\\Rightarrow w$。“$\\stackrel{+}\\Rightarrow$”表示多步直接推导。 若有$v\\stackrel{+}\\Rightarrow w$,或v=w(n=0),则说v经过n($n\\geq 0$)步推导出w，记作：$v\\stackrel{}\\Rightarrow w$。“$\\stackrel{}\\Rightarrow$”表示0步或多步直接推导。 ","date":"2024-03-06","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%862/:11:2","tags":["编译原理"],"title":"编译引论(第二章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%862/"},{"categories":["编译原理"],"content":"最左推导和最右推导 若在推导过程中，每一步总是对当前符号串最左(右)边的非终结符号进行替换，称为最左(右)推导。如果文法G是无二义的，那么最右推导的逆过程为最左归约，最有推导为规范推导，最左规约为规范归约。 ","date":"2024-03-06","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%862/:11:3","tags":["编译原理"],"title":"编译引论(第二章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%862/"},{"categories":["编译原理"],"content":"句型，句子和语言 ","date":"2024-03-06","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%862/:12:0","tags":["编译原理"],"title":"编译引论(第二章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%862/"},{"categories":["编译原理"],"content":"句型，句子 定义 设G[S]是文字表V上的一个文法，如果符号串u是由文法的开始符号推导出来的，则称u是文法G[S]的句型。如果u仅由终结符号组成，则称u是文法G[S]的句子 即： 若$S\\stackrel{}\\Rightarrow u$，$u\\in V^$，则称u是文法G[S]的句型； 若$S\\stackrel{+}\\Rightarrow u$，$u \\in V_T^*$，则称u是文法G[S]的句子； ","date":"2024-03-06","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%862/:12:1","tags":["编译原理"],"title":"编译引论(第二章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%862/"},{"categories":["编译原理"],"content":"语言 定义 文法G[S]所产生的所有句子的集合，称为该文法所定义的语言，记为L(G[S])。 即： L(G)={u|$S\\stackrel{+}\\Rightarrow u$，且$u\\in V_T^*$} 文法和语言的关系 对于一给定的文法，可以唯一地确定它所产生的语言 对于一给定的语言，可以找到若干不同的文法定义它 ","date":"2024-03-06","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%862/:12:2","tags":["编译原理"],"title":"编译引论(第二章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%862/"},{"categories":["编译原理"],"content":"短语，简单短语，句柄 ","date":"2024-03-06","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%862/:13:0","tags":["编译原理"],"title":"编译引论(第二章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%862/"},{"categories":["编译原理"],"content":"定义 设G是一个文法，S是文法G的开始符号，$\\alpha\\beta\\delta$是该文法的一个句型，如果有： $S\\stackrel{*}\\Rightarrow \\alpha A \\delta$并且 $A\\stackrel{+}\\Rightarrow\\beta$ 则称$\\beta$ 是句型$\\alpha\\beta\\delta$相对于非终结符号A的短语。特别的，如果$A\\stackrel{+}\\Rightarrow\\beta$ 是通过1步推导来完成的，则称$\\beta$是句型$\\alpha\\beta\\delta$相对于非终结符号A的简单短语，也称为直接短语。一个句型的最左边的简单短语称为句柄 ","date":"2024-03-06","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%862/:13:1","tags":["编译原理"],"title":"编译引论(第二章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%862/"},{"categories":["编译原理"],"content":"语法树与文法的二义性 ","date":"2024-03-06","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%862/:14:0","tags":["编译原理"],"title":"编译引论(第二章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%862/"},{"categories":["编译原理"],"content":"语法树 用一张图来表示一个句型的推导过程 设文法G=($V_N,V_T,P,S$)，对于文法G的任意一个句型都存在一个相应的语法树： 树中每个结点都有一个标记，该标记是$V_NV_T$中的一个符号； 树的根节点标记文法的识别符号S； 若树的一个结点至少有一个叶子结点，则该结点的标记一定是一个非终结符； 若树的一个结点有多个结点，该结点的标记为A，这些叶子结点的标记从左到右分别是$B_1,B_2,…,B_n$，则($A\\rightarrow B_1B_2…B_n$)$\\in P$ ","date":"2024-03-06","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%862/:14:1","tags":["编译原理"],"title":"编译引论(第二章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%862/"},{"categories":["编译原理"],"content":"二义性 定义 一个文法，如果它的一个句子由两颗或两颗以上的语法树，则称此句子具有二义性。如果一个文法含有二义性的句子，则该文法具有二义性。 注意 文法的二义性和语言的二义性是两个不同的概念。如果产生上下文无关语言的每一个文法都是二义性的，则说该语言是二义性的。并非文法的二义性就说其描述的语言是二义性的。通常可能有两个不同的文法G1和G2，其中一个文法是二义性的，另外一个是没有二义性的，但是却有L(G1) = L(G2)，即两个文法产生的语言是等价的 ","date":"2024-03-06","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%862/:14:2","tags":["编译原理"],"title":"编译引论(第二章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%862/"},{"categories":["编译原理"],"content":"文法的实用限制 ","date":"2024-03-06","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%862/:15:0","tags":["编译原理"],"title":"编译引论(第二章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%862/"},{"categories":["编译原理"],"content":"有害规则 定义： 文法中形如$U \\rightarrow U$的规则就称为有害规则 如果文法中含有有害规则，它除了造成文法的二义性以外，对定义语言则是没有任何意义。 例如： ","date":"2024-03-06","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%862/:15:1","tags":["编译原理"],"title":"编译引论(第二章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%862/"},{"categories":["编译原理"],"content":"多余规则 多余规则则指文法中任何句子的推导都不会用到的规则，多余规则在文法中以两种形式出现，即不可到达的非终结符和不可终止的非终止符 文法中某些非终结符(除去文法开始符号)不出现任何其他规则的右部，该非终结符称为不可到达。 文法中某些非终结符，由它不能推出终结符号串，该非终结符称为不可终止。 例如： G[S]: $S\\rightarrow Be$ $B\\rightarrow Ce$ $B\\rightarrow Af$ $A\\rightarrow Ae$ $A\\rightarrow e$ $C\\rightarrow Cf$ $D\\rightarrow f$ 根据有害规则和多余规则的定义，显然文法不包含有有害规则，而由于非终结符号C为不可终止，非终结符号D为不可到达，因此产生式2，6，7为多余规则应去掉 一般所讨论的文法均假定不包含有有害规则和多余规则 ","date":"2024-03-06","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%862/:15:2","tags":["编译原理"],"title":"编译引论(第二章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%862/"},{"categories":["编译原理"],"content":"文法的等价变换 ","date":"2024-03-06","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%862/:16:0","tags":["编译原理"],"title":"编译引论(第二章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%862/"},{"categories":["编译原理"],"content":"文法直接左递归的消除 假定关于非终结符U的产生式为：$U\\rightarrow U\\alpha|\\beta$ 其中$\\alpha ,\\beta \\in (V_N\\bigcup V_T)^*$，$\\beta$补以U开头，那么，可以把U的产生式改写成如下的非直接左递归形式： $U\\rightarrow \\beta U^,$ $U^, \\rightarrow \\alpha U^,|\\epsilon$ 引入新的非终结符号消去文法中的直接左递归: 形如$U \\rightarrow Ux_1 | Ux_2 |…| Ux_m|y_1|y_2|…|y_m$的规则，可引入一个新的非终结符号$U^,$,则得到等价的规则： $U \\rightarrow y_1U^,|y_2U^,|…|y_mU^,$ $U^, \\rightarrow x_1U^,|x_2U^,|…|x_mU^,|\\epsilon$ ","date":"2024-03-06","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%862/:16:1","tags":["编译原理"],"title":"编译引论(第二章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%862/"},{"categories":["编译原理"],"content":"文法一般左递归的消除 如果一个文法不含有形如$U \\stackrel{+}\\Rightarrow U$的推导，也不含有以$\\epsilon$为右部的产生式，那执行下面的算法将保证消除文法中的所有左递归 消除间接左递归的算法如下 例： ","date":"2024-03-06","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%862/:16:2","tags":["编译原理"],"title":"编译引论(第二章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%862/"},{"categories":["编译原理"],"content":"提取左因子 假设A的产生式为： $A \\rightarrow \\delta\\beta_1|\\delta\\beta_2|…|\\delta\\beta_n|\\gamma_1|\\gamma_2|…|\\gamma_n$（其中，每个$\\gamma$不以$\\delta$开头） 可将这些产生式改写成： $A \\rightarrow A^,|\\gamma_1|\\gamma_2|…|\\gamma_n$ $A^,\\rightarrow \\beta_1|\\beta_2|…|\\beta_n$ 经过反复提取左因子，就能够把每个非终结符(包括新引进者)的所有候选式的公共左因子消除掉，则改变后的文法便于自上而下的语法分析，如LL(1)预测分析法。相应付出的代价是，大量引进新的非终结符和$\\epsilon -$产生式。 例： ","date":"2024-03-06","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%862/:16:3","tags":["编译原理"],"title":"编译引论(第二章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%862/"},{"categories":["编译原理"],"content":"文法 ","date":"2024-03-06","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%862/:17:0","tags":["编译原理"],"title":"编译引论(第二章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%862/"},{"categories":["编译原理"],"content":"0型文法 0型文法(无限制的文法)，其产生式具有以下形式： $\\alpha \\rightarrow \\beta$ 其中，$\\alpha \\in V^+$，且至少含有一个非终结符；$\\beta \\in V^*$ ","date":"2024-03-06","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%862/:17:1","tags":["编译原理"],"title":"编译引论(第二章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%862/"},{"categories":["编译原理"],"content":"1型文法(上下文有关文法) 定义：1型文法G的产生式具有以下形式： $xUy \\rightarrow \\xuy$ 其中$x,y \\in V^*;U \\in V_N;u \\in V^+$ ","date":"2024-03-06","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%862/:17:2","tags":["编译原理"],"title":"编译引论(第二章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%862/"},{"categories":["编译原理"],"content":"2型文法(上下文无关文法) 定义：在1型文法的产生式中上下文x和y用空符号串$\\epsilon$代替，则有以下形式的产生式称为2型文法： $U \\rightarrow u$ 其中，$U \\in V_N,u \\in V^*$ ","date":"2024-03-06","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%862/:17:3","tags":["编译原理"],"title":"编译引论(第二章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%862/"},{"categories":["编译原理"],"content":"3型文法(正规文法) 定义1：如果文法的产生式只含有下面的两种形式： $U \\rightarrow a$或$U \\rightarrow aB$ 其中U，$B \\in V_N,a \\in V_T^*$，则称该文法为右线性文法； 定义2：如果文法的产生式只含有下面的两种形式： $U \\rightarrow a$或$U \\rightarrow Ba$ 其中U，$B \\in V_N,a \\in V_T^*$，则称该文法为左线性文法； 例： ","date":"2024-03-06","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%862/:17:4","tags":["编译原理"],"title":"编译引论(第二章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%862/"},{"categories":["操作系统"],"content":"进程管理(引入) ","date":"2024-03-05","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F2/:0:0","tags":["操作系统"],"title":"操作系统(第二章)","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F2/"},{"categories":["操作系统"],"content":"前趋图(也称为：有向无循环图) 条件：有向，无循环 O(圆圈)：节点，代表指令，程序，进程… →：有向边，代表前趋/后继关系 ","date":"2024-03-05","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F2/:1:0","tags":["操作系统"],"title":"操作系统(第二章)","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F2/"},{"categories":["操作系统"],"content":"程序的执行 ","date":"2024-03-05","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F2/:2:0","tags":["操作系统"],"title":"操作系统(第二章)","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F2/"},{"categories":["操作系统"],"content":"顺序执行及特征 特征：顺序性，封闭性，可再现性 顺序→并发(可能性分析图) 例题： 引起不可再现性是因为没有临界资源(每一个缓冲区)没有访问(互斥访问) 进程的相关概念 ","date":"2024-03-05","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F2/:2:1","tags":["操作系统"],"title":"操作系统(第二章)","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F2/"},{"categories":["操作系统"],"content":"定义 程序的一次执行过程 ","date":"2024-03-05","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F2/:3:0","tags":["操作系统"],"title":"操作系统(第二章)","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F2/"},{"categories":["操作系统"],"content":"结构 进程映像：PCB+程序段+数据段 (中断返回地址存放在PCB中) ","date":"2024-03-05","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F2/:4:0","tags":["操作系统"],"title":"操作系统(第二章)","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F2/"},{"categories":["操作系统"],"content":"动态 由\"创建\"而产生，由\"调度\"而执行，由\"撤消\"而消亡(而程序是静态的) ","date":"2024-03-05","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F2/:5:0","tags":["操作系统"],"title":"操作系统(第二章)","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F2/"},{"categories":["操作系统"],"content":"状态 ","date":"2024-03-05","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F2/:6:0","tags":["操作系统"],"title":"操作系统(第二章)","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F2/"},{"categories":["操作系统"],"content":"三态结构(图) 就绪状态： 条件：获得除CPU以外的所有资源 一个就绪队列 执行状态： 条件：已获得CPU，程序正在执行的状态 在单处理机系统中，只有一个进程处于执行状态；而在多处理机系统中，则有多个进程处于执行状态 阻塞状态： 条件：进程的执行受到阻塞 一个阻塞队列 实事上，在较大的系统中，为了减少队列操作的开销，提高系统效率，根据阻塞原因不同，会设置多个阻塞队列。 ","date":"2024-03-05","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F2/:6:1","tags":["操作系统"],"title":"操作系统(第二章)","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F2/"},{"categories":["操作系统"],"content":"转换关系 经常发生：4个，就绪→执行，执行→就绪，执行→阻塞，阻塞→执行 绝对不会发生：就绪→阻塞 有可能会发生：阻塞→执行 挂起状态 ","date":"2024-03-05","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F2/:6:2","tags":["操作系统"],"title":"操作系统(第二章)","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F2/"},{"categories":["操作系统"],"content":"引入原因 减少内存当中进程的数量(从内存调到外存) ","date":"2024-03-05","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F2/:7:0","tags":["操作系统"],"title":"操作系统(第二章)","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F2/"},{"categories":["操作系统"],"content":"状态分类 静止→活动 被激活(执行激活函数) 话动→静止 被挂起(执行挂起函数) ","date":"2024-03-05","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F2/:8:0","tags":["操作系统"],"title":"操作系统(第二章)","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F2/"},{"categories":["操作系统"],"content":"具有挂起状态的进程状态图(五态结构) 进程控制块(PCB) ","date":"2024-03-05","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F2/:9:0","tags":["操作系统"],"title":"操作系统(第二章)","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F2/"},{"categories":["操作系统"],"content":"作用 进程存在的唯一标志 ","date":"2024-03-05","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F2/:10:0","tags":["操作系统"],"title":"操作系统(第二章)","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F2/"},{"categories":["操作系统"],"content":"进程控制块中的信息(图) 标识，处理机状态，进程调度信息，进程控制信息 优先数：一般为整数 ","date":"2024-03-05","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F2/:11:0","tags":["操作系统"],"title":"操作系统(第二章)","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F2/"},{"categories":["操作系统"],"content":"PCB的组织 链接 索引 进程控制(三对操作) 创建与终止 阻塞与唤醒 挂起与激活 进程同步 ","date":"2024-03-05","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F2/:12:0","tags":["操作系统"],"title":"操作系统(第二章)","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F2/"},{"categories":["操作系统"],"content":"概念 并发进程在执行次序上的协调，以达到有效的资源共享和相互合作，使程序的执行具有可再现性 ","date":"2024-03-05","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F2/:13:0","tags":["操作系统"],"title":"操作系统(第二章)","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F2/"},{"categories":["操作系统"],"content":"关系 间接制约：互斥共享资源 直接制约：相互合作 ","date":"2024-03-05","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F2/:14:0","tags":["操作系统"],"title":"操作系统(第二章)","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F2/"},{"categories":["操作系统"],"content":"临界资源 一次只允许一个进程访问的资源 引起不可再现性是因为没有临界资源(每一个缓冲区)没有访问(互斥访问) ","date":"2024-03-05","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F2/:15:0","tags":["操作系统"],"title":"操作系统(第二章)","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F2/"},{"categories":["操作系统"],"content":"临界区 ","date":"2024-03-05","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F2/:16:0","tags":["操作系统"],"title":"操作系统(第二章)","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F2/"},{"categories":["操作系统"],"content":"定义 进程访问临界资源的那段代码 ","date":"2024-03-05","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F2/:16:1","tags":["操作系统"],"title":"操作系统(第二章)","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F2/"},{"categories":["操作系统"],"content":"描述 进入区：检查有无进程进入 临界区： 退出区：将访问标志复位 ","date":"2024-03-05","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F2/:16:2","tags":["操作系统"],"title":"操作系统(第二章)","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F2/"},{"categories":["操作系统"],"content":"信号量机制 ","date":"2024-03-05","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F2/:17:0","tags":["操作系统"],"title":"操作系统(第二章)","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F2/"},{"categories":["操作系统"],"content":"整型信号量(S) 是一个整型量，通过2个原子操作wait (s)和signal (s)来访问 含义：表示资源，$S_{初始值}≥0$ 变化： –1：wait(s) p(s) 表示申请资源 +1：signal(s) v(s) 表示释放资源 注：wait(s)和signal(s)是成对出现 问题：当S≤0，不能分配资源，进程阻塞(队列) 记录型(S) S.value：代表资源，s.value≥0 S.L：阻塞进程的队列 操作 wait(s) 分析 ： S.value=1→(p(s))1-1=0 S.value=0→(p(s))0-1=-1 signal(s) 分析 S.value=-1→(v(s))-1+1=0 S.value=-2→(v(s))-2+1=-1 小结： 实现进程关系的描述 wait(s)和signal(s)是成对出现 同一个进程或两个进程之间出现 在记录型信号量机制中 S.value初值：表示系统中某类资源的数目 S.value\u003c0：表示信号量链表中已阻塞进程的数目 ","date":"2024-03-05","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F2/:17:1","tags":["操作系统"],"title":"操作系统(第二章)","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F2/"},{"categories":["操作系统"],"content":"信号量的应用 ","date":"2024-03-05","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F2/:18:0","tags":["操作系统"],"title":"操作系统(第二章)","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F2/"},{"categories":["操作系统"],"content":"利用信号量实现互斥 一个进程执行，另一个进程不执行，则成互斥关系 步骤 共享临界资源(mutex)=1 wait(mutex) signal(mutex) 设置临界区 进入：wait(mutex) CS 退出：signal(mutex) 同一个进程当中，成对出现 总结 mutex实现临界区的设置(2个) mutex实现两个进程的互斥 ","date":"2024-03-05","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F2/:18:1","tags":["操作系统"],"title":"操作系统(第二章)","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F2/"},{"categories":["操作系统"],"content":"同步(直接制约) 同步的模型 前趋图 S1(被等待)signal(a)→S2(等待)wait(a) 代码框架描述如下 ","date":"2024-03-05","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F2/:18:2","tags":["操作系统"],"title":"操作系统(第二章)","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F2/"},{"categories":["操作系统"],"content":"经典进程的同步问题 ","date":"2024-03-05","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F2/:19:0","tags":["操作系统"],"title":"操作系统(第二章)","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F2/"},{"categories":["操作系统"],"content":"生产者–消费者问题 设置信号量 每个缓冲区：mutex(初值为：1) empty:空(初值为：n) full:满(初值为：0) 结论 当有多个信号量时，注意wait的顺序 临界区的设置，主要是实现变量的修改 代码描述如下： int in=0,out=0; item buffer[n]; semaphore mutex=1,empty=n;full=0; void proceducer(){ do{ proceducer an item nextp; ... wait(empty); wait(mutex); buffer[in]=nextp; in:=(in+1)%n; signal(mutex); signal(full); }while(TRUE) } void consumer(){ do{ wait(full); wait(mutex); nextc=buffer[out]; out:=(out+1)%n; signal(mutex); signal(empty); consumer the item in nextc; ... }while(TRUE) } void main(){ cobegin proceducer(); consumer(); coend } 注意 在每个程序中的多个wait操作顺序不能颠倒。应先执行对信号资源量的wait操作，然后再执行对互斥信号量的wait操作，否则可能引起死锁 ","date":"2024-03-05","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F2/:19:1","tags":["操作系统"],"title":"操作系统(第二章)","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F2/"},{"categories":["操作系统"],"content":"哲学家进餐问题 经分析可知，放在桌子上的筷子是临界资源，在一段时间只允许一位哲学家使用。为了实现对筷子的互斥使用，可以用一个信号量表示一只筷子，由这五个信号量构成信号量数组，描述如下： semaphore chopstick[5]={1,1,1,1,1}; 所有信号量均被初始化为1，第i位哲学家的活动可描述为： do{ wait(chopstick[i]); wait(chopstick[(i+1)%5]); ... //eat ... signal(chopstick[i]); signal(chopstick[(i+1)%5]); ... //think ... }while[TRUE]; 解决漏洞 假设五位哲学家同时饥饿而各自拿起左边的筷子时，就会使五个信号量chopstick均为0；当他们再试图去拿右边的筷子时，都将因无筷子可拿而无限期等待。从而出现死锁。 对于这样的死锁问题，可采取以下几种解决办法： 至多只允许有四位哲学家同时去拿左边的筷子，最终能保证至少有一位哲学家能够进餐，并在用毕时能释放出他用过的两只筷子，从而使更多的哲学家能够进餐 仅当哲学家的左，右两只筷子均可用时，才允许他拿起筷子进餐 规定奇数号哲学家先拿起他左边的筷子，然后再去拿右边的筷子；而偶数号哲学家则相反。按此规定，将是1，2号哲学家竞争1号筷子；3，4号哲学家竞争3号筷子，即五位哲学家都先竞争奇数号筷子，获得后，再去竞争偶数号筷子，最后总会有一位哲学家能获得两只筷子而进餐。 ","date":"2024-03-05","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F2/:19:2","tags":["操作系统"],"title":"操作系统(第二章)","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F2/"},{"categories":["操作系统"],"content":"读者–写者问题 两者呈互斥关系 特点：读进程可共享同一对象，写进程不可共享同一对象。 为实现Reader与Writer进程间在读或写时的互斥而设置了一个互斥信号量Wmutex.另外再设置一个整型变量Readcount表示正在读的进程数目。又因为Readcount是一个可被多个Reader进程访问的临界资源，因此，也因该为它设置一个互斥信号量rmutex 读者–写着问题可描述如下： semaphore rmutex=1,wmutex=1; int readcount=0; void reader(){ do{ wait(rmutex); if(readcount==0) wait(wmutex); readcount++; signal(rmutex); ... perform read operation; ... wait(rmutex); readcount--; if(readcount==0) signal(wmutex); signal(rmutex); }while(TRUE); } void writer(){ do{ wait(wmutex); perform write operation; signal(wmutex); }while(TRUE); } void main(){ cobegin reader(); writer(); coend } ","date":"2024-03-05","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F2/:19:3","tags":["操作系统"],"title":"操作系统(第二章)","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F2/"},{"categories":["操作系统"],"content":"思考题 ","date":"2024-03-05","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F2/:20:0","tags":["操作系统"],"title":"操作系统(第二章)","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F2/"},{"categories":["计算机算法设计与分析"],"content":"算法与程序 ","date":"2024-03-05","objectID":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%8A%98%E4%B8%8E%E8%AE%BE%E8%AE%A1/:0:0","tags":["计算机算法设计与分析"],"title":"算法与程序(第一章)","uri":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%8A%98%E4%B8%8E%E8%AE%BE%E8%AE%A1/"},{"categories":["计算机算法设计与分析"],"content":"算法 是满足下述性质的指令序列: 输入:有零个或多个外部量作为算法的输入 输出:算法产生至少一个量作为输出 确定性:组成算法的每条指令是清晰的，无歧义的 有限性:算法中每条指令的执行次数是有限的，执行每条指令的时间也是有限的 ","date":"2024-03-05","objectID":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%8A%98%E4%B8%8E%E8%AE%BE%E8%AE%A1/:1:0","tags":["计算机算法设计与分析"],"title":"算法与程序(第一章)","uri":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%8A%98%E4%B8%8E%E8%AE%BE%E8%AE%A1/"},{"categories":["计算机算法设计与分析"],"content":"程序 与算法不同。程序是算法用某种程序设计语言的具体实现，程序可以不满足算法的性质 问题求解(图) 算法复杂性分析 ","date":"2024-03-05","objectID":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%8A%98%E4%B8%8E%E8%AE%BE%E8%AE%A1/:2:0","tags":["计算机算法设计与分析"],"title":"算法与程序(第一章)","uri":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%8A%98%E4%B8%8E%E8%AE%BE%E8%AE%A1/"},{"categories":["计算机算法设计与分析"],"content":"时间复杂性 输入为ⅰ时的跟规模n相关的算法运行时间增长率 ","date":"2024-03-05","objectID":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%8A%98%E4%B8%8E%E8%AE%BE%E8%AE%A1/:3:0","tags":["计算机算法设计与分析"],"title":"算法与程序(第一章)","uri":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%8A%98%E4%B8%8E%E8%AE%BE%E8%AE%A1/"},{"categories":["计算机算法设计与分析"],"content":"空间复杂性 输入为ⅰ时的跟规模n相关的算法辅助空间增长率 ","date":"2024-03-05","objectID":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%8A%98%E4%B8%8E%E8%AE%BE%E8%AE%A1/:4:0","tags":["计算机算法设计与分析"],"title":"算法与程序(第一章)","uri":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%8A%98%E4%B8%8E%E8%AE%BE%E8%AE%A1/"},{"categories":["计算机算法设计与分析"],"content":"分析 算法复杂性分析→算法的能行性 n！，2n，n较大时 同一问题不同算法的算法复杂性分析→算法的优劣 时间复杂性与空间复杂性的分析方法类同，主要讨论时间复杂性 ","date":"2024-03-05","objectID":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%8A%98%E4%B8%8E%E8%AE%BE%E8%AE%A1/:5:0","tags":["计算机算法设计与分析"],"title":"算法与程序(第一章)","uri":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%8A%98%E4%B8%8E%E8%AE%BE%E8%AE%A1/"},{"categories":["计算机算法设计与分析"],"content":"时间复杂性分析方法 ","date":"2024-03-05","objectID":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%8A%98%E4%B8%8E%E8%AE%BE%E8%AE%A1/:6:0","tags":["计算机算法设计与分析"],"title":"算法与程序(第一章)","uri":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%8A%98%E4%B8%8E%E8%AE%BE%E8%AE%A1/"},{"categories":["计算机算法设计与分析"],"content":"分类 非递归算法的时间复杂性分析 递归算法的时间复杂性分析 ","date":"2024-03-05","objectID":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%8A%98%E4%B8%8E%E8%AE%BE%E8%AE%A1/:7:0","tags":["计算机算法设计与分析"],"title":"算法与程序(第一章)","uri":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%8A%98%E4%B8%8E%E8%AE%BE%E8%AE%A1/"},{"categories":["计算机算法设计与分析"],"content":"算法复杂性在渐近意义下的阶 渐近意义下的记号：O，Ω，θ，o，ω g(n)是定义在正数集上的正函数。T(n)为算法的时间复杂性 ","date":"2024-03-05","objectID":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%8A%98%E4%B8%8E%E8%AE%BE%E8%AE%A1/:8:0","tags":["计算机算法设计与分析"],"title":"算法与程序(第一章)","uri":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%8A%98%E4%B8%8E%E8%AE%BE%E8%AE%A1/"},{"categories":["计算机算法设计与分析"],"content":"渐近上界记号O 若T(n) = O(g(n)) 含义：算法在任何实例情况下，其时间复杂度的阶不超过g(n)的阶 即：$\\lim_{n\\rightarrow\\infty}\\frac{T_max(n)}{g(n)}=c\\neq0$,c为常数 上例中 $\\lim_{n\\rightarrow\\infty}\\frac{T_max(n)}{n^2}=\\frac{c4+c5+c6}{2}$为常数，故T(n)=O(n2) ","date":"2024-03-05","objectID":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%8A%98%E4%B8%8E%E8%AE%BE%E8%AE%A1/:8:1","tags":["计算机算法设计与分析"],"title":"算法与程序(第一章)","uri":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%8A%98%E4%B8%8E%E8%AE%BE%E8%AE%A1/"},{"categories":["计算机算法设计与分析"],"content":"记号θ 举例有一个算法A： 最坏情况：Tmax=c1n2+n+4 最好情况：Tmin=c2n2 存在g(n)=n2,有T(n) = Ω(g(n)) 和 T(n) = O(g(n)) 因此 T(n) = θ(g(n)) ","date":"2024-03-05","objectID":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%8A%98%E4%B8%8E%E8%AE%BE%E8%AE%A1/:8:2","tags":["计算机算法设计与分析"],"title":"算法与程序(第一章)","uri":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%8A%98%E4%B8%8E%E8%AE%BE%E8%AE%A1/"},{"categories":["计算机算法设计与分析"],"content":"非紧渐近上界记号 o 若T(n) = o(g(n)) 含义：算法在任何实例情况下，其算法时间复杂性的阶小于g(n)的阶 即 $\\lim_{n\\rightarrow\\infty}\\frac{T_max(n)}{g(n)}=0$ 举例：g(n) = n2,Tmax(n)=c2nlogn —\u003e o(n2) ","date":"2024-03-05","objectID":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%8A%98%E4%B8%8E%E8%AE%BE%E8%AE%A1/:8:3","tags":["计算机算法设计与分析"],"title":"算法与程序(第一章)","uri":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%8A%98%E4%B8%8E%E8%AE%BE%E8%AE%A1/"},{"categories":["计算机算法设计与分析"],"content":"非紧渐近上界记号 ω 若T(n) = ω(g(n)) 含义：算法在任何实例情况下，其算法时间复杂性的阶大于g(n)的阶 即 $\\lim_{n\\rightarrow\\infty}\\frac{T_min(n)}{g(n)}=\\infty$ 举例：g(n)=n,Tmin=c1nlogn—\u003eω(n) ","date":"2024-03-05","objectID":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%8A%98%E4%B8%8E%E8%AE%BE%E8%AE%A1/:8:4","tags":["计算机算法设计与分析"],"title":"算法与程序(第一章)","uri":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%8A%98%E4%B8%8E%E8%AE%BE%E8%AE%A1/"},{"categories":["计算机算法设计与分析"],"content":"简便分析方法 最优算法 Master定理方法求递归算法时间复杂性 ","date":"2024-03-05","objectID":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%8A%98%E4%B8%8E%E8%AE%BE%E8%AE%A1/:9:0","tags":["计算机算法设计与分析"],"title":"算法与程序(第一章)","uri":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%8A%98%E4%B8%8E%E8%AE%BE%E8%AE%A1/"},{"categories":["计算机算法设计与分析"],"content":"第二章分治策略中，通常设计为递归算法 时间复杂性的递归定义一般有如下形式 ","date":"2024-03-05","objectID":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%8A%98%E4%B8%8E%E8%AE%BE%E8%AE%A1/:10:0","tags":["计算机算法设计与分析"],"title":"算法与程序(第一章)","uri":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%8A%98%E4%B8%8E%E8%AE%BE%E8%AE%A1/"},{"categories":["计算机算法设计与分析"],"content":"例题 第二章棋盘覆盖的时间复杂性 ","date":"2024-03-05","objectID":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%8A%98%E4%B8%8E%E8%AE%BE%E8%AE%A1/:11:0","tags":["计算机算法设计与分析"],"title":"算法与程序(第一章)","uri":"/posts/%E7%AE%97%E6%B3%95%E5%88%86%E6%8A%98%E4%B8%8E%E8%AE%BE%E8%AE%A1/"},{"categories":["编译原理"],"content":"编译程序(图) 某一种语言等价地转换成另外一种语言程序(称为目标语言程序) 解释程序(图) 将源程序按动态顺序逐句分晰解释执行，根据语句的含义执行，最终得到运行结果 编译器在语言处理系统中的位置(图) 编译过程 1. 词法分析 任务：输入源程序，对构成源程序的字符串进行扫描和分解，识别一个个单词符号。 依循的原则：构词规则 描述工具：正规式，有限自动机 FOR(保留字) I(标识符) :=(算符) 1(常整数) TO(保留字) 100(常整数) DO(保留字) 2. 语法分析 任务： 在词法分析的基础上，根据语言的语法规则把单词符号串分解成各类语法单位。 依循的原则：语法分析 描述工具：上下文无关文法 i(标识符)=5(无符号整数)+3(无符号整数)j(标识符) 3. 中间代码生成 任务：对语法分析所识别出的各类语法单位，分析其含义，并产生中间代码 依循的原则：语义规则 描述工具：属性文法 中间代码是一种独立于硬件的记号系统。常见的中间代码形式有逆波兰表达式，三元式，四元式等 (i+j)(x-y)翻译为四元式 (+,i,j,T1) (-,x,y,T2) (,T1,T2,T3) 4. 优化 任务：对当前阶段产生的中间代码进行等价加工变换，以期最终生成的目标代码更加高效 依循的原则：等价变换原则 常见的优化种类有公共子表达式删除，复制传播，无用代码删除和常量合并 (*,5.3,2,T1) (=,T1, ,x) 优化后： ( =,10.6, ,x) 5. 目标代码产生 任务：把中间代码变换成特定机器上的低级语言代码 该阶段的工作非常复杂，涉及机器指令的选择，寄存器的调度，以及各种数据类型变量的存储空间分配等。 6. 表格管理程序 完成编译过程中的建表，查表，更新数据等有关表格操作 **7. 错误处理程序 ** 编译程序不仅能对书写正确的程序进行翻译，而且还能对出现在源程序中的错误进行处理 编译程序的结构 ","date":"2024-03-05","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/:0:0","tags":["编译原理"],"title":"编译引论(第一章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"},{"categories":["编译原理"],"content":"编译程序的总体结构(图) 相关概念 ","date":"2024-03-05","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/:1:0","tags":["编译原理"],"title":"编译引论(第一章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"},{"categories":["编译原理"],"content":"“遍\"的概念 所谓\"一遍\"是指，对源程序或中间程序从头到尾扫描一次，并作相关加工处理，生成新的中间程序或相关代码 ","date":"2024-03-05","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/:2:0","tags":["编译原理"],"title":"编译引论(第一章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"},{"categories":["编译原理"],"content":"多遍编译程序 把编译的5个阶段应完成的工作分遍来做，每一遍完成一个或相连几个阶段的工作 ","date":"2024-03-05","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/:3:0","tags":["编译原理"],"title":"编译引论(第一章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"},{"categories":["编译原理"],"content":"前端 通常包括词法分析，语法分析，语义分析及中间代码生成，有的优化工作也可以包括在前端，前端依赖于源程序 ","date":"2024-03-05","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/:3:1","tags":["编译原理"],"title":"编译引论(第一章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"},{"categories":["编译原理"],"content":"后端 通常包括有关代码优化和目标代码生成，依赖于中间代码，计算机的硬件系统和机器指令系统 编译程序开发 ","date":"2024-03-05","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/:3:2","tags":["编译原理"],"title":"编译引论(第一章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"},{"categories":["编译原理"],"content":"自展技术(图) 按照自展技术，需要把源语言L分解成一个核心部分L0与扩充部分L1,L2,….,Ln。分解源语言之后，先用汇编语言或机器语言编写L0的编译程序，然后再用L0编写L1的编译程序，用Li编写Li+n的编译程序(i=1,2,…,n-1),像滚雪球一样，愈滚愈大，最后得到源语言L的编译程序 ","date":"2024-03-05","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/:4:0","tags":["编译原理"],"title":"编译引论(第一章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"},{"categories":["编译原理"],"content":"移植技术 即利用A机器上已有的高级语言L编写一个能够在B机器上运行的高级语言L的编译程序 假设A机器上已经有用A机器代码实现的高级语言L的编译程序，移植实现的具体做法是： 首先用L语言编写出在A机器上运行的产生B机器代码的L语言的编译程序源程序 然后把该编译程序源程序经过A机器上的L编译程序编译后，得到能在A机器上运行产生B机器代码的编译程序 最后用这个编译程序再一次编译第1步编写的编译程序源程序，得到了能在B机器上运行的产生B机器代码的编译程序 ","date":"2024-03-05","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/:5:0","tags":["编译原理"],"title":"编译引论(第一章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"},{"categories":["编译原理"],"content":"自动生成技术 利用工具，编译程序自动生成 LEX：词法分析程序产生器 YACC：语法分析程序产生器 ","date":"2024-03-05","objectID":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/:6:0","tags":["编译原理"],"title":"编译引论(第一章)","uri":"/posts/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"},{"categories":["操作系统"],"content":"os的定义 ","date":"2024-03-04","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/:0:0","tags":["操作系统"],"title":"操作系统(第一章)","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"categories":["操作系统"],"content":"管理资源 ","date":"2024-03-04","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/:1:0","tags":["操作系统"],"title":"操作系统(第一章)","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"categories":["操作系统"],"content":"硬件 进程，存储器，外部设备 ","date":"2024-03-04","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/:1:1","tags":["操作系统"],"title":"操作系统(第一章)","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"categories":["操作系统"],"content":"软件 文件 ","date":"2024-03-04","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/:1:2","tags":["操作系统"],"title":"操作系统(第一章)","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"categories":["操作系统"],"content":"分配资源 以作业/进程为单位进行调度(cpu算法) ","date":"2024-03-04","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/:2:0","tags":["操作系统"],"title":"操作系统(第一章)","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"categories":["操作系统"],"content":"程序 ","date":"2024-03-04","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/:3:0","tags":["操作系统"],"title":"操作系统(第一章)","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"categories":["操作系统"],"content":"进程 执行的程序(内存) ","date":"2024-03-04","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/:3:1","tags":["操作系统"],"title":"操作系统(第一章)","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"categories":["操作系统"],"content":"作业 暂时不执行的程序(外存) 操作系统概念 一组控制和管理计算机硬件和软件资源，合理地对各类作业进行调度以及方便用户的程序集合。 用户(方便) 作为扩充机器 把覆盖了软件的机器称为扩充机或虚拟机 发展 ","date":"2024-03-04","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/:3:2","tags":["操作系统"],"title":"操作系统(第一章)","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"categories":["操作系统"],"content":"脱机(spooLing(假脱机)) ","date":"2024-03-04","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/:4:0","tags":["操作系统"],"title":"操作系统(第一章)","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"categories":["操作系统"],"content":"外围机 用于管理输入/输出设备 ","date":"2024-03-04","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/:4:1","tags":["操作系统"],"title":"操作系统(第一章)","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"categories":["操作系统"],"content":"磁盘 优点:容量大 ","date":"2024-03-04","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/:4:2","tags":["操作系统"],"title":"操作系统(第一章)","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"categories":["操作系统"],"content":"批处理 ","date":"2024-03-04","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/:5:0","tags":["操作系统"],"title":"操作系统(第一章)","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"categories":["操作系统"],"content":"单道 两种硬件 cpu, i/o 串行工作 ","date":"2024-03-04","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/:5:1","tags":["操作系统"],"title":"操作系统(第一章)","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"categories":["操作系统"],"content":"多道(图) 两种硬件 cpu, i/o 并行工作 分时操作系统 实现人机交互，满足用户需要 实时系统 系统能实时响应外部事件的请求，在规定时间内完成对该事件的处理，并控制所有任务协调一致地运行 操作系统的特征 ","date":"2024-03-04","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/:5:2","tags":["操作系统"],"title":"操作系统(第一章)","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"categories":["操作系统"],"content":"并发性 ","date":"2024-03-04","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/:6:0","tags":["操作系统"],"title":"操作系统(第一章)","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"categories":["操作系统"],"content":"并发 同一个时间间隔发生 ","date":"2024-03-04","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/:6:1","tags":["操作系统"],"title":"操作系统(第一章)","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"categories":["操作系统"],"content":"并行 同一个时刻发生 ","date":"2024-03-04","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/:6:2","tags":["操作系统"],"title":"操作系统(第一章)","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"categories":["操作系统"],"content":"进程和线程 线程也被称为轻型进程 ","date":"2024-03-04","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/:6:3","tags":["操作系统"],"title":"操作系统(第一章)","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"categories":["操作系统"],"content":"共享 系统中资源可供内存中多个并发执行的进程共同使用 ","date":"2024-03-04","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/:7:0","tags":["操作系统"],"title":"操作系统(第一章)","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"categories":["操作系统"],"content":"互斥共享 一段时间内只允许一个进程访问该资源 ","date":"2024-03-04","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/:7:1","tags":["操作系统"],"title":"操作系统(第一章)","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"categories":["操作系统"],"content":"同时访问 微观上仍是互斥的 ","date":"2024-03-04","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/:7:2","tags":["操作系统"],"title":"操作系统(第一章)","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"categories":["操作系统"],"content":"虚拟(逻辑\u003c–\u003e物理) 通过某种技术把一个物理实体变为若干个逻辑上的对应物 ","date":"2024-03-04","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/:8:0","tags":["操作系统"],"title":"操作系统(第一章)","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"categories":["操作系统"],"content":"存储器 逻辑地址→(重定向)物理地址 ","date":"2024-03-04","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/:8:1","tags":["操作系统"],"title":"操作系统(第一章)","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"categories":["操作系统"],"content":"I/O设备 逻辑设备→物理设备 ","date":"2024-03-04","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/:8:2","tags":["操作系统"],"title":"操作系统(第一章)","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"categories":["操作系统"],"content":"异步 运行进度不可预知 了解常见的os的性能(建议ppt) ","date":"2024-03-04","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/:9:0","tags":["操作系统"],"title":"操作系统(第一章)","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"categories":["操作系统"],"content":"优点 ","date":"2024-03-04","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/:10:0","tags":["操作系统"],"title":"操作系统(第一章)","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"categories":["操作系统"],"content":"缺点 ","date":"2024-03-04","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/:11:0","tags":["操作系统"],"title":"操作系统(第一章)","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"categories":["hugo"],"content":"使用Hugo+Github搭建自己的个人博客 一、前言介绍 Hugo是一个个人博客静态框架，相比于Hexo更加轻量生成更加快速。结合GitHub.io可以快速的搭建生成属于自己的博客，并且有丰富的主题和插件支持。 二、搭建过程 ","date":"2024-03-01","objectID":"/posts/%E6%90%AD%E5%BB%BAhugo%E5%8D%9A%E5%AE%A2buildblog/:0:0","tags":["hugo"],"title":"搭建hugo博客(buildblog)","uri":"/posts/%E6%90%AD%E5%BB%BAhugo%E5%8D%9A%E5%AE%A2buildblog/"},{"categories":["hugo"],"content":"一.安装Hugo和Git 查阅 Hugo 安装指南：Install Hugo | Hugo，找到对应系统的安装操作。 基本上都是使用各个包工具安装，本人 Win11，比较嫌麻烦就直接下载使用。 打开 Github 中的 Hugo 库，打开右侧的 Realeases，下载最新的版本，本次下载为：hugo_extended_0.82.0_Windows-64bit.zip 解压后，将其中的 hugo.exe 放到指定的安装目录，比如 D:\\softwares\\Hugo\\bin，然后将该目录添加到系统环境变量（win+R → sysdm.cpl → 高级 → 环境变量 → 系统变量 Path）的 Path 下。 打开命令行，输入 hugo version，显示版本号即为安装成功 本地下载 Git ，Win11直接下载 exe ，点击下一步就好了 https://registry.npmmirror.com/binary.html?path=git-for-windows/ 因为官方地址下载可能会缓慢所以这里建议使用镜像地址下载。镜像地址离包含的是Git的所有历史版本，因此要选择一个最新的版本，这里可以对比一下官方地址的版本号，然后去镜像地址找到对应的文件下载下来就可以了。比如我下载的是2.39.2 64bit的版本： 那么镜像地址中就找到对应的版本即可： 三.搭建Hugo网站 新建一个目录，用于存放 Hugo 网站的文件，比如：H:\\HugoWebsite 打开命令行，切换到该目录，执行命令新建一个 Hugo 网站 #blog 是网站文件夹名 hugo new site blog\r四.选择 Hugo 主题 打开 hugo theme 的网站，选择合适的主题，以LoveIt 举例。 Hugo Themes: https://themes.gohugo.io 将选中的主题下载到本地 #进入网站目录 blog cd blog #进入 themes 目录，一般默认有，如果没有自行创建 cd themes #下载主题到 themes 文件夹下 git clone https://github.com/dillonzq/LoveIt.git themes/LoveIt 此处建议选择的这个主题相较适合第一次尝试，配置文件比较详细明了。待熟悉后，可以自行选择主题。 Hugo主题库：https://themes.gohugo.io 个人推荐主题：https://github.com/dillonzq/LoveIt.git 在 Hugo 网站的根目录下（上文提及的 HugoWebsite）配置 config.toml(也有可能是hugo.toml) 详细配置参考: https://hugoloveit.com/zh-cn/theme-documentation-basics/ 在本地启动网站 hugo serve –buildDrafts 打开网址 http://localhost:1313/ 可以进行预览 如果发现预览效果不满意，可以 编辑 config.toml(hugo.toml) 文件 五.部署到 Github 构建 Hugo 网站 在 Hugo 网站文件夹的根目录（H:\\HugoWebsite\\blog）下执行 hugo 命令构建 Hugo 会将构建的网站内容默认保存至网站根目录下的 public/ 文件夹下。 将网站文件夹与 GitHub 建立联系**（仅第一次运行需要）** 进入 H:\\HugoWebsite\\blog\\public 目录，初始化 Git 库 生成的 HTML 文件保存在 “public” 目录中，“public” 文件夹会被转换为 Git 库。 git init 将 Git 本地库关联至远程库 在 H:\\HugoWebsite\\blog\\public 目录下，为 Git 本地库添加远程库，“https://github.com/adan-ning/adan-ning.github.io.git” git remote add origin https://github.com/adan-ning/adan-ning.github.io.git 提交修改 在 H:\\HugoWebsite\\blog\\public 目录下，通过如下命令提交： 查看当前修改状态 git status 添加修改过得文件， . 表示所有，也可以指定文件 git add . ““里面的内容就是提交内容的说明信息 git commit -m “first commit” 提交修改至远程库 在 H:\\HugoWebsite\\blog\\public 目录下，通过如下命令提交： git push -u origin master 然后如果按照博客顺序操作，第一次应该失败的。 因为本地的 git 库和远程的库并不是一致的，需要进行一次 pull 操作才能继续 push。 解决办法：先把除 .git 文件夹外的所有文件复制到其他目录备份，然后 git pull 当前库下的文件下来，然后把这些文件和自己需要的文件结合处理好（本次就是删除这些文件，再把原文件复制回来），重新提交即可。日常推荐这种方法，养成好习惯。 1.移动除 .git 外的文件到另一个目录下 2.pull 该库当前文件，最后的参数是因为合并两个不相关的项目（即，不知道彼此存在并且提交历史不匹配的项目）时，会发生Git错误：fatal: refusing to merge unrelated histories，此时出现记录文件，先按住 ctrl+:，再输入 wq 即可。 git pull origin master –allow-unrelated-histories 3.合并这些文件和第一次移动出去的文件，本次就是删除这些文件，把那些文件移动回来就好了 4.提交本地 git add . git commit -m “first commit” 5.提交远程 git push -u origin master 好了，第一次初始化配置也就成功完成了！输入：https://github用户名.github.io/ 就可以访问部署的网站了。 六.其他 新建文章 1.新建一篇文章，在网站根目录：H:\\HugoWebsite\\blog hugo new post/第二篇测试博客.md 2.在目录 H:\\HugoWebsite\\blog\\content\\post 下找到对应文件进行修改 3.本地预览, http://localhost:1313/ hugo server -D 4.构建 Hugo 网站 hugo 5.切换到目录 H:\\HugoWebsite\\blog\\public ，提交修改至本地库 git add . git commit -m ‘commit info’ 6.将修改推至远程库 git push -u origin master 修改文章 1.当前工作目录：H:\\HugoWebsite\\blog 2.在目录 H:\\HugoWebsite\\blog\\content\\post 下找到对应文件 进行修改 3.本地预览, http://localhost:1313/ hugo server -D 4.构建 Hugo 网站 hugo 5.切换到目录 H:\\HugoWebsite\\blog\\public ，提交修改至本地库 git add . git commit -m ‘commit info’ 6.将修改推至远程库 git push -u origin master 删除文章 1.当前工作目录：H:\\HugoWebsite\\blog 2.删除两处文件 在目录H:\\HugoWebsite\\blog\\content\\post ,H:\\HugoWebsite\\blog\\public 下找到对应文件进行删除 其中 public 下文件不删除也不影响显示，只是该文件就会一直存在，另外该目录下即便文件（除.git)删错或者全部删除也是不影响的，应为 hugo 命令会全部重建 3.本地预览, http://localhost:1313/ hugo server -D 4.构建 Hugo 网站 hugo 5.切换到目录 H:\\HugoWebsite\\blog\\public ，提交修改至本地库 git add . git commit -m ‘commit info’ 6.将修改推至远程库 git push -u origin master 添加图片 可参考：【博客写作指南】GitHub+jsDelivr+PicGo搭建博客图床 - 知乎 (zhihu.com) https://zhuanlan.zhihu.com/p/653131492 七.总结 可以将主题下相关文件复制到 blog 网站根目录下，因为这样可以直接渲染网站效果，而又不影响主题本身的内容。 主要是 themes\\LoveIt\\exampleSite 目录下文件 发布文章如果有参数 draft ，记得将值设为 false，或者删除 draft，不然会被认定为草稿只能本地运行而不能运行到网站上。 基本上就是安装 Hugo ，建站，下载主题，配置主题参数，然后部署就是了。 ","date":"2024-03-01","objectID":"/posts/%E6%90%AD%E5%BB%BAhugo%E5%8D%9A%E5%AE%A2buildblog/:1:0","tags":["hugo"],"title":"搭建hugo博客(buildblog)","uri":"/posts/%E6%90%AD%E5%BB%BAhugo%E5%8D%9A%E5%AE%A2buildblog/"},{"categories":["编程技术"],"content":"代码生成器 ","date":"2024-02-29","objectID":"/posts/%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E5%99%A8/:0:0","tags":["java"],"title":"CodeCreate(代码生成器)","uri":"/posts/%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E5%99%A8/"},{"categories":["编程技术"],"content":"前言 我们在编写一些由Springboot框架的系统时，会有很多类似的结构，而代码生成器则会帮我们自动生成这些结构，从而减少我们的代码量，是我们的编程效率得到大幅提高 ","date":"2024-02-29","objectID":"/posts/%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E5%99%A8/:1:0","tags":["java"],"title":"CodeCreate(代码生成器)","uri":"/posts/%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E5%99%A8/"},{"categories":["编程技术"],"content":"代码展示 import com.baomidou.mybatisplus.core.exceptions.MybatisPlusException; import com.baomidou.mybatisplus.core.toolkit.StringPool; import com.baomidou.mybatisplus.core.toolkit.StringUtils; import com.baomidou.mybatisplus.generator.AutoGenerator; import com.baomidou.mybatisplus.generator.InjectionConfig; import com.baomidou.mybatisplus.generator.config.*; import com.baomidou.mybatisplus.generator.config.po.TableInfo; import com.baomidou.mybatisplus.generator.config.rules.NamingStrategy; import com.baomidou.mybatisplus.generator.engine.FreemarkerTemplateEngine; import java.util.ArrayList; import java.util.List; import java.util.Scanner; public class CodeGenerator { /** * * @param tip * @return * 读取控制台内容 */ public static String scanner(String tip){ Scanner scanner = new Scanner(System.in); StringBuilder help = new StringBuilder(); help.append(\"请输入\"+tip+\":\"); System.out.println(help.toString()); if (scanner.hasNext()){ String ipt = scanner.next(); if (StringUtils.isNotBlank(ipt)){ return ipt; } } throw new MybatisPlusException(\"请输入正确的\"+tip+\"!\"); } /** * 操作步骤 * 1.修改数据源包括地址密码信息，对应代码标记：-，下同 * 2.模块配置，可以修改包名 * 3.修改模板，（这步可忽略） * @param args */ public static void main(String[] args){ //代码生成器 AutoGenerator mpg = new AutoGenerator(); //全局配置 GlobalConfig gc = new GlobalConfig(); String projectPath = System.getProperty(\"user.dir\"); gc.setOutputDir(projectPath+\"/src/main/java\"); gc.setAuthor(\"lqx\"); gc.setOpen(false); gc.setSwagger2(true);//实体属性 Swagger2注解 gc.setBaseResultMap(true);//XML ResultMap gc.setBaseColumnList(true);//XML ColumnList //去掉service接口首字母的I，如D0为UserService gc.setServiceName(\"%sService\"); mpg.setGlobalConfig(gc); //数据源配置 DataSourceConfig dsc = new DataSourceConfig(); //一，修改数据源 dsc.setUrl(\"jdbc:mysql://localhost:3306/db?serverTimezone=UTC\"); dsc.setDriverName(\"com.mysql.cj.jdbc.Driver\"); dsc.setUsername(\"root\"); dsc.setPassword(\"1234\"); mpg.setDataSource(dsc); //包配置 PackageConfig pc = new PackageConfig(); //二，模块配置 pc.setParent(\"com.lqx\") .setEntity(\"entity\") .setMapper(\"mapper\") .setService(\"service\") .setServiceImpl(\"service.impl\") .setController(\"controller\"); mpg.setPackageInfo(pc); //自定义配置 InjectionConfig cfg = new InjectionConfig() { @Override public void initMap() { // to do nothing } }; // 如果模板引擎是 freemarker String templatePath = \"/templates/mapper.xml.ftl\"; // 如果模板引擎是 velocity // String templatePath = \"/templates/mapper.xml.vm\"; // 自定义输出配置 List\u003cFileOutConfig\u003e focList = new ArrayList\u003c\u003e(); // 自定义配置会被优先输出 focList.add(new FileOutConfig(templatePath) { @Override public String outputFile(TableInfo tableInfo) { // 自定义输出文件名 ， 如果你 Entity 设置了前后缀、此处注意 xml 的名称会跟着发生变化！！ return projectPath + \"/src/main/resources/mapper/\" + pc.getModuleName() + \"/\" + tableInfo.getEntityName() + \"Mapper\" + StringPool.DOT_XML; } }); /* cfg.setFileCreate(new IFileCreate() { @Override public boolean isCreate(ConfigBuilder configBuilder, FileType fileType, String filePath) { // 判断自定义文件夹是否需要创建 checkDir(\"调用默认方法创建的目录，自定义目录用\"); if (fileType == FileType.MAPPER) { // 已经生成 mapper 文件判断存在，不想重新生成返回 false return !new File(filePath).exists(); } // 允许生成模板文件 return true; } }); */ cfg.setFileOutConfigList(focList); mpg.setCfg(cfg); // 配置模板 TemplateConfig templateConfig = new TemplateConfig(); // 配置自定义输出模板 //指定自定义模板路径，注意不要带上.ftl/.vm, 会根据使用的模板引擎自动识别 //三，修改模板 // templateConfig.setEntity(\"templates/entity2.java\"); // templateConfig.setService(); // templateConfig.setController(); templateConfig.setXml(null); mpg.setTemplate(templateConfig); // 策略配置 StrategyConfig strategy = new StrategyConfig(); strategy.setNaming(NamingStrategy.underline_to_camel); strategy.setColumnNaming(NamingStrategy.underline_to_camel); // strategy.setSuperEntityClass(\"你自己的父类实体,没有就不用设置!\"); strategy.setEntityLombokModel(true); strategy.setRestControllerStyle(true); // 公共父类 // strategy.setSuperControllerClass(\"你自己的父类控制器,没有就不用设置!\"); // 写于父类中的公共字段 // strategy.setSuperEntityColumns(\"id\"); strategy.setInclude(scanner(\"表名，多个英文逗号分割\").split(\",\")); strategy.setControllerMappingHyphenStyle(true); // strategy.se","date":"2024-02-29","objectID":"/posts/%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E5%99%A8/:2:0","tags":["java"],"title":"CodeCreate(代码生成器)","uri":"/posts/%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E5%99%A8/"},{"categories":["编程技术"],"content":"运行效果 ","date":"2024-02-29","objectID":"/posts/%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E5%99%A8/:3:0","tags":["java"],"title":"CodeCreate(代码生成器)","uri":"/posts/%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E5%99%A8/"},{"categories":["编程技术"],"content":"运行操作 ","date":"2024-02-29","objectID":"/posts/%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E5%99%A8/:3:1","tags":["java"],"title":"CodeCreate(代码生成器)","uri":"/posts/%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E5%99%A8/"},{"categories":["编程技术"],"content":"运行结果 ","date":"2024-02-29","objectID":"/posts/%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E5%99%A8/:3:2","tags":["java"],"title":"CodeCreate(代码生成器)","uri":"/posts/%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E5%99%A8/"},{"categories":["hugo"],"content":"每次更新hugo博客的操作 ","date":"2024-02-18","objectID":"/posts/%E6%AF%8F%E6%AC%A1%E6%9B%B4%E6%96%B0hugo%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%93%8D%E4%BD%9C/:0:0","tags":["hugo"],"title":"每次更新hugo博客的操作","uri":"/posts/%E6%AF%8F%E6%AC%A1%E6%9B%B4%E6%96%B0hugo%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%93%8D%E4%BD%9C/"},{"categories":["hugo"],"content":"每次更新hugo博客所需的操作 打开 PowerShell / cmd 终端，打开最初用 hugo 搭建的博客所在的文件夹，以我为例： cd e:\\myblog ","date":"2024-02-18","objectID":"/posts/%E6%AF%8F%E6%AC%A1%E6%9B%B4%E6%96%B0hugo%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%93%8D%E4%BD%9C/:1:0","tags":["hugo"],"title":"每次更新hugo博客的操作","uri":"/posts/%E6%AF%8F%E6%AC%A1%E6%9B%B4%E6%96%B0hugo%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%93%8D%E4%BD%9C/"},{"categories":["hugo"],"content":"第一步 新建一个 markdown(.md) 格式的文件(如果要修改原来的文件可不需要新建) hugo new post/FileName.md 其中 FileName 为自定义的文件名 ","date":"2024-02-18","objectID":"/posts/%E6%AF%8F%E6%AC%A1%E6%9B%B4%E6%96%B0hugo%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%93%8D%E4%BD%9C/:1:1","tags":["hugo"],"title":"每次更新hugo博客的操作","uri":"/posts/%E6%AF%8F%E6%AC%A1%E6%9B%B4%E6%96%B0hugo%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%93%8D%E4%BD%9C/"},{"categories":["hugo"],"content":"第二步 输入命令： hugo —theme=hugo-tranquilpeak-theme —baseUrl=\"https://tzq0301.github.io\" —buildDrafts 其中，hugo-tranquilpeak-theme 是我所应用的主题，https://tzq0301.github.io 是我的GitHub中为hugo博客配置的仓库 ","date":"2024-02-18","objectID":"/posts/%E6%AF%8F%E6%AC%A1%E6%9B%B4%E6%96%B0hugo%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%93%8D%E4%BD%9C/:1:2","tags":["hugo"],"title":"每次更新hugo博客的操作","uri":"/posts/%E6%AF%8F%E6%AC%A1%E6%9B%B4%E6%96%B0hugo%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%93%8D%E4%BD%9C/"},{"categories":["hugo"],"content":"第三步 把博客部署到远程GitHub仓库 首先切换到 public 文件夹： cd public 此时，正处于 e:\\myblog\\public 中 接下来输入以下指令： git add . git commit -m “yyyy/mm/dd-hh:mm” git push -u origin master 其中 yyyy/mm/dd-hh:mm 为每次提交的名称，引号内可以随意更改，yyyy/mm/dd-hh:mm 是我个人采用的格式，以时间做标记可保证不会重复 最后现在刷新GitHub，登陆个人博客查看即可 ","date":"2024-02-18","objectID":"/posts/%E6%AF%8F%E6%AC%A1%E6%9B%B4%E6%96%B0hugo%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%93%8D%E4%BD%9C/:1:3","tags":["hugo"],"title":"每次更新hugo博客的操作","uri":"/posts/%E6%AF%8F%E6%AC%A1%E6%9B%B4%E6%96%B0hugo%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%93%8D%E4%BD%9C/"}]